/* soapC.cpp
   Generated by gSOAP 2.7.17 from ./wsdl2h_generate/bz_560_service.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.17 2012-01-19 14:07:59 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns2__getSearchCarsInfResponse:
		return soap_in_ns2__getSearchCarsInfResponse(soap, NULL, NULL, "ns2:getSearchCarsInfResponse");
	case SOAP_TYPE_ns2__getSearchCarsInf:
		return soap_in_ns2__getSearchCarsInf(soap, NULL, NULL, "ns2:getSearchCarsInf");
	case SOAP_TYPE_ns2__getAgentPopAdResponse:
		return soap_in_ns2__getAgentPopAdResponse(soap, NULL, NULL, "ns2:getAgentPopAdResponse");
	case SOAP_TYPE_ns2__getAgentPopAd:
		return soap_in_ns2__getAgentPopAd(soap, NULL, NULL, "ns2:getAgentPopAd");
	case SOAP_TYPE_ns2__getSearchCarsInfNewResponse:
		return soap_in_ns2__getSearchCarsInfNewResponse(soap, NULL, NULL, "ns2:getSearchCarsInfNewResponse");
	case SOAP_TYPE_ns2__getSearchCarsInfNew:
		return soap_in_ns2__getSearchCarsInfNew(soap, NULL, NULL, "ns2:getSearchCarsInfNew");
	case SOAP_TYPE_ns2__delFavoriteSpecialLineResponse:
		return soap_in_ns2__delFavoriteSpecialLineResponse(soap, NULL, NULL, "ns2:delFavoriteSpecialLineResponse");
	case SOAP_TYPE_ns2__delFavoriteSpecialLine:
		return soap_in_ns2__delFavoriteSpecialLine(soap, NULL, NULL, "ns2:delFavoriteSpecialLine");
	case SOAP_TYPE_ns2__getNewGoodsInfResponse:
		return soap_in_ns2__getNewGoodsInfResponse(soap, NULL, NULL, "ns2:getNewGoodsInfResponse");
	case SOAP_TYPE_ns2__getNewGoodsInf:
		return soap_in_ns2__getNewGoodsInf(soap, NULL, NULL, "ns2:getNewGoodsInf");
	case SOAP_TYPE_ns2__getMySpecialLineInfResponse:
		return soap_in_ns2__getMySpecialLineInfResponse(soap, NULL, NULL, "ns2:getMySpecialLineInfResponse");
	case SOAP_TYPE_ns2__getMySpecialLineInf:
		return soap_in_ns2__getMySpecialLineInf(soap, NULL, NULL, "ns2:getMySpecialLineInf");
	case SOAP_TYPE_ns2__setPubSpecialLineInfResponse:
		return soap_in_ns2__setPubSpecialLineInfResponse(soap, NULL, NULL, "ns2:setPubSpecialLineInfResponse");
	case SOAP_TYPE_ns2__setPubSpecialLineInf:
		return soap_in_ns2__setPubSpecialLineInf(soap, NULL, NULL, "ns2:setPubSpecialLineInf");
	case SOAP_TYPE_ns2__delCarsInfResponse:
		return soap_in_ns2__delCarsInfResponse(soap, NULL, NULL, "ns2:delCarsInfResponse");
	case SOAP_TYPE_ns2__delCarsInf:
		return soap_in_ns2__delCarsInf(soap, NULL, NULL, "ns2:delCarsInf");
	case SOAP_TYPE_ns2__getPersisCarsInfoResponse:
		return soap_in_ns2__getPersisCarsInfoResponse(soap, NULL, NULL, "ns2:getPersisCarsInfoResponse");
	case SOAP_TYPE_ns2__getPersisCarsInfo:
		return soap_in_ns2__getPersisCarsInfo(soap, NULL, NULL, "ns2:getPersisCarsInfo");
	case SOAP_TYPE_ns2__browseZoneCarsResponse:
		return soap_in_ns2__browseZoneCarsResponse(soap, NULL, NULL, "ns2:browseZoneCarsResponse");
	case SOAP_TYPE_ns2__browseZoneCars:
		return soap_in_ns2__browseZoneCars(soap, NULL, NULL, "ns2:browseZoneCars");
	case SOAP_TYPE_ns2__placeOrderResponse:
		return soap_in_ns2__placeOrderResponse(soap, NULL, NULL, "ns2:placeOrderResponse");
	case SOAP_TYPE_ns2__placeOrder:
		return soap_in_ns2__placeOrder(soap, NULL, NULL, "ns2:placeOrder");
	case SOAP_TYPE_ns2__getPersisGoodsInfoResponse:
		return soap_in_ns2__getPersisGoodsInfoResponse(soap, NULL, NULL, "ns2:getPersisGoodsInfoResponse");
	case SOAP_TYPE_ns2__getPersisGoodsInfo:
		return soap_in_ns2__getPersisGoodsInfo(soap, NULL, NULL, "ns2:getPersisGoodsInfo");
	case SOAP_TYPE_ns2__usrLoginResponse:
		return soap_in_ns2__usrLoginResponse(soap, NULL, NULL, "ns2:usrLoginResponse");
	case SOAP_TYPE_ns2__usrLogin:
		return soap_in_ns2__usrLogin(soap, NULL, NULL, "ns2:usrLogin");
	case SOAP_TYPE_ns2__delBulkGoodsInfResponse:
		return soap_in_ns2__delBulkGoodsInfResponse(soap, NULL, NULL, "ns2:delBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__delBulkGoodsInf:
		return soap_in_ns2__delBulkGoodsInf(soap, NULL, NULL, "ns2:delBulkGoodsInf");
	case SOAP_TYPE_ns2__getClickSearchCarsInfResponse:
		return soap_in_ns2__getClickSearchCarsInfResponse(soap, NULL, NULL, "ns2:getClickSearchCarsInfResponse");
	case SOAP_TYPE_ns2__getClickSearchCarsInf:
		return soap_in_ns2__getClickSearchCarsInf(soap, NULL, NULL, "ns2:getClickSearchCarsInf");
	case SOAP_TYPE_ns2__setPubCarsInfResponse:
		return soap_in_ns2__setPubCarsInfResponse(soap, NULL, NULL, "ns2:setPubCarsInfResponse");
	case SOAP_TYPE_ns2__setPubCarsInf:
		return soap_in_ns2__setPubCarsInf(soap, NULL, NULL, "ns2:setPubCarsInf");
	case SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse:
		return soap_in_ns2__getSearchBulkGoodsInfResponse(soap, NULL, NULL, "ns2:getSearchBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__getSearchBulkGoodsInf:
		return soap_in_ns2__getSearchBulkGoodsInf(soap, NULL, NULL, "ns2:getSearchBulkGoodsInf");
	case SOAP_TYPE_ns2__setPubBulkGoodsInfResponse:
		return soap_in_ns2__setPubBulkGoodsInfResponse(soap, NULL, NULL, "ns2:setPubBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__setPubBulkGoodsInf:
		return soap_in_ns2__setPubBulkGoodsInf(soap, NULL, NULL, "ns2:setPubBulkGoodsInf");
	case SOAP_TYPE_ns2__getNewCarsInfResponse:
		return soap_in_ns2__getNewCarsInfResponse(soap, NULL, NULL, "ns2:getNewCarsInfResponse");
	case SOAP_TYPE_ns2__getNewCarsInf:
		return soap_in_ns2__getNewCarsInf(soap, NULL, NULL, "ns2:getNewCarsInf");
	case SOAP_TYPE_ns2__getClickSearchGoodsInfResponse:
		return soap_in_ns2__getClickSearchGoodsInfResponse(soap, NULL, NULL, "ns2:getClickSearchGoodsInfResponse");
	case SOAP_TYPE_ns2__getClickSearchGoodsInf:
		return soap_in_ns2__getClickSearchGoodsInf(soap, NULL, NULL, "ns2:getClickSearchGoodsInf");
	case SOAP_TYPE_ns2__setPubGoodsInfResponse:
		return soap_in_ns2__setPubGoodsInfResponse(soap, NULL, NULL, "ns2:setPubGoodsInfResponse");
	case SOAP_TYPE_ns2__setPubGoodsInf:
		return soap_in_ns2__setPubGoodsInf(soap, NULL, NULL, "ns2:setPubGoodsInf");
	case SOAP_TYPE_ns2__addUserCustomInfResponse:
		return soap_in_ns2__addUserCustomInfResponse(soap, NULL, NULL, "ns2:addUserCustomInfResponse");
	case SOAP_TYPE_ns2__addUserCustomInf:
		return soap_in_ns2__addUserCustomInf(soap, NULL, NULL, "ns2:addUserCustomInf");
	case SOAP_TYPE_ns2__getMyBulkGoodsInfResponse:
		return soap_in_ns2__getMyBulkGoodsInfResponse(soap, NULL, NULL, "ns2:getMyBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__getMyBulkGoodsInf:
		return soap_in_ns2__getMyBulkGoodsInf(soap, NULL, NULL, "ns2:getMyBulkGoodsInf");
	case SOAP_TYPE_ns2__delSpecialLineInfResponse:
		return soap_in_ns2__delSpecialLineInfResponse(soap, NULL, NULL, "ns2:delSpecialLineInfResponse");
	case SOAP_TYPE_ns2__delSpecialLineInf:
		return soap_in_ns2__delSpecialLineInf(soap, NULL, NULL, "ns2:delSpecialLineInf");
	case SOAP_TYPE_ns2__getAllSpecialLineInfResponse:
		return soap_in_ns2__getAllSpecialLineInfResponse(soap, NULL, NULL, "ns2:getAllSpecialLineInfResponse");
	case SOAP_TYPE_ns2__getAllSpecialLineInf:
		return soap_in_ns2__getAllSpecialLineInf(soap, NULL, NULL, "ns2:getAllSpecialLineInf");
	case SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse:
		return soap_in_ns2__getClickSearchSpecialLineInfResponse(soap, NULL, NULL, "ns2:getClickSearchSpecialLineInfResponse");
	case SOAP_TYPE_ns2__getClickSearchSpecialLineInf:
		return soap_in_ns2__getClickSearchSpecialLineInf(soap, NULL, NULL, "ns2:getClickSearchSpecialLineInf");
	case SOAP_TYPE_ns2__checkChargeUserResponse:
		return soap_in_ns2__checkChargeUserResponse(soap, NULL, NULL, "ns2:checkChargeUserResponse");
	case SOAP_TYPE_ns2__checkChargeUser:
		return soap_in_ns2__checkChargeUser(soap, NULL, NULL, "ns2:checkChargeUser");
	case SOAP_TYPE_ns2__deleteUserCustomInfResponse:
		return soap_in_ns2__deleteUserCustomInfResponse(soap, NULL, NULL, "ns2:deleteUserCustomInfResponse");
	case SOAP_TYPE_ns2__deleteUserCustomInf:
		return soap_in_ns2__deleteUserCustomInf(soap, NULL, NULL, "ns2:deleteUserCustomInf");
	case SOAP_TYPE_ns2__setServiceStationInfResponse:
		return soap_in_ns2__setServiceStationInfResponse(soap, NULL, NULL, "ns2:setServiceStationInfResponse");
	case SOAP_TYPE_ns2__setServiceStationInf:
		return soap_in_ns2__setServiceStationInf(soap, NULL, NULL, "ns2:setServiceStationInf");
	case SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse:
		return soap_in_ns2__getClickSearchBulkGoodsInfResponse(soap, NULL, NULL, "ns2:getClickSearchBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__getClickSearchBulkGoodsInf:
		return soap_in_ns2__getClickSearchBulkGoodsInf(soap, NULL, NULL, "ns2:getClickSearchBulkGoodsInf");
	case SOAP_TYPE_ns2__getCustomGoodsInfResponse:
		return soap_in_ns2__getCustomGoodsInfResponse(soap, NULL, NULL, "ns2:getCustomGoodsInfResponse");
	case SOAP_TYPE_ns2__getCustomGoodsInf:
		return soap_in_ns2__getCustomGoodsInf(soap, NULL, NULL, "ns2:getCustomGoodsInf");
	case SOAP_TYPE_ns2__getAgentScrollAdResponse:
		return soap_in_ns2__getAgentScrollAdResponse(soap, NULL, NULL, "ns2:getAgentScrollAdResponse");
	case SOAP_TYPE_ns2__getAgentScrollAd:
		return soap_in_ns2__getAgentScrollAd(soap, NULL, NULL, "ns2:getAgentScrollAd");
	case SOAP_TYPE_ns2__getSystemScrollAdResponse:
		return soap_in_ns2__getSystemScrollAdResponse(soap, NULL, NULL, "ns2:getSystemScrollAdResponse");
	case SOAP_TYPE_ns2__getSystemScrollAd:
		return soap_in_ns2__getSystemScrollAd(soap, NULL, NULL, "ns2:getSystemScrollAd");
	case SOAP_TYPE_ns2__getMyGoodsInfResponse:
		return soap_in_ns2__getMyGoodsInfResponse(soap, NULL, NULL, "ns2:getMyGoodsInfResponse");
	case SOAP_TYPE_ns2__getMyGoodsInf:
		return soap_in_ns2__getMyGoodsInf(soap, NULL, NULL, "ns2:getMyGoodsInf");
	case SOAP_TYPE_ns2__getSearchGoodsInfNewResponse:
		return soap_in_ns2__getSearchGoodsInfNewResponse(soap, NULL, NULL, "ns2:getSearchGoodsInfNewResponse");
	case SOAP_TYPE_ns2__getSearchGoodsInfNew:
		return soap_in_ns2__getSearchGoodsInfNew(soap, NULL, NULL, "ns2:getSearchGoodsInfNew");
	case SOAP_TYPE_ns2__getSearchGoodsInfResponse:
		return soap_in_ns2__getSearchGoodsInfResponse(soap, NULL, NULL, "ns2:getSearchGoodsInfResponse");
	case SOAP_TYPE_ns2__getSearchGoodsInf:
		return soap_in_ns2__getSearchGoodsInf(soap, NULL, NULL, "ns2:getSearchGoodsInf");
	case SOAP_TYPE_ns2__delGoodsInfResponse:
		return soap_in_ns2__delGoodsInfResponse(soap, NULL, NULL, "ns2:delGoodsInfResponse");
	case SOAP_TYPE_ns2__delGoodsInf:
		return soap_in_ns2__delGoodsInf(soap, NULL, NULL, "ns2:delGoodsInf");
	case SOAP_TYPE_ns2__getCustomCarsInfResponse:
		return soap_in_ns2__getCustomCarsInfResponse(soap, NULL, NULL, "ns2:getCustomCarsInfResponse");
	case SOAP_TYPE_ns2__getCustomCarsInf:
		return soap_in_ns2__getCustomCarsInf(soap, NULL, NULL, "ns2:getCustomCarsInf");
	case SOAP_TYPE_ns2__setGoodsStatusResponse:
		return soap_in_ns2__setGoodsStatusResponse(soap, NULL, NULL, "ns2:setGoodsStatusResponse");
	case SOAP_TYPE_ns2__setGoodsStatus:
		return soap_in_ns2__setGoodsStatus(soap, NULL, NULL, "ns2:setGoodsStatus");
	case SOAP_TYPE_ns2__getClickServiceStationInfResponse:
		return soap_in_ns2__getClickServiceStationInfResponse(soap, NULL, NULL, "ns2:getClickServiceStationInfResponse");
	case SOAP_TYPE_ns2__getClickServiceStationInf:
		return soap_in_ns2__getClickServiceStationInf(soap, NULL, NULL, "ns2:getClickServiceStationInf");
	case SOAP_TYPE_ns2__getSearchSpecialLineInfResponse:
		return soap_in_ns2__getSearchSpecialLineInfResponse(soap, NULL, NULL, "ns2:getSearchSpecialLineInfResponse");
	case SOAP_TYPE_ns2__getSearchSpecialLineInf:
		return soap_in_ns2__getSearchSpecialLineInf(soap, NULL, NULL, "ns2:getSearchSpecialLineInf");
	case SOAP_TYPE_ns2__setCarsStatusResponse:
		return soap_in_ns2__setCarsStatusResponse(soap, NULL, NULL, "ns2:setCarsStatusResponse");
	case SOAP_TYPE_ns2__setCarsStatus:
		return soap_in_ns2__setCarsStatus(soap, NULL, NULL, "ns2:setCarsStatus");
	case SOAP_TYPE_ns2__sendPhoneMessageResponse:
		return soap_in_ns2__sendPhoneMessageResponse(soap, NULL, NULL, "ns2:sendPhoneMessageResponse");
	case SOAP_TYPE_ns2__sendPhoneMessage:
		return soap_in_ns2__sendPhoneMessage(soap, NULL, NULL, "ns2:sendPhoneMessage");
	case SOAP_TYPE_ns2__getMyCarsInfResponse:
		return soap_in_ns2__getMyCarsInfResponse(soap, NULL, NULL, "ns2:getMyCarsInfResponse");
	case SOAP_TYPE_ns2__getMyCarsInf:
		return soap_in_ns2__getMyCarsInf(soap, NULL, NULL, "ns2:getMyCarsInf");
	case SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse:
		return soap_in_ns2__getFavoriteSpecialLineInfResponse(soap, NULL, NULL, "ns2:getFavoriteSpecialLineInfResponse");
	case SOAP_TYPE_ns2__getFavoriteSpecialLineInf:
		return soap_in_ns2__getFavoriteSpecialLineInf(soap, NULL, NULL, "ns2:getFavoriteSpecialLineInf");
	case SOAP_TYPE_ns2__getUserCustomInfResponse:
		return soap_in_ns2__getUserCustomInfResponse(soap, NULL, NULL, "ns2:getUserCustomInfResponse");
	case SOAP_TYPE_ns2__getUserCustomInf:
		return soap_in_ns2__getUserCustomInf(soap, NULL, NULL, "ns2:getUserCustomInf");
	case SOAP_TYPE_ns2__collectSpecialLineResponse:
		return soap_in_ns2__collectSpecialLineResponse(soap, NULL, NULL, "ns2:collectSpecialLineResponse");
	case SOAP_TYPE_ns2__collectSpecialLine:
		return soap_in_ns2__collectSpecialLine(soap, NULL, NULL, "ns2:collectSpecialLine");
	case SOAP_TYPE_ns2__getNewBulkGoodsInfResponse:
		return soap_in_ns2__getNewBulkGoodsInfResponse(soap, NULL, NULL, "ns2:getNewBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__getNewBulkGoodsInf:
		return soap_in_ns2__getNewBulkGoodsInf(soap, NULL, NULL, "ns2:getNewBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__getSearchCarsInfResponse:
		return soap_in_PointerTons2__getSearchCarsInfResponse(soap, NULL, NULL, "ns2:getSearchCarsInfResponse");
	case SOAP_TYPE_PointerTons2__getSearchCarsInf:
		return soap_in_PointerTons2__getSearchCarsInf(soap, NULL, NULL, "ns2:getSearchCarsInf");
	case SOAP_TYPE_PointerTons2__getAgentPopAdResponse:
		return soap_in_PointerTons2__getAgentPopAdResponse(soap, NULL, NULL, "ns2:getAgentPopAdResponse");
	case SOAP_TYPE_PointerTons2__getAgentPopAd:
		return soap_in_PointerTons2__getAgentPopAd(soap, NULL, NULL, "ns2:getAgentPopAd");
	case SOAP_TYPE_PointerTons2__getSearchCarsInfNewResponse:
		return soap_in_PointerTons2__getSearchCarsInfNewResponse(soap, NULL, NULL, "ns2:getSearchCarsInfNewResponse");
	case SOAP_TYPE_PointerTons2__getSearchCarsInfNew:
		return soap_in_PointerTons2__getSearchCarsInfNew(soap, NULL, NULL, "ns2:getSearchCarsInfNew");
	case SOAP_TYPE_PointerTons2__delFavoriteSpecialLineResponse:
		return soap_in_PointerTons2__delFavoriteSpecialLineResponse(soap, NULL, NULL, "ns2:delFavoriteSpecialLineResponse");
	case SOAP_TYPE_PointerTons2__delFavoriteSpecialLine:
		return soap_in_PointerTons2__delFavoriteSpecialLine(soap, NULL, NULL, "ns2:delFavoriteSpecialLine");
	case SOAP_TYPE_PointerTons2__getNewGoodsInfResponse:
		return soap_in_PointerTons2__getNewGoodsInfResponse(soap, NULL, NULL, "ns2:getNewGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getNewGoodsInf:
		return soap_in_PointerTons2__getNewGoodsInf(soap, NULL, NULL, "ns2:getNewGoodsInf");
	case SOAP_TYPE_PointerTons2__setPubSpecialLineInfResponse:
		return soap_in_PointerTons2__setPubSpecialLineInfResponse(soap, NULL, NULL, "ns2:setPubSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__setPubSpecialLineInf:
		return soap_in_PointerTons2__setPubSpecialLineInf(soap, NULL, NULL, "ns2:setPubSpecialLineInf");
	case SOAP_TYPE_PointerTons2__getMySpecialLineInfResponse:
		return soap_in_PointerTons2__getMySpecialLineInfResponse(soap, NULL, NULL, "ns2:getMySpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__getMySpecialLineInf:
		return soap_in_PointerTons2__getMySpecialLineInf(soap, NULL, NULL, "ns2:getMySpecialLineInf");
	case SOAP_TYPE_PointerTons2__delCarsInfResponse:
		return soap_in_PointerTons2__delCarsInfResponse(soap, NULL, NULL, "ns2:delCarsInfResponse");
	case SOAP_TYPE_PointerTons2__delCarsInf:
		return soap_in_PointerTons2__delCarsInf(soap, NULL, NULL, "ns2:delCarsInf");
	case SOAP_TYPE_PointerTons2__getPersisCarsInfoResponse:
		return soap_in_PointerTons2__getPersisCarsInfoResponse(soap, NULL, NULL, "ns2:getPersisCarsInfoResponse");
	case SOAP_TYPE_PointerTons2__getPersisCarsInfo:
		return soap_in_PointerTons2__getPersisCarsInfo(soap, NULL, NULL, "ns2:getPersisCarsInfo");
	case SOAP_TYPE_PointerTons2__placeOrderResponse:
		return soap_in_PointerTons2__placeOrderResponse(soap, NULL, NULL, "ns2:placeOrderResponse");
	case SOAP_TYPE_PointerTons2__placeOrder:
		return soap_in_PointerTons2__placeOrder(soap, NULL, NULL, "ns2:placeOrder");
	case SOAP_TYPE_PointerTons2__browseZoneCarsResponse:
		return soap_in_PointerTons2__browseZoneCarsResponse(soap, NULL, NULL, "ns2:browseZoneCarsResponse");
	case SOAP_TYPE_PointerTons2__browseZoneCars:
		return soap_in_PointerTons2__browseZoneCars(soap, NULL, NULL, "ns2:browseZoneCars");
	case SOAP_TYPE_PointerTons2__getPersisGoodsInfoResponse:
		return soap_in_PointerTons2__getPersisGoodsInfoResponse(soap, NULL, NULL, "ns2:getPersisGoodsInfoResponse");
	case SOAP_TYPE_PointerTons2__getPersisGoodsInfo:
		return soap_in_PointerTons2__getPersisGoodsInfo(soap, NULL, NULL, "ns2:getPersisGoodsInfo");
	case SOAP_TYPE_PointerTons2__usrLoginResponse:
		return soap_in_PointerTons2__usrLoginResponse(soap, NULL, NULL, "ns2:usrLoginResponse");
	case SOAP_TYPE_PointerTons2__usrLogin:
		return soap_in_PointerTons2__usrLogin(soap, NULL, NULL, "ns2:usrLogin");
	case SOAP_TYPE_PointerTons2__delBulkGoodsInfResponse:
		return soap_in_PointerTons2__delBulkGoodsInfResponse(soap, NULL, NULL, "ns2:delBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__delBulkGoodsInf:
		return soap_in_PointerTons2__delBulkGoodsInf(soap, NULL, NULL, "ns2:delBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__getClickSearchCarsInfResponse:
		return soap_in_PointerTons2__getClickSearchCarsInfResponse(soap, NULL, NULL, "ns2:getClickSearchCarsInfResponse");
	case SOAP_TYPE_PointerTons2__getClickSearchCarsInf:
		return soap_in_PointerTons2__getClickSearchCarsInf(soap, NULL, NULL, "ns2:getClickSearchCarsInf");
	case SOAP_TYPE_PointerTons2__setPubCarsInfResponse:
		return soap_in_PointerTons2__setPubCarsInfResponse(soap, NULL, NULL, "ns2:setPubCarsInfResponse");
	case SOAP_TYPE_PointerTons2__setPubCarsInf:
		return soap_in_PointerTons2__setPubCarsInf(soap, NULL, NULL, "ns2:setPubCarsInf");
	case SOAP_TYPE_PointerTons2__setPubBulkGoodsInfResponse:
		return soap_in_PointerTons2__setPubBulkGoodsInfResponse(soap, NULL, NULL, "ns2:setPubBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__setPubBulkGoodsInf:
		return soap_in_PointerTons2__setPubBulkGoodsInf(soap, NULL, NULL, "ns2:setPubBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__getSearchBulkGoodsInfResponse:
		return soap_in_PointerTons2__getSearchBulkGoodsInfResponse(soap, NULL, NULL, "ns2:getSearchBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getSearchBulkGoodsInf:
		return soap_in_PointerTons2__getSearchBulkGoodsInf(soap, NULL, NULL, "ns2:getSearchBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__getNewCarsInfResponse:
		return soap_in_PointerTons2__getNewCarsInfResponse(soap, NULL, NULL, "ns2:getNewCarsInfResponse");
	case SOAP_TYPE_PointerTons2__getNewCarsInf:
		return soap_in_PointerTons2__getNewCarsInf(soap, NULL, NULL, "ns2:getNewCarsInf");
	case SOAP_TYPE_PointerTons2__setPubGoodsInfResponse:
		return soap_in_PointerTons2__setPubGoodsInfResponse(soap, NULL, NULL, "ns2:setPubGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__setPubGoodsInf:
		return soap_in_PointerTons2__setPubGoodsInf(soap, NULL, NULL, "ns2:setPubGoodsInf");
	case SOAP_TYPE_PointerTons2__getClickSearchGoodsInfResponse:
		return soap_in_PointerTons2__getClickSearchGoodsInfResponse(soap, NULL, NULL, "ns2:getClickSearchGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getClickSearchGoodsInf:
		return soap_in_PointerTons2__getClickSearchGoodsInf(soap, NULL, NULL, "ns2:getClickSearchGoodsInf");
	case SOAP_TYPE_PointerTons2__addUserCustomInfResponse:
		return soap_in_PointerTons2__addUserCustomInfResponse(soap, NULL, NULL, "ns2:addUserCustomInfResponse");
	case SOAP_TYPE_PointerTons2__addUserCustomInf:
		return soap_in_PointerTons2__addUserCustomInf(soap, NULL, NULL, "ns2:addUserCustomInf");
	case SOAP_TYPE_PointerTons2__getMyBulkGoodsInfResponse:
		return soap_in_PointerTons2__getMyBulkGoodsInfResponse(soap, NULL, NULL, "ns2:getMyBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getMyBulkGoodsInf:
		return soap_in_PointerTons2__getMyBulkGoodsInf(soap, NULL, NULL, "ns2:getMyBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__delSpecialLineInfResponse:
		return soap_in_PointerTons2__delSpecialLineInfResponse(soap, NULL, NULL, "ns2:delSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__delSpecialLineInf:
		return soap_in_PointerTons2__delSpecialLineInf(soap, NULL, NULL, "ns2:delSpecialLineInf");
	case SOAP_TYPE_PointerTons2__getClickSearchSpecialLineInfResponse:
		return soap_in_PointerTons2__getClickSearchSpecialLineInfResponse(soap, NULL, NULL, "ns2:getClickSearchSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__getClickSearchSpecialLineInf:
		return soap_in_PointerTons2__getClickSearchSpecialLineInf(soap, NULL, NULL, "ns2:getClickSearchSpecialLineInf");
	case SOAP_TYPE_PointerTons2__getAllSpecialLineInfResponse:
		return soap_in_PointerTons2__getAllSpecialLineInfResponse(soap, NULL, NULL, "ns2:getAllSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__getAllSpecialLineInf:
		return soap_in_PointerTons2__getAllSpecialLineInf(soap, NULL, NULL, "ns2:getAllSpecialLineInf");
	case SOAP_TYPE_PointerTons2__setServiceStationInfResponse:
		return soap_in_PointerTons2__setServiceStationInfResponse(soap, NULL, NULL, "ns2:setServiceStationInfResponse");
	case SOAP_TYPE_PointerTons2__setServiceStationInf:
		return soap_in_PointerTons2__setServiceStationInf(soap, NULL, NULL, "ns2:setServiceStationInf");
	case SOAP_TYPE_PointerTons2__deleteUserCustomInfResponse:
		return soap_in_PointerTons2__deleteUserCustomInfResponse(soap, NULL, NULL, "ns2:deleteUserCustomInfResponse");
	case SOAP_TYPE_PointerTons2__deleteUserCustomInf:
		return soap_in_PointerTons2__deleteUserCustomInf(soap, NULL, NULL, "ns2:deleteUserCustomInf");
	case SOAP_TYPE_PointerTons2__checkChargeUserResponse:
		return soap_in_PointerTons2__checkChargeUserResponse(soap, NULL, NULL, "ns2:checkChargeUserResponse");
	case SOAP_TYPE_PointerTons2__checkChargeUser:
		return soap_in_PointerTons2__checkChargeUser(soap, NULL, NULL, "ns2:checkChargeUser");
	case SOAP_TYPE_PointerTons2__getClickSearchBulkGoodsInfResponse:
		return soap_in_PointerTons2__getClickSearchBulkGoodsInfResponse(soap, NULL, NULL, "ns2:getClickSearchBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getClickSearchBulkGoodsInf:
		return soap_in_PointerTons2__getClickSearchBulkGoodsInf(soap, NULL, NULL, "ns2:getClickSearchBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__getCustomGoodsInfResponse:
		return soap_in_PointerTons2__getCustomGoodsInfResponse(soap, NULL, NULL, "ns2:getCustomGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getCustomGoodsInf:
		return soap_in_PointerTons2__getCustomGoodsInf(soap, NULL, NULL, "ns2:getCustomGoodsInf");
	case SOAP_TYPE_PointerTons2__getAgentScrollAdResponse:
		return soap_in_PointerTons2__getAgentScrollAdResponse(soap, NULL, NULL, "ns2:getAgentScrollAdResponse");
	case SOAP_TYPE_PointerTons2__getAgentScrollAd:
		return soap_in_PointerTons2__getAgentScrollAd(soap, NULL, NULL, "ns2:getAgentScrollAd");
	case SOAP_TYPE_PointerTons2__getSystemScrollAdResponse:
		return soap_in_PointerTons2__getSystemScrollAdResponse(soap, NULL, NULL, "ns2:getSystemScrollAdResponse");
	case SOAP_TYPE_PointerTons2__getSystemScrollAd:
		return soap_in_PointerTons2__getSystemScrollAd(soap, NULL, NULL, "ns2:getSystemScrollAd");
	case SOAP_TYPE_PointerTons2__getMyGoodsInfResponse:
		return soap_in_PointerTons2__getMyGoodsInfResponse(soap, NULL, NULL, "ns2:getMyGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getMyGoodsInf:
		return soap_in_PointerTons2__getMyGoodsInf(soap, NULL, NULL, "ns2:getMyGoodsInf");
	case SOAP_TYPE_PointerTons2__getSearchGoodsInfNewResponse:
		return soap_in_PointerTons2__getSearchGoodsInfNewResponse(soap, NULL, NULL, "ns2:getSearchGoodsInfNewResponse");
	case SOAP_TYPE_PointerTons2__getSearchGoodsInfNew:
		return soap_in_PointerTons2__getSearchGoodsInfNew(soap, NULL, NULL, "ns2:getSearchGoodsInfNew");
	case SOAP_TYPE_PointerTons2__getSearchGoodsInfResponse:
		return soap_in_PointerTons2__getSearchGoodsInfResponse(soap, NULL, NULL, "ns2:getSearchGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getSearchGoodsInf:
		return soap_in_PointerTons2__getSearchGoodsInf(soap, NULL, NULL, "ns2:getSearchGoodsInf");
	case SOAP_TYPE_PointerTons2__delGoodsInfResponse:
		return soap_in_PointerTons2__delGoodsInfResponse(soap, NULL, NULL, "ns2:delGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__delGoodsInf:
		return soap_in_PointerTons2__delGoodsInf(soap, NULL, NULL, "ns2:delGoodsInf");
	case SOAP_TYPE_PointerTons2__setGoodsStatusResponse:
		return soap_in_PointerTons2__setGoodsStatusResponse(soap, NULL, NULL, "ns2:setGoodsStatusResponse");
	case SOAP_TYPE_PointerTons2__setGoodsStatus:
		return soap_in_PointerTons2__setGoodsStatus(soap, NULL, NULL, "ns2:setGoodsStatus");
	case SOAP_TYPE_PointerTons2__getCustomCarsInfResponse:
		return soap_in_PointerTons2__getCustomCarsInfResponse(soap, NULL, NULL, "ns2:getCustomCarsInfResponse");
	case SOAP_TYPE_PointerTons2__getCustomCarsInf:
		return soap_in_PointerTons2__getCustomCarsInf(soap, NULL, NULL, "ns2:getCustomCarsInf");
	case SOAP_TYPE_PointerTons2__getSearchSpecialLineInfResponse:
		return soap_in_PointerTons2__getSearchSpecialLineInfResponse(soap, NULL, NULL, "ns2:getSearchSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__getSearchSpecialLineInf:
		return soap_in_PointerTons2__getSearchSpecialLineInf(soap, NULL, NULL, "ns2:getSearchSpecialLineInf");
	case SOAP_TYPE_PointerTons2__getClickServiceStationInfResponse:
		return soap_in_PointerTons2__getClickServiceStationInfResponse(soap, NULL, NULL, "ns2:getClickServiceStationInfResponse");
	case SOAP_TYPE_PointerTons2__getClickServiceStationInf:
		return soap_in_PointerTons2__getClickServiceStationInf(soap, NULL, NULL, "ns2:getClickServiceStationInf");
	case SOAP_TYPE_PointerTons2__setCarsStatusResponse:
		return soap_in_PointerTons2__setCarsStatusResponse(soap, NULL, NULL, "ns2:setCarsStatusResponse");
	case SOAP_TYPE_PointerTons2__setCarsStatus:
		return soap_in_PointerTons2__setCarsStatus(soap, NULL, NULL, "ns2:setCarsStatus");
	case SOAP_TYPE_PointerTons2__sendPhoneMessageResponse:
		return soap_in_PointerTons2__sendPhoneMessageResponse(soap, NULL, NULL, "ns2:sendPhoneMessageResponse");
	case SOAP_TYPE_PointerTons2__sendPhoneMessage:
		return soap_in_PointerTons2__sendPhoneMessage(soap, NULL, NULL, "ns2:sendPhoneMessage");
	case SOAP_TYPE_PointerTons2__getMyCarsInfResponse:
		return soap_in_PointerTons2__getMyCarsInfResponse(soap, NULL, NULL, "ns2:getMyCarsInfResponse");
	case SOAP_TYPE_PointerTons2__getMyCarsInf:
		return soap_in_PointerTons2__getMyCarsInf(soap, NULL, NULL, "ns2:getMyCarsInf");
	case SOAP_TYPE_PointerTons2__getUserCustomInfResponse:
		return soap_in_PointerTons2__getUserCustomInfResponse(soap, NULL, NULL, "ns2:getUserCustomInfResponse");
	case SOAP_TYPE_PointerTons2__getUserCustomInf:
		return soap_in_PointerTons2__getUserCustomInf(soap, NULL, NULL, "ns2:getUserCustomInf");
	case SOAP_TYPE_PointerTons2__getFavoriteSpecialLineInfResponse:
		return soap_in_PointerTons2__getFavoriteSpecialLineInfResponse(soap, NULL, NULL, "ns2:getFavoriteSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__getFavoriteSpecialLineInf:
		return soap_in_PointerTons2__getFavoriteSpecialLineInf(soap, NULL, NULL, "ns2:getFavoriteSpecialLineInf");
	case SOAP_TYPE_PointerTons2__collectSpecialLineResponse:
		return soap_in_PointerTons2__collectSpecialLineResponse(soap, NULL, NULL, "ns2:collectSpecialLineResponse");
	case SOAP_TYPE_PointerTons2__collectSpecialLine:
		return soap_in_PointerTons2__collectSpecialLine(soap, NULL, NULL, "ns2:collectSpecialLine");
	case SOAP_TYPE_PointerTons2__getNewBulkGoodsInfResponse:
		return soap_in_PointerTons2__getNewBulkGoodsInfResponse(soap, NULL, NULL, "ns2:getNewBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getNewBulkGoodsInf:
		return soap_in_PointerTons2__getNewBulkGoodsInf(soap, NULL, NULL, "ns2:getNewBulkGoodsInf");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchCarsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getSearchCarsInfResponse;
			return soap_in_ns2__getSearchCarsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchCarsInf"))
		{	*type = SOAP_TYPE_ns2__getSearchCarsInf;
			return soap_in_ns2__getSearchCarsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getAgentPopAdResponse"))
		{	*type = SOAP_TYPE_ns2__getAgentPopAdResponse;
			return soap_in_ns2__getAgentPopAdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getAgentPopAd"))
		{	*type = SOAP_TYPE_ns2__getAgentPopAd;
			return soap_in_ns2__getAgentPopAd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchCarsInfNewResponse"))
		{	*type = SOAP_TYPE_ns2__getSearchCarsInfNewResponse;
			return soap_in_ns2__getSearchCarsInfNewResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchCarsInfNew"))
		{	*type = SOAP_TYPE_ns2__getSearchCarsInfNew;
			return soap_in_ns2__getSearchCarsInfNew(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:delFavoriteSpecialLineResponse"))
		{	*type = SOAP_TYPE_ns2__delFavoriteSpecialLineResponse;
			return soap_in_ns2__delFavoriteSpecialLineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:delFavoriteSpecialLine"))
		{	*type = SOAP_TYPE_ns2__delFavoriteSpecialLine;
			return soap_in_ns2__delFavoriteSpecialLine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getNewGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getNewGoodsInfResponse;
			return soap_in_ns2__getNewGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getNewGoodsInf"))
		{	*type = SOAP_TYPE_ns2__getNewGoodsInf;
			return soap_in_ns2__getNewGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMySpecialLineInfResponse"))
		{	*type = SOAP_TYPE_ns2__getMySpecialLineInfResponse;
			return soap_in_ns2__getMySpecialLineInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMySpecialLineInf"))
		{	*type = SOAP_TYPE_ns2__getMySpecialLineInf;
			return soap_in_ns2__getMySpecialLineInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setPubSpecialLineInfResponse"))
		{	*type = SOAP_TYPE_ns2__setPubSpecialLineInfResponse;
			return soap_in_ns2__setPubSpecialLineInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setPubSpecialLineInf"))
		{	*type = SOAP_TYPE_ns2__setPubSpecialLineInf;
			return soap_in_ns2__setPubSpecialLineInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:delCarsInfResponse"))
		{	*type = SOAP_TYPE_ns2__delCarsInfResponse;
			return soap_in_ns2__delCarsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:delCarsInf"))
		{	*type = SOAP_TYPE_ns2__delCarsInf;
			return soap_in_ns2__delCarsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getPersisCarsInfoResponse"))
		{	*type = SOAP_TYPE_ns2__getPersisCarsInfoResponse;
			return soap_in_ns2__getPersisCarsInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getPersisCarsInfo"))
		{	*type = SOAP_TYPE_ns2__getPersisCarsInfo;
			return soap_in_ns2__getPersisCarsInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:browseZoneCarsResponse"))
		{	*type = SOAP_TYPE_ns2__browseZoneCarsResponse;
			return soap_in_ns2__browseZoneCarsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:browseZoneCars"))
		{	*type = SOAP_TYPE_ns2__browseZoneCars;
			return soap_in_ns2__browseZoneCars(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:placeOrderResponse"))
		{	*type = SOAP_TYPE_ns2__placeOrderResponse;
			return soap_in_ns2__placeOrderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:placeOrder"))
		{	*type = SOAP_TYPE_ns2__placeOrder;
			return soap_in_ns2__placeOrder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getPersisGoodsInfoResponse"))
		{	*type = SOAP_TYPE_ns2__getPersisGoodsInfoResponse;
			return soap_in_ns2__getPersisGoodsInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getPersisGoodsInfo"))
		{	*type = SOAP_TYPE_ns2__getPersisGoodsInfo;
			return soap_in_ns2__getPersisGoodsInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:usrLoginResponse"))
		{	*type = SOAP_TYPE_ns2__usrLoginResponse;
			return soap_in_ns2__usrLoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:usrLogin"))
		{	*type = SOAP_TYPE_ns2__usrLogin;
			return soap_in_ns2__usrLogin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:delBulkGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__delBulkGoodsInfResponse;
			return soap_in_ns2__delBulkGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:delBulkGoodsInf"))
		{	*type = SOAP_TYPE_ns2__delBulkGoodsInf;
			return soap_in_ns2__delBulkGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClickSearchCarsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getClickSearchCarsInfResponse;
			return soap_in_ns2__getClickSearchCarsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClickSearchCarsInf"))
		{	*type = SOAP_TYPE_ns2__getClickSearchCarsInf;
			return soap_in_ns2__getClickSearchCarsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setPubCarsInfResponse"))
		{	*type = SOAP_TYPE_ns2__setPubCarsInfResponse;
			return soap_in_ns2__setPubCarsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setPubCarsInf"))
		{	*type = SOAP_TYPE_ns2__setPubCarsInf;
			return soap_in_ns2__setPubCarsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchBulkGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse;
			return soap_in_ns2__getSearchBulkGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchBulkGoodsInf"))
		{	*type = SOAP_TYPE_ns2__getSearchBulkGoodsInf;
			return soap_in_ns2__getSearchBulkGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setPubBulkGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__setPubBulkGoodsInfResponse;
			return soap_in_ns2__setPubBulkGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setPubBulkGoodsInf"))
		{	*type = SOAP_TYPE_ns2__setPubBulkGoodsInf;
			return soap_in_ns2__setPubBulkGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getNewCarsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getNewCarsInfResponse;
			return soap_in_ns2__getNewCarsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getNewCarsInf"))
		{	*type = SOAP_TYPE_ns2__getNewCarsInf;
			return soap_in_ns2__getNewCarsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClickSearchGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getClickSearchGoodsInfResponse;
			return soap_in_ns2__getClickSearchGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClickSearchGoodsInf"))
		{	*type = SOAP_TYPE_ns2__getClickSearchGoodsInf;
			return soap_in_ns2__getClickSearchGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setPubGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__setPubGoodsInfResponse;
			return soap_in_ns2__setPubGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setPubGoodsInf"))
		{	*type = SOAP_TYPE_ns2__setPubGoodsInf;
			return soap_in_ns2__setPubGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:addUserCustomInfResponse"))
		{	*type = SOAP_TYPE_ns2__addUserCustomInfResponse;
			return soap_in_ns2__addUserCustomInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:addUserCustomInf"))
		{	*type = SOAP_TYPE_ns2__addUserCustomInf;
			return soap_in_ns2__addUserCustomInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMyBulkGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getMyBulkGoodsInfResponse;
			return soap_in_ns2__getMyBulkGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMyBulkGoodsInf"))
		{	*type = SOAP_TYPE_ns2__getMyBulkGoodsInf;
			return soap_in_ns2__getMyBulkGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:delSpecialLineInfResponse"))
		{	*type = SOAP_TYPE_ns2__delSpecialLineInfResponse;
			return soap_in_ns2__delSpecialLineInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:delSpecialLineInf"))
		{	*type = SOAP_TYPE_ns2__delSpecialLineInf;
			return soap_in_ns2__delSpecialLineInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getAllSpecialLineInfResponse"))
		{	*type = SOAP_TYPE_ns2__getAllSpecialLineInfResponse;
			return soap_in_ns2__getAllSpecialLineInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getAllSpecialLineInf"))
		{	*type = SOAP_TYPE_ns2__getAllSpecialLineInf;
			return soap_in_ns2__getAllSpecialLineInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClickSearchSpecialLineInfResponse"))
		{	*type = SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse;
			return soap_in_ns2__getClickSearchSpecialLineInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClickSearchSpecialLineInf"))
		{	*type = SOAP_TYPE_ns2__getClickSearchSpecialLineInf;
			return soap_in_ns2__getClickSearchSpecialLineInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:checkChargeUserResponse"))
		{	*type = SOAP_TYPE_ns2__checkChargeUserResponse;
			return soap_in_ns2__checkChargeUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:checkChargeUser"))
		{	*type = SOAP_TYPE_ns2__checkChargeUser;
			return soap_in_ns2__checkChargeUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteUserCustomInfResponse"))
		{	*type = SOAP_TYPE_ns2__deleteUserCustomInfResponse;
			return soap_in_ns2__deleteUserCustomInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteUserCustomInf"))
		{	*type = SOAP_TYPE_ns2__deleteUserCustomInf;
			return soap_in_ns2__deleteUserCustomInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setServiceStationInfResponse"))
		{	*type = SOAP_TYPE_ns2__setServiceStationInfResponse;
			return soap_in_ns2__setServiceStationInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setServiceStationInf"))
		{	*type = SOAP_TYPE_ns2__setServiceStationInf;
			return soap_in_ns2__setServiceStationInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClickSearchBulkGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse;
			return soap_in_ns2__getClickSearchBulkGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClickSearchBulkGoodsInf"))
		{	*type = SOAP_TYPE_ns2__getClickSearchBulkGoodsInf;
			return soap_in_ns2__getClickSearchBulkGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getCustomGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getCustomGoodsInfResponse;
			return soap_in_ns2__getCustomGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getCustomGoodsInf"))
		{	*type = SOAP_TYPE_ns2__getCustomGoodsInf;
			return soap_in_ns2__getCustomGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getAgentScrollAdResponse"))
		{	*type = SOAP_TYPE_ns2__getAgentScrollAdResponse;
			return soap_in_ns2__getAgentScrollAdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getAgentScrollAd"))
		{	*type = SOAP_TYPE_ns2__getAgentScrollAd;
			return soap_in_ns2__getAgentScrollAd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSystemScrollAdResponse"))
		{	*type = SOAP_TYPE_ns2__getSystemScrollAdResponse;
			return soap_in_ns2__getSystemScrollAdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSystemScrollAd"))
		{	*type = SOAP_TYPE_ns2__getSystemScrollAd;
			return soap_in_ns2__getSystemScrollAd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMyGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getMyGoodsInfResponse;
			return soap_in_ns2__getMyGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMyGoodsInf"))
		{	*type = SOAP_TYPE_ns2__getMyGoodsInf;
			return soap_in_ns2__getMyGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchGoodsInfNewResponse"))
		{	*type = SOAP_TYPE_ns2__getSearchGoodsInfNewResponse;
			return soap_in_ns2__getSearchGoodsInfNewResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchGoodsInfNew"))
		{	*type = SOAP_TYPE_ns2__getSearchGoodsInfNew;
			return soap_in_ns2__getSearchGoodsInfNew(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getSearchGoodsInfResponse;
			return soap_in_ns2__getSearchGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchGoodsInf"))
		{	*type = SOAP_TYPE_ns2__getSearchGoodsInf;
			return soap_in_ns2__getSearchGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:delGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__delGoodsInfResponse;
			return soap_in_ns2__delGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:delGoodsInf"))
		{	*type = SOAP_TYPE_ns2__delGoodsInf;
			return soap_in_ns2__delGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getCustomCarsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getCustomCarsInfResponse;
			return soap_in_ns2__getCustomCarsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getCustomCarsInf"))
		{	*type = SOAP_TYPE_ns2__getCustomCarsInf;
			return soap_in_ns2__getCustomCarsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setGoodsStatusResponse"))
		{	*type = SOAP_TYPE_ns2__setGoodsStatusResponse;
			return soap_in_ns2__setGoodsStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setGoodsStatus"))
		{	*type = SOAP_TYPE_ns2__setGoodsStatus;
			return soap_in_ns2__setGoodsStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClickServiceStationInfResponse"))
		{	*type = SOAP_TYPE_ns2__getClickServiceStationInfResponse;
			return soap_in_ns2__getClickServiceStationInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClickServiceStationInf"))
		{	*type = SOAP_TYPE_ns2__getClickServiceStationInf;
			return soap_in_ns2__getClickServiceStationInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchSpecialLineInfResponse"))
		{	*type = SOAP_TYPE_ns2__getSearchSpecialLineInfResponse;
			return soap_in_ns2__getSearchSpecialLineInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSearchSpecialLineInf"))
		{	*type = SOAP_TYPE_ns2__getSearchSpecialLineInf;
			return soap_in_ns2__getSearchSpecialLineInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setCarsStatusResponse"))
		{	*type = SOAP_TYPE_ns2__setCarsStatusResponse;
			return soap_in_ns2__setCarsStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setCarsStatus"))
		{	*type = SOAP_TYPE_ns2__setCarsStatus;
			return soap_in_ns2__setCarsStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:sendPhoneMessageResponse"))
		{	*type = SOAP_TYPE_ns2__sendPhoneMessageResponse;
			return soap_in_ns2__sendPhoneMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:sendPhoneMessage"))
		{	*type = SOAP_TYPE_ns2__sendPhoneMessage;
			return soap_in_ns2__sendPhoneMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMyCarsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getMyCarsInfResponse;
			return soap_in_ns2__getMyCarsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMyCarsInf"))
		{	*type = SOAP_TYPE_ns2__getMyCarsInf;
			return soap_in_ns2__getMyCarsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getFavoriteSpecialLineInfResponse"))
		{	*type = SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse;
			return soap_in_ns2__getFavoriteSpecialLineInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getFavoriteSpecialLineInf"))
		{	*type = SOAP_TYPE_ns2__getFavoriteSpecialLineInf;
			return soap_in_ns2__getFavoriteSpecialLineInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getUserCustomInfResponse"))
		{	*type = SOAP_TYPE_ns2__getUserCustomInfResponse;
			return soap_in_ns2__getUserCustomInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getUserCustomInf"))
		{	*type = SOAP_TYPE_ns2__getUserCustomInf;
			return soap_in_ns2__getUserCustomInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:collectSpecialLineResponse"))
		{	*type = SOAP_TYPE_ns2__collectSpecialLineResponse;
			return soap_in_ns2__collectSpecialLineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:collectSpecialLine"))
		{	*type = SOAP_TYPE_ns2__collectSpecialLine;
			return soap_in_ns2__collectSpecialLine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getNewBulkGoodsInfResponse"))
		{	*type = SOAP_TYPE_ns2__getNewBulkGoodsInfResponse;
			return soap_in_ns2__getNewBulkGoodsInfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getNewBulkGoodsInf"))
		{	*type = SOAP_TYPE_ns2__getNewBulkGoodsInf;
			return soap_in_ns2__getNewBulkGoodsInf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns2__getSearchCarsInfResponse:
		return ((ns2__getSearchCarsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getSearchCarsInfResponse");
	case SOAP_TYPE_ns2__getSearchCarsInf:
		return ((ns2__getSearchCarsInf *)ptr)->soap_out(soap, tag, id, "ns2:getSearchCarsInf");
	case SOAP_TYPE_ns2__getAgentPopAdResponse:
		return ((ns2__getAgentPopAdResponse *)ptr)->soap_out(soap, tag, id, "ns2:getAgentPopAdResponse");
	case SOAP_TYPE_ns2__getAgentPopAd:
		return ((ns2__getAgentPopAd *)ptr)->soap_out(soap, tag, id, "ns2:getAgentPopAd");
	case SOAP_TYPE_ns2__getSearchCarsInfNewResponse:
		return ((ns2__getSearchCarsInfNewResponse *)ptr)->soap_out(soap, tag, id, "ns2:getSearchCarsInfNewResponse");
	case SOAP_TYPE_ns2__getSearchCarsInfNew:
		return ((ns2__getSearchCarsInfNew *)ptr)->soap_out(soap, tag, id, "ns2:getSearchCarsInfNew");
	case SOAP_TYPE_ns2__delFavoriteSpecialLineResponse:
		return ((ns2__delFavoriteSpecialLineResponse *)ptr)->soap_out(soap, tag, id, "ns2:delFavoriteSpecialLineResponse");
	case SOAP_TYPE_ns2__delFavoriteSpecialLine:
		return ((ns2__delFavoriteSpecialLine *)ptr)->soap_out(soap, tag, id, "ns2:delFavoriteSpecialLine");
	case SOAP_TYPE_ns2__getNewGoodsInfResponse:
		return ((ns2__getNewGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getNewGoodsInfResponse");
	case SOAP_TYPE_ns2__getNewGoodsInf:
		return ((ns2__getNewGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:getNewGoodsInf");
	case SOAP_TYPE_ns2__getMySpecialLineInfResponse:
		return ((ns2__getMySpecialLineInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getMySpecialLineInfResponse");
	case SOAP_TYPE_ns2__getMySpecialLineInf:
		return ((ns2__getMySpecialLineInf *)ptr)->soap_out(soap, tag, id, "ns2:getMySpecialLineInf");
	case SOAP_TYPE_ns2__setPubSpecialLineInfResponse:
		return ((ns2__setPubSpecialLineInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:setPubSpecialLineInfResponse");
	case SOAP_TYPE_ns2__setPubSpecialLineInf:
		return ((ns2__setPubSpecialLineInf *)ptr)->soap_out(soap, tag, id, "ns2:setPubSpecialLineInf");
	case SOAP_TYPE_ns2__delCarsInfResponse:
		return ((ns2__delCarsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:delCarsInfResponse");
	case SOAP_TYPE_ns2__delCarsInf:
		return ((ns2__delCarsInf *)ptr)->soap_out(soap, tag, id, "ns2:delCarsInf");
	case SOAP_TYPE_ns2__getPersisCarsInfoResponse:
		return ((ns2__getPersisCarsInfoResponse *)ptr)->soap_out(soap, tag, id, "ns2:getPersisCarsInfoResponse");
	case SOAP_TYPE_ns2__getPersisCarsInfo:
		return ((ns2__getPersisCarsInfo *)ptr)->soap_out(soap, tag, id, "ns2:getPersisCarsInfo");
	case SOAP_TYPE_ns2__browseZoneCarsResponse:
		return ((ns2__browseZoneCarsResponse *)ptr)->soap_out(soap, tag, id, "ns2:browseZoneCarsResponse");
	case SOAP_TYPE_ns2__browseZoneCars:
		return ((ns2__browseZoneCars *)ptr)->soap_out(soap, tag, id, "ns2:browseZoneCars");
	case SOAP_TYPE_ns2__placeOrderResponse:
		return ((ns2__placeOrderResponse *)ptr)->soap_out(soap, tag, id, "ns2:placeOrderResponse");
	case SOAP_TYPE_ns2__placeOrder:
		return ((ns2__placeOrder *)ptr)->soap_out(soap, tag, id, "ns2:placeOrder");
	case SOAP_TYPE_ns2__getPersisGoodsInfoResponse:
		return ((ns2__getPersisGoodsInfoResponse *)ptr)->soap_out(soap, tag, id, "ns2:getPersisGoodsInfoResponse");
	case SOAP_TYPE_ns2__getPersisGoodsInfo:
		return ((ns2__getPersisGoodsInfo *)ptr)->soap_out(soap, tag, id, "ns2:getPersisGoodsInfo");
	case SOAP_TYPE_ns2__usrLoginResponse:
		return ((ns2__usrLoginResponse *)ptr)->soap_out(soap, tag, id, "ns2:usrLoginResponse");
	case SOAP_TYPE_ns2__usrLogin:
		return ((ns2__usrLogin *)ptr)->soap_out(soap, tag, id, "ns2:usrLogin");
	case SOAP_TYPE_ns2__delBulkGoodsInfResponse:
		return ((ns2__delBulkGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:delBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__delBulkGoodsInf:
		return ((ns2__delBulkGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:delBulkGoodsInf");
	case SOAP_TYPE_ns2__getClickSearchCarsInfResponse:
		return ((ns2__getClickSearchCarsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getClickSearchCarsInfResponse");
	case SOAP_TYPE_ns2__getClickSearchCarsInf:
		return ((ns2__getClickSearchCarsInf *)ptr)->soap_out(soap, tag, id, "ns2:getClickSearchCarsInf");
	case SOAP_TYPE_ns2__setPubCarsInfResponse:
		return ((ns2__setPubCarsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:setPubCarsInfResponse");
	case SOAP_TYPE_ns2__setPubCarsInf:
		return ((ns2__setPubCarsInf *)ptr)->soap_out(soap, tag, id, "ns2:setPubCarsInf");
	case SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse:
		return ((ns2__getSearchBulkGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getSearchBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__getSearchBulkGoodsInf:
		return ((ns2__getSearchBulkGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:getSearchBulkGoodsInf");
	case SOAP_TYPE_ns2__setPubBulkGoodsInfResponse:
		return ((ns2__setPubBulkGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:setPubBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__setPubBulkGoodsInf:
		return ((ns2__setPubBulkGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:setPubBulkGoodsInf");
	case SOAP_TYPE_ns2__getNewCarsInfResponse:
		return ((ns2__getNewCarsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getNewCarsInfResponse");
	case SOAP_TYPE_ns2__getNewCarsInf:
		return ((ns2__getNewCarsInf *)ptr)->soap_out(soap, tag, id, "ns2:getNewCarsInf");
	case SOAP_TYPE_ns2__getClickSearchGoodsInfResponse:
		return ((ns2__getClickSearchGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getClickSearchGoodsInfResponse");
	case SOAP_TYPE_ns2__getClickSearchGoodsInf:
		return ((ns2__getClickSearchGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:getClickSearchGoodsInf");
	case SOAP_TYPE_ns2__setPubGoodsInfResponse:
		return ((ns2__setPubGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:setPubGoodsInfResponse");
	case SOAP_TYPE_ns2__setPubGoodsInf:
		return ((ns2__setPubGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:setPubGoodsInf");
	case SOAP_TYPE_ns2__addUserCustomInfResponse:
		return ((ns2__addUserCustomInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:addUserCustomInfResponse");
	case SOAP_TYPE_ns2__addUserCustomInf:
		return ((ns2__addUserCustomInf *)ptr)->soap_out(soap, tag, id, "ns2:addUserCustomInf");
	case SOAP_TYPE_ns2__getMyBulkGoodsInfResponse:
		return ((ns2__getMyBulkGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getMyBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__getMyBulkGoodsInf:
		return ((ns2__getMyBulkGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:getMyBulkGoodsInf");
	case SOAP_TYPE_ns2__delSpecialLineInfResponse:
		return ((ns2__delSpecialLineInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:delSpecialLineInfResponse");
	case SOAP_TYPE_ns2__delSpecialLineInf:
		return ((ns2__delSpecialLineInf *)ptr)->soap_out(soap, tag, id, "ns2:delSpecialLineInf");
	case SOAP_TYPE_ns2__getAllSpecialLineInfResponse:
		return ((ns2__getAllSpecialLineInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getAllSpecialLineInfResponse");
	case SOAP_TYPE_ns2__getAllSpecialLineInf:
		return ((ns2__getAllSpecialLineInf *)ptr)->soap_out(soap, tag, id, "ns2:getAllSpecialLineInf");
	case SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse:
		return ((ns2__getClickSearchSpecialLineInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getClickSearchSpecialLineInfResponse");
	case SOAP_TYPE_ns2__getClickSearchSpecialLineInf:
		return ((ns2__getClickSearchSpecialLineInf *)ptr)->soap_out(soap, tag, id, "ns2:getClickSearchSpecialLineInf");
	case SOAP_TYPE_ns2__checkChargeUserResponse:
		return ((ns2__checkChargeUserResponse *)ptr)->soap_out(soap, tag, id, "ns2:checkChargeUserResponse");
	case SOAP_TYPE_ns2__checkChargeUser:
		return ((ns2__checkChargeUser *)ptr)->soap_out(soap, tag, id, "ns2:checkChargeUser");
	case SOAP_TYPE_ns2__deleteUserCustomInfResponse:
		return ((ns2__deleteUserCustomInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:deleteUserCustomInfResponse");
	case SOAP_TYPE_ns2__deleteUserCustomInf:
		return ((ns2__deleteUserCustomInf *)ptr)->soap_out(soap, tag, id, "ns2:deleteUserCustomInf");
	case SOAP_TYPE_ns2__setServiceStationInfResponse:
		return ((ns2__setServiceStationInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:setServiceStationInfResponse");
	case SOAP_TYPE_ns2__setServiceStationInf:
		return ((ns2__setServiceStationInf *)ptr)->soap_out(soap, tag, id, "ns2:setServiceStationInf");
	case SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse:
		return ((ns2__getClickSearchBulkGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getClickSearchBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__getClickSearchBulkGoodsInf:
		return ((ns2__getClickSearchBulkGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:getClickSearchBulkGoodsInf");
	case SOAP_TYPE_ns2__getCustomGoodsInfResponse:
		return ((ns2__getCustomGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getCustomGoodsInfResponse");
	case SOAP_TYPE_ns2__getCustomGoodsInf:
		return ((ns2__getCustomGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:getCustomGoodsInf");
	case SOAP_TYPE_ns2__getAgentScrollAdResponse:
		return ((ns2__getAgentScrollAdResponse *)ptr)->soap_out(soap, tag, id, "ns2:getAgentScrollAdResponse");
	case SOAP_TYPE_ns2__getAgentScrollAd:
		return ((ns2__getAgentScrollAd *)ptr)->soap_out(soap, tag, id, "ns2:getAgentScrollAd");
	case SOAP_TYPE_ns2__getSystemScrollAdResponse:
		return ((ns2__getSystemScrollAdResponse *)ptr)->soap_out(soap, tag, id, "ns2:getSystemScrollAdResponse");
	case SOAP_TYPE_ns2__getSystemScrollAd:
		return ((ns2__getSystemScrollAd *)ptr)->soap_out(soap, tag, id, "ns2:getSystemScrollAd");
	case SOAP_TYPE_ns2__getMyGoodsInfResponse:
		return ((ns2__getMyGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getMyGoodsInfResponse");
	case SOAP_TYPE_ns2__getMyGoodsInf:
		return ((ns2__getMyGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:getMyGoodsInf");
	case SOAP_TYPE_ns2__getSearchGoodsInfNewResponse:
		return ((ns2__getSearchGoodsInfNewResponse *)ptr)->soap_out(soap, tag, id, "ns2:getSearchGoodsInfNewResponse");
	case SOAP_TYPE_ns2__getSearchGoodsInfNew:
		return ((ns2__getSearchGoodsInfNew *)ptr)->soap_out(soap, tag, id, "ns2:getSearchGoodsInfNew");
	case SOAP_TYPE_ns2__getSearchGoodsInfResponse:
		return ((ns2__getSearchGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getSearchGoodsInfResponse");
	case SOAP_TYPE_ns2__getSearchGoodsInf:
		return ((ns2__getSearchGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:getSearchGoodsInf");
	case SOAP_TYPE_ns2__delGoodsInfResponse:
		return ((ns2__delGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:delGoodsInfResponse");
	case SOAP_TYPE_ns2__delGoodsInf:
		return ((ns2__delGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:delGoodsInf");
	case SOAP_TYPE_ns2__getCustomCarsInfResponse:
		return ((ns2__getCustomCarsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getCustomCarsInfResponse");
	case SOAP_TYPE_ns2__getCustomCarsInf:
		return ((ns2__getCustomCarsInf *)ptr)->soap_out(soap, tag, id, "ns2:getCustomCarsInf");
	case SOAP_TYPE_ns2__setGoodsStatusResponse:
		return ((ns2__setGoodsStatusResponse *)ptr)->soap_out(soap, tag, id, "ns2:setGoodsStatusResponse");
	case SOAP_TYPE_ns2__setGoodsStatus:
		return ((ns2__setGoodsStatus *)ptr)->soap_out(soap, tag, id, "ns2:setGoodsStatus");
	case SOAP_TYPE_ns2__getClickServiceStationInfResponse:
		return ((ns2__getClickServiceStationInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getClickServiceStationInfResponse");
	case SOAP_TYPE_ns2__getClickServiceStationInf:
		return ((ns2__getClickServiceStationInf *)ptr)->soap_out(soap, tag, id, "ns2:getClickServiceStationInf");
	case SOAP_TYPE_ns2__getSearchSpecialLineInfResponse:
		return ((ns2__getSearchSpecialLineInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getSearchSpecialLineInfResponse");
	case SOAP_TYPE_ns2__getSearchSpecialLineInf:
		return ((ns2__getSearchSpecialLineInf *)ptr)->soap_out(soap, tag, id, "ns2:getSearchSpecialLineInf");
	case SOAP_TYPE_ns2__setCarsStatusResponse:
		return ((ns2__setCarsStatusResponse *)ptr)->soap_out(soap, tag, id, "ns2:setCarsStatusResponse");
	case SOAP_TYPE_ns2__setCarsStatus:
		return ((ns2__setCarsStatus *)ptr)->soap_out(soap, tag, id, "ns2:setCarsStatus");
	case SOAP_TYPE_ns2__sendPhoneMessageResponse:
		return ((ns2__sendPhoneMessageResponse *)ptr)->soap_out(soap, tag, id, "ns2:sendPhoneMessageResponse");
	case SOAP_TYPE_ns2__sendPhoneMessage:
		return ((ns2__sendPhoneMessage *)ptr)->soap_out(soap, tag, id, "ns2:sendPhoneMessage");
	case SOAP_TYPE_ns2__getMyCarsInfResponse:
		return ((ns2__getMyCarsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getMyCarsInfResponse");
	case SOAP_TYPE_ns2__getMyCarsInf:
		return ((ns2__getMyCarsInf *)ptr)->soap_out(soap, tag, id, "ns2:getMyCarsInf");
	case SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse:
		return ((ns2__getFavoriteSpecialLineInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getFavoriteSpecialLineInfResponse");
	case SOAP_TYPE_ns2__getFavoriteSpecialLineInf:
		return ((ns2__getFavoriteSpecialLineInf *)ptr)->soap_out(soap, tag, id, "ns2:getFavoriteSpecialLineInf");
	case SOAP_TYPE_ns2__getUserCustomInfResponse:
		return ((ns2__getUserCustomInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getUserCustomInfResponse");
	case SOAP_TYPE_ns2__getUserCustomInf:
		return ((ns2__getUserCustomInf *)ptr)->soap_out(soap, tag, id, "ns2:getUserCustomInf");
	case SOAP_TYPE_ns2__collectSpecialLineResponse:
		return ((ns2__collectSpecialLineResponse *)ptr)->soap_out(soap, tag, id, "ns2:collectSpecialLineResponse");
	case SOAP_TYPE_ns2__collectSpecialLine:
		return ((ns2__collectSpecialLine *)ptr)->soap_out(soap, tag, id, "ns2:collectSpecialLine");
	case SOAP_TYPE_ns2__getNewBulkGoodsInfResponse:
		return ((ns2__getNewBulkGoodsInfResponse *)ptr)->soap_out(soap, tag, id, "ns2:getNewBulkGoodsInfResponse");
	case SOAP_TYPE_ns2__getNewBulkGoodsInf:
		return ((ns2__getNewBulkGoodsInf *)ptr)->soap_out(soap, tag, id, "ns2:getNewBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__getSearchCarsInfResponse:
		return soap_out_PointerTons2__getSearchCarsInfResponse(soap, tag, id, (ns2__getSearchCarsInfResponse *const*)ptr, "ns2:getSearchCarsInfResponse");
	case SOAP_TYPE_PointerTons2__getSearchCarsInf:
		return soap_out_PointerTons2__getSearchCarsInf(soap, tag, id, (ns2__getSearchCarsInf *const*)ptr, "ns2:getSearchCarsInf");
	case SOAP_TYPE_PointerTons2__getAgentPopAdResponse:
		return soap_out_PointerTons2__getAgentPopAdResponse(soap, tag, id, (ns2__getAgentPopAdResponse *const*)ptr, "ns2:getAgentPopAdResponse");
	case SOAP_TYPE_PointerTons2__getAgentPopAd:
		return soap_out_PointerTons2__getAgentPopAd(soap, tag, id, (ns2__getAgentPopAd *const*)ptr, "ns2:getAgentPopAd");
	case SOAP_TYPE_PointerTons2__getSearchCarsInfNewResponse:
		return soap_out_PointerTons2__getSearchCarsInfNewResponse(soap, tag, id, (ns2__getSearchCarsInfNewResponse *const*)ptr, "ns2:getSearchCarsInfNewResponse");
	case SOAP_TYPE_PointerTons2__getSearchCarsInfNew:
		return soap_out_PointerTons2__getSearchCarsInfNew(soap, tag, id, (ns2__getSearchCarsInfNew *const*)ptr, "ns2:getSearchCarsInfNew");
	case SOAP_TYPE_PointerTons2__delFavoriteSpecialLineResponse:
		return soap_out_PointerTons2__delFavoriteSpecialLineResponse(soap, tag, id, (ns2__delFavoriteSpecialLineResponse *const*)ptr, "ns2:delFavoriteSpecialLineResponse");
	case SOAP_TYPE_PointerTons2__delFavoriteSpecialLine:
		return soap_out_PointerTons2__delFavoriteSpecialLine(soap, tag, id, (ns2__delFavoriteSpecialLine *const*)ptr, "ns2:delFavoriteSpecialLine");
	case SOAP_TYPE_PointerTons2__getNewGoodsInfResponse:
		return soap_out_PointerTons2__getNewGoodsInfResponse(soap, tag, id, (ns2__getNewGoodsInfResponse *const*)ptr, "ns2:getNewGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getNewGoodsInf:
		return soap_out_PointerTons2__getNewGoodsInf(soap, tag, id, (ns2__getNewGoodsInf *const*)ptr, "ns2:getNewGoodsInf");
	case SOAP_TYPE_PointerTons2__setPubSpecialLineInfResponse:
		return soap_out_PointerTons2__setPubSpecialLineInfResponse(soap, tag, id, (ns2__setPubSpecialLineInfResponse *const*)ptr, "ns2:setPubSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__setPubSpecialLineInf:
		return soap_out_PointerTons2__setPubSpecialLineInf(soap, tag, id, (ns2__setPubSpecialLineInf *const*)ptr, "ns2:setPubSpecialLineInf");
	case SOAP_TYPE_PointerTons2__getMySpecialLineInfResponse:
		return soap_out_PointerTons2__getMySpecialLineInfResponse(soap, tag, id, (ns2__getMySpecialLineInfResponse *const*)ptr, "ns2:getMySpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__getMySpecialLineInf:
		return soap_out_PointerTons2__getMySpecialLineInf(soap, tag, id, (ns2__getMySpecialLineInf *const*)ptr, "ns2:getMySpecialLineInf");
	case SOAP_TYPE_PointerTons2__delCarsInfResponse:
		return soap_out_PointerTons2__delCarsInfResponse(soap, tag, id, (ns2__delCarsInfResponse *const*)ptr, "ns2:delCarsInfResponse");
	case SOAP_TYPE_PointerTons2__delCarsInf:
		return soap_out_PointerTons2__delCarsInf(soap, tag, id, (ns2__delCarsInf *const*)ptr, "ns2:delCarsInf");
	case SOAP_TYPE_PointerTons2__getPersisCarsInfoResponse:
		return soap_out_PointerTons2__getPersisCarsInfoResponse(soap, tag, id, (ns2__getPersisCarsInfoResponse *const*)ptr, "ns2:getPersisCarsInfoResponse");
	case SOAP_TYPE_PointerTons2__getPersisCarsInfo:
		return soap_out_PointerTons2__getPersisCarsInfo(soap, tag, id, (ns2__getPersisCarsInfo *const*)ptr, "ns2:getPersisCarsInfo");
	case SOAP_TYPE_PointerTons2__placeOrderResponse:
		return soap_out_PointerTons2__placeOrderResponse(soap, tag, id, (ns2__placeOrderResponse *const*)ptr, "ns2:placeOrderResponse");
	case SOAP_TYPE_PointerTons2__placeOrder:
		return soap_out_PointerTons2__placeOrder(soap, tag, id, (ns2__placeOrder *const*)ptr, "ns2:placeOrder");
	case SOAP_TYPE_PointerTons2__browseZoneCarsResponse:
		return soap_out_PointerTons2__browseZoneCarsResponse(soap, tag, id, (ns2__browseZoneCarsResponse *const*)ptr, "ns2:browseZoneCarsResponse");
	case SOAP_TYPE_PointerTons2__browseZoneCars:
		return soap_out_PointerTons2__browseZoneCars(soap, tag, id, (ns2__browseZoneCars *const*)ptr, "ns2:browseZoneCars");
	case SOAP_TYPE_PointerTons2__getPersisGoodsInfoResponse:
		return soap_out_PointerTons2__getPersisGoodsInfoResponse(soap, tag, id, (ns2__getPersisGoodsInfoResponse *const*)ptr, "ns2:getPersisGoodsInfoResponse");
	case SOAP_TYPE_PointerTons2__getPersisGoodsInfo:
		return soap_out_PointerTons2__getPersisGoodsInfo(soap, tag, id, (ns2__getPersisGoodsInfo *const*)ptr, "ns2:getPersisGoodsInfo");
	case SOAP_TYPE_PointerTons2__usrLoginResponse:
		return soap_out_PointerTons2__usrLoginResponse(soap, tag, id, (ns2__usrLoginResponse *const*)ptr, "ns2:usrLoginResponse");
	case SOAP_TYPE_PointerTons2__usrLogin:
		return soap_out_PointerTons2__usrLogin(soap, tag, id, (ns2__usrLogin *const*)ptr, "ns2:usrLogin");
	case SOAP_TYPE_PointerTons2__delBulkGoodsInfResponse:
		return soap_out_PointerTons2__delBulkGoodsInfResponse(soap, tag, id, (ns2__delBulkGoodsInfResponse *const*)ptr, "ns2:delBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__delBulkGoodsInf:
		return soap_out_PointerTons2__delBulkGoodsInf(soap, tag, id, (ns2__delBulkGoodsInf *const*)ptr, "ns2:delBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__getClickSearchCarsInfResponse:
		return soap_out_PointerTons2__getClickSearchCarsInfResponse(soap, tag, id, (ns2__getClickSearchCarsInfResponse *const*)ptr, "ns2:getClickSearchCarsInfResponse");
	case SOAP_TYPE_PointerTons2__getClickSearchCarsInf:
		return soap_out_PointerTons2__getClickSearchCarsInf(soap, tag, id, (ns2__getClickSearchCarsInf *const*)ptr, "ns2:getClickSearchCarsInf");
	case SOAP_TYPE_PointerTons2__setPubCarsInfResponse:
		return soap_out_PointerTons2__setPubCarsInfResponse(soap, tag, id, (ns2__setPubCarsInfResponse *const*)ptr, "ns2:setPubCarsInfResponse");
	case SOAP_TYPE_PointerTons2__setPubCarsInf:
		return soap_out_PointerTons2__setPubCarsInf(soap, tag, id, (ns2__setPubCarsInf *const*)ptr, "ns2:setPubCarsInf");
	case SOAP_TYPE_PointerTons2__setPubBulkGoodsInfResponse:
		return soap_out_PointerTons2__setPubBulkGoodsInfResponse(soap, tag, id, (ns2__setPubBulkGoodsInfResponse *const*)ptr, "ns2:setPubBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__setPubBulkGoodsInf:
		return soap_out_PointerTons2__setPubBulkGoodsInf(soap, tag, id, (ns2__setPubBulkGoodsInf *const*)ptr, "ns2:setPubBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__getSearchBulkGoodsInfResponse:
		return soap_out_PointerTons2__getSearchBulkGoodsInfResponse(soap, tag, id, (ns2__getSearchBulkGoodsInfResponse *const*)ptr, "ns2:getSearchBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getSearchBulkGoodsInf:
		return soap_out_PointerTons2__getSearchBulkGoodsInf(soap, tag, id, (ns2__getSearchBulkGoodsInf *const*)ptr, "ns2:getSearchBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__getNewCarsInfResponse:
		return soap_out_PointerTons2__getNewCarsInfResponse(soap, tag, id, (ns2__getNewCarsInfResponse *const*)ptr, "ns2:getNewCarsInfResponse");
	case SOAP_TYPE_PointerTons2__getNewCarsInf:
		return soap_out_PointerTons2__getNewCarsInf(soap, tag, id, (ns2__getNewCarsInf *const*)ptr, "ns2:getNewCarsInf");
	case SOAP_TYPE_PointerTons2__setPubGoodsInfResponse:
		return soap_out_PointerTons2__setPubGoodsInfResponse(soap, tag, id, (ns2__setPubGoodsInfResponse *const*)ptr, "ns2:setPubGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__setPubGoodsInf:
		return soap_out_PointerTons2__setPubGoodsInf(soap, tag, id, (ns2__setPubGoodsInf *const*)ptr, "ns2:setPubGoodsInf");
	case SOAP_TYPE_PointerTons2__getClickSearchGoodsInfResponse:
		return soap_out_PointerTons2__getClickSearchGoodsInfResponse(soap, tag, id, (ns2__getClickSearchGoodsInfResponse *const*)ptr, "ns2:getClickSearchGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getClickSearchGoodsInf:
		return soap_out_PointerTons2__getClickSearchGoodsInf(soap, tag, id, (ns2__getClickSearchGoodsInf *const*)ptr, "ns2:getClickSearchGoodsInf");
	case SOAP_TYPE_PointerTons2__addUserCustomInfResponse:
		return soap_out_PointerTons2__addUserCustomInfResponse(soap, tag, id, (ns2__addUserCustomInfResponse *const*)ptr, "ns2:addUserCustomInfResponse");
	case SOAP_TYPE_PointerTons2__addUserCustomInf:
		return soap_out_PointerTons2__addUserCustomInf(soap, tag, id, (ns2__addUserCustomInf *const*)ptr, "ns2:addUserCustomInf");
	case SOAP_TYPE_PointerTons2__getMyBulkGoodsInfResponse:
		return soap_out_PointerTons2__getMyBulkGoodsInfResponse(soap, tag, id, (ns2__getMyBulkGoodsInfResponse *const*)ptr, "ns2:getMyBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getMyBulkGoodsInf:
		return soap_out_PointerTons2__getMyBulkGoodsInf(soap, tag, id, (ns2__getMyBulkGoodsInf *const*)ptr, "ns2:getMyBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__delSpecialLineInfResponse:
		return soap_out_PointerTons2__delSpecialLineInfResponse(soap, tag, id, (ns2__delSpecialLineInfResponse *const*)ptr, "ns2:delSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__delSpecialLineInf:
		return soap_out_PointerTons2__delSpecialLineInf(soap, tag, id, (ns2__delSpecialLineInf *const*)ptr, "ns2:delSpecialLineInf");
	case SOAP_TYPE_PointerTons2__getClickSearchSpecialLineInfResponse:
		return soap_out_PointerTons2__getClickSearchSpecialLineInfResponse(soap, tag, id, (ns2__getClickSearchSpecialLineInfResponse *const*)ptr, "ns2:getClickSearchSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__getClickSearchSpecialLineInf:
		return soap_out_PointerTons2__getClickSearchSpecialLineInf(soap, tag, id, (ns2__getClickSearchSpecialLineInf *const*)ptr, "ns2:getClickSearchSpecialLineInf");
	case SOAP_TYPE_PointerTons2__getAllSpecialLineInfResponse:
		return soap_out_PointerTons2__getAllSpecialLineInfResponse(soap, tag, id, (ns2__getAllSpecialLineInfResponse *const*)ptr, "ns2:getAllSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__getAllSpecialLineInf:
		return soap_out_PointerTons2__getAllSpecialLineInf(soap, tag, id, (ns2__getAllSpecialLineInf *const*)ptr, "ns2:getAllSpecialLineInf");
	case SOAP_TYPE_PointerTons2__setServiceStationInfResponse:
		return soap_out_PointerTons2__setServiceStationInfResponse(soap, tag, id, (ns2__setServiceStationInfResponse *const*)ptr, "ns2:setServiceStationInfResponse");
	case SOAP_TYPE_PointerTons2__setServiceStationInf:
		return soap_out_PointerTons2__setServiceStationInf(soap, tag, id, (ns2__setServiceStationInf *const*)ptr, "ns2:setServiceStationInf");
	case SOAP_TYPE_PointerTons2__deleteUserCustomInfResponse:
		return soap_out_PointerTons2__deleteUserCustomInfResponse(soap, tag, id, (ns2__deleteUserCustomInfResponse *const*)ptr, "ns2:deleteUserCustomInfResponse");
	case SOAP_TYPE_PointerTons2__deleteUserCustomInf:
		return soap_out_PointerTons2__deleteUserCustomInf(soap, tag, id, (ns2__deleteUserCustomInf *const*)ptr, "ns2:deleteUserCustomInf");
	case SOAP_TYPE_PointerTons2__checkChargeUserResponse:
		return soap_out_PointerTons2__checkChargeUserResponse(soap, tag, id, (ns2__checkChargeUserResponse *const*)ptr, "ns2:checkChargeUserResponse");
	case SOAP_TYPE_PointerTons2__checkChargeUser:
		return soap_out_PointerTons2__checkChargeUser(soap, tag, id, (ns2__checkChargeUser *const*)ptr, "ns2:checkChargeUser");
	case SOAP_TYPE_PointerTons2__getClickSearchBulkGoodsInfResponse:
		return soap_out_PointerTons2__getClickSearchBulkGoodsInfResponse(soap, tag, id, (ns2__getClickSearchBulkGoodsInfResponse *const*)ptr, "ns2:getClickSearchBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getClickSearchBulkGoodsInf:
		return soap_out_PointerTons2__getClickSearchBulkGoodsInf(soap, tag, id, (ns2__getClickSearchBulkGoodsInf *const*)ptr, "ns2:getClickSearchBulkGoodsInf");
	case SOAP_TYPE_PointerTons2__getCustomGoodsInfResponse:
		return soap_out_PointerTons2__getCustomGoodsInfResponse(soap, tag, id, (ns2__getCustomGoodsInfResponse *const*)ptr, "ns2:getCustomGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getCustomGoodsInf:
		return soap_out_PointerTons2__getCustomGoodsInf(soap, tag, id, (ns2__getCustomGoodsInf *const*)ptr, "ns2:getCustomGoodsInf");
	case SOAP_TYPE_PointerTons2__getAgentScrollAdResponse:
		return soap_out_PointerTons2__getAgentScrollAdResponse(soap, tag, id, (ns2__getAgentScrollAdResponse *const*)ptr, "ns2:getAgentScrollAdResponse");
	case SOAP_TYPE_PointerTons2__getAgentScrollAd:
		return soap_out_PointerTons2__getAgentScrollAd(soap, tag, id, (ns2__getAgentScrollAd *const*)ptr, "ns2:getAgentScrollAd");
	case SOAP_TYPE_PointerTons2__getSystemScrollAdResponse:
		return soap_out_PointerTons2__getSystemScrollAdResponse(soap, tag, id, (ns2__getSystemScrollAdResponse *const*)ptr, "ns2:getSystemScrollAdResponse");
	case SOAP_TYPE_PointerTons2__getSystemScrollAd:
		return soap_out_PointerTons2__getSystemScrollAd(soap, tag, id, (ns2__getSystemScrollAd *const*)ptr, "ns2:getSystemScrollAd");
	case SOAP_TYPE_PointerTons2__getMyGoodsInfResponse:
		return soap_out_PointerTons2__getMyGoodsInfResponse(soap, tag, id, (ns2__getMyGoodsInfResponse *const*)ptr, "ns2:getMyGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getMyGoodsInf:
		return soap_out_PointerTons2__getMyGoodsInf(soap, tag, id, (ns2__getMyGoodsInf *const*)ptr, "ns2:getMyGoodsInf");
	case SOAP_TYPE_PointerTons2__getSearchGoodsInfNewResponse:
		return soap_out_PointerTons2__getSearchGoodsInfNewResponse(soap, tag, id, (ns2__getSearchGoodsInfNewResponse *const*)ptr, "ns2:getSearchGoodsInfNewResponse");
	case SOAP_TYPE_PointerTons2__getSearchGoodsInfNew:
		return soap_out_PointerTons2__getSearchGoodsInfNew(soap, tag, id, (ns2__getSearchGoodsInfNew *const*)ptr, "ns2:getSearchGoodsInfNew");
	case SOAP_TYPE_PointerTons2__getSearchGoodsInfResponse:
		return soap_out_PointerTons2__getSearchGoodsInfResponse(soap, tag, id, (ns2__getSearchGoodsInfResponse *const*)ptr, "ns2:getSearchGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getSearchGoodsInf:
		return soap_out_PointerTons2__getSearchGoodsInf(soap, tag, id, (ns2__getSearchGoodsInf *const*)ptr, "ns2:getSearchGoodsInf");
	case SOAP_TYPE_PointerTons2__delGoodsInfResponse:
		return soap_out_PointerTons2__delGoodsInfResponse(soap, tag, id, (ns2__delGoodsInfResponse *const*)ptr, "ns2:delGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__delGoodsInf:
		return soap_out_PointerTons2__delGoodsInf(soap, tag, id, (ns2__delGoodsInf *const*)ptr, "ns2:delGoodsInf");
	case SOAP_TYPE_PointerTons2__setGoodsStatusResponse:
		return soap_out_PointerTons2__setGoodsStatusResponse(soap, tag, id, (ns2__setGoodsStatusResponse *const*)ptr, "ns2:setGoodsStatusResponse");
	case SOAP_TYPE_PointerTons2__setGoodsStatus:
		return soap_out_PointerTons2__setGoodsStatus(soap, tag, id, (ns2__setGoodsStatus *const*)ptr, "ns2:setGoodsStatus");
	case SOAP_TYPE_PointerTons2__getCustomCarsInfResponse:
		return soap_out_PointerTons2__getCustomCarsInfResponse(soap, tag, id, (ns2__getCustomCarsInfResponse *const*)ptr, "ns2:getCustomCarsInfResponse");
	case SOAP_TYPE_PointerTons2__getCustomCarsInf:
		return soap_out_PointerTons2__getCustomCarsInf(soap, tag, id, (ns2__getCustomCarsInf *const*)ptr, "ns2:getCustomCarsInf");
	case SOAP_TYPE_PointerTons2__getSearchSpecialLineInfResponse:
		return soap_out_PointerTons2__getSearchSpecialLineInfResponse(soap, tag, id, (ns2__getSearchSpecialLineInfResponse *const*)ptr, "ns2:getSearchSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__getSearchSpecialLineInf:
		return soap_out_PointerTons2__getSearchSpecialLineInf(soap, tag, id, (ns2__getSearchSpecialLineInf *const*)ptr, "ns2:getSearchSpecialLineInf");
	case SOAP_TYPE_PointerTons2__getClickServiceStationInfResponse:
		return soap_out_PointerTons2__getClickServiceStationInfResponse(soap, tag, id, (ns2__getClickServiceStationInfResponse *const*)ptr, "ns2:getClickServiceStationInfResponse");
	case SOAP_TYPE_PointerTons2__getClickServiceStationInf:
		return soap_out_PointerTons2__getClickServiceStationInf(soap, tag, id, (ns2__getClickServiceStationInf *const*)ptr, "ns2:getClickServiceStationInf");
	case SOAP_TYPE_PointerTons2__setCarsStatusResponse:
		return soap_out_PointerTons2__setCarsStatusResponse(soap, tag, id, (ns2__setCarsStatusResponse *const*)ptr, "ns2:setCarsStatusResponse");
	case SOAP_TYPE_PointerTons2__setCarsStatus:
		return soap_out_PointerTons2__setCarsStatus(soap, tag, id, (ns2__setCarsStatus *const*)ptr, "ns2:setCarsStatus");
	case SOAP_TYPE_PointerTons2__sendPhoneMessageResponse:
		return soap_out_PointerTons2__sendPhoneMessageResponse(soap, tag, id, (ns2__sendPhoneMessageResponse *const*)ptr, "ns2:sendPhoneMessageResponse");
	case SOAP_TYPE_PointerTons2__sendPhoneMessage:
		return soap_out_PointerTons2__sendPhoneMessage(soap, tag, id, (ns2__sendPhoneMessage *const*)ptr, "ns2:sendPhoneMessage");
	case SOAP_TYPE_PointerTons2__getMyCarsInfResponse:
		return soap_out_PointerTons2__getMyCarsInfResponse(soap, tag, id, (ns2__getMyCarsInfResponse *const*)ptr, "ns2:getMyCarsInfResponse");
	case SOAP_TYPE_PointerTons2__getMyCarsInf:
		return soap_out_PointerTons2__getMyCarsInf(soap, tag, id, (ns2__getMyCarsInf *const*)ptr, "ns2:getMyCarsInf");
	case SOAP_TYPE_PointerTons2__getUserCustomInfResponse:
		return soap_out_PointerTons2__getUserCustomInfResponse(soap, tag, id, (ns2__getUserCustomInfResponse *const*)ptr, "ns2:getUserCustomInfResponse");
	case SOAP_TYPE_PointerTons2__getUserCustomInf:
		return soap_out_PointerTons2__getUserCustomInf(soap, tag, id, (ns2__getUserCustomInf *const*)ptr, "ns2:getUserCustomInf");
	case SOAP_TYPE_PointerTons2__getFavoriteSpecialLineInfResponse:
		return soap_out_PointerTons2__getFavoriteSpecialLineInfResponse(soap, tag, id, (ns2__getFavoriteSpecialLineInfResponse *const*)ptr, "ns2:getFavoriteSpecialLineInfResponse");
	case SOAP_TYPE_PointerTons2__getFavoriteSpecialLineInf:
		return soap_out_PointerTons2__getFavoriteSpecialLineInf(soap, tag, id, (ns2__getFavoriteSpecialLineInf *const*)ptr, "ns2:getFavoriteSpecialLineInf");
	case SOAP_TYPE_PointerTons2__collectSpecialLineResponse:
		return soap_out_PointerTons2__collectSpecialLineResponse(soap, tag, id, (ns2__collectSpecialLineResponse *const*)ptr, "ns2:collectSpecialLineResponse");
	case SOAP_TYPE_PointerTons2__collectSpecialLine:
		return soap_out_PointerTons2__collectSpecialLine(soap, tag, id, (ns2__collectSpecialLine *const*)ptr, "ns2:collectSpecialLine");
	case SOAP_TYPE_PointerTons2__getNewBulkGoodsInfResponse:
		return soap_out_PointerTons2__getNewBulkGoodsInfResponse(soap, tag, id, (ns2__getNewBulkGoodsInfResponse *const*)ptr, "ns2:getNewBulkGoodsInfResponse");
	case SOAP_TYPE_PointerTons2__getNewBulkGoodsInf:
		return soap_out_PointerTons2__getNewBulkGoodsInf(soap, tag, id, (ns2__getNewBulkGoodsInf *const*)ptr, "ns2:getNewBulkGoodsInf");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__getSearchCarsInfResponse:
		((ns2__getSearchCarsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSearchCarsInf:
		((ns2__getSearchCarsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getAgentPopAdResponse:
		((ns2__getAgentPopAdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getAgentPopAd:
		((ns2__getAgentPopAd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSearchCarsInfNewResponse:
		((ns2__getSearchCarsInfNewResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSearchCarsInfNew:
		((ns2__getSearchCarsInfNew *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__delFavoriteSpecialLineResponse:
		((ns2__delFavoriteSpecialLineResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__delFavoriteSpecialLine:
		((ns2__delFavoriteSpecialLine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getNewGoodsInfResponse:
		((ns2__getNewGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getNewGoodsInf:
		((ns2__getNewGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMySpecialLineInfResponse:
		((ns2__getMySpecialLineInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMySpecialLineInf:
		((ns2__getMySpecialLineInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setPubSpecialLineInfResponse:
		((ns2__setPubSpecialLineInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setPubSpecialLineInf:
		((ns2__setPubSpecialLineInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__delCarsInfResponse:
		((ns2__delCarsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__delCarsInf:
		((ns2__delCarsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getPersisCarsInfoResponse:
		((ns2__getPersisCarsInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getPersisCarsInfo:
		((ns2__getPersisCarsInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__browseZoneCarsResponse:
		((ns2__browseZoneCarsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__browseZoneCars:
		((ns2__browseZoneCars *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__placeOrderResponse:
		((ns2__placeOrderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__placeOrder:
		((ns2__placeOrder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getPersisGoodsInfoResponse:
		((ns2__getPersisGoodsInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getPersisGoodsInfo:
		((ns2__getPersisGoodsInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__usrLoginResponse:
		((ns2__usrLoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__usrLogin:
		((ns2__usrLogin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__delBulkGoodsInfResponse:
		((ns2__delBulkGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__delBulkGoodsInf:
		((ns2__delBulkGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClickSearchCarsInfResponse:
		((ns2__getClickSearchCarsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClickSearchCarsInf:
		((ns2__getClickSearchCarsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setPubCarsInfResponse:
		((ns2__setPubCarsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setPubCarsInf:
		((ns2__setPubCarsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse:
		((ns2__getSearchBulkGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSearchBulkGoodsInf:
		((ns2__getSearchBulkGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setPubBulkGoodsInfResponse:
		((ns2__setPubBulkGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setPubBulkGoodsInf:
		((ns2__setPubBulkGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getNewCarsInfResponse:
		((ns2__getNewCarsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getNewCarsInf:
		((ns2__getNewCarsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClickSearchGoodsInfResponse:
		((ns2__getClickSearchGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClickSearchGoodsInf:
		((ns2__getClickSearchGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setPubGoodsInfResponse:
		((ns2__setPubGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setPubGoodsInf:
		((ns2__setPubGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__addUserCustomInfResponse:
		((ns2__addUserCustomInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__addUserCustomInf:
		((ns2__addUserCustomInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMyBulkGoodsInfResponse:
		((ns2__getMyBulkGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMyBulkGoodsInf:
		((ns2__getMyBulkGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__delSpecialLineInfResponse:
		((ns2__delSpecialLineInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__delSpecialLineInf:
		((ns2__delSpecialLineInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getAllSpecialLineInfResponse:
		((ns2__getAllSpecialLineInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getAllSpecialLineInf:
		((ns2__getAllSpecialLineInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse:
		((ns2__getClickSearchSpecialLineInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClickSearchSpecialLineInf:
		((ns2__getClickSearchSpecialLineInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__checkChargeUserResponse:
		((ns2__checkChargeUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__checkChargeUser:
		((ns2__checkChargeUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteUserCustomInfResponse:
		((ns2__deleteUserCustomInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteUserCustomInf:
		((ns2__deleteUserCustomInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setServiceStationInfResponse:
		((ns2__setServiceStationInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setServiceStationInf:
		((ns2__setServiceStationInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse:
		((ns2__getClickSearchBulkGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClickSearchBulkGoodsInf:
		((ns2__getClickSearchBulkGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getCustomGoodsInfResponse:
		((ns2__getCustomGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getCustomGoodsInf:
		((ns2__getCustomGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getAgentScrollAdResponse:
		((ns2__getAgentScrollAdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getAgentScrollAd:
		((ns2__getAgentScrollAd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSystemScrollAdResponse:
		((ns2__getSystemScrollAdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSystemScrollAd:
		((ns2__getSystemScrollAd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMyGoodsInfResponse:
		((ns2__getMyGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMyGoodsInf:
		((ns2__getMyGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSearchGoodsInfNewResponse:
		((ns2__getSearchGoodsInfNewResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSearchGoodsInfNew:
		((ns2__getSearchGoodsInfNew *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSearchGoodsInfResponse:
		((ns2__getSearchGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSearchGoodsInf:
		((ns2__getSearchGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__delGoodsInfResponse:
		((ns2__delGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__delGoodsInf:
		((ns2__delGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getCustomCarsInfResponse:
		((ns2__getCustomCarsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getCustomCarsInf:
		((ns2__getCustomCarsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setGoodsStatusResponse:
		((ns2__setGoodsStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setGoodsStatus:
		((ns2__setGoodsStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClickServiceStationInfResponse:
		((ns2__getClickServiceStationInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClickServiceStationInf:
		((ns2__getClickServiceStationInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSearchSpecialLineInfResponse:
		((ns2__getSearchSpecialLineInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getSearchSpecialLineInf:
		((ns2__getSearchSpecialLineInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setCarsStatusResponse:
		((ns2__setCarsStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setCarsStatus:
		((ns2__setCarsStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__sendPhoneMessageResponse:
		((ns2__sendPhoneMessageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__sendPhoneMessage:
		((ns2__sendPhoneMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMyCarsInfResponse:
		((ns2__getMyCarsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMyCarsInf:
		((ns2__getMyCarsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse:
		((ns2__getFavoriteSpecialLineInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getFavoriteSpecialLineInf:
		((ns2__getFavoriteSpecialLineInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getUserCustomInfResponse:
		((ns2__getUserCustomInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getUserCustomInf:
		((ns2__getUserCustomInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__collectSpecialLineResponse:
		((ns2__collectSpecialLineResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__collectSpecialLine:
		((ns2__collectSpecialLine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getNewBulkGoodsInfResponse:
		((ns2__getNewBulkGoodsInfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getNewBulkGoodsInf:
		((ns2__getNewBulkGoodsInf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__getSearchCarsInf:
		soap_serialize___ns1__getSearchCarsInf(soap, (const struct __ns1__getSearchCarsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getAgentPopAd:
		soap_serialize___ns1__getAgentPopAd(soap, (const struct __ns1__getAgentPopAd *)ptr);
		break;
	case SOAP_TYPE___ns1__getSearchCarsInfNew:
		soap_serialize___ns1__getSearchCarsInfNew(soap, (const struct __ns1__getSearchCarsInfNew *)ptr);
		break;
	case SOAP_TYPE___ns1__delFavoriteSpecialLine:
		soap_serialize___ns1__delFavoriteSpecialLine(soap, (const struct __ns1__delFavoriteSpecialLine *)ptr);
		break;
	case SOAP_TYPE___ns1__getNewGoodsInf:
		soap_serialize___ns1__getNewGoodsInf(soap, (const struct __ns1__getNewGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__setPubSpecialLineInf:
		soap_serialize___ns1__setPubSpecialLineInf(soap, (const struct __ns1__setPubSpecialLineInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getMySpecialLineInf:
		soap_serialize___ns1__getMySpecialLineInf(soap, (const struct __ns1__getMySpecialLineInf *)ptr);
		break;
	case SOAP_TYPE___ns1__delCarsInf:
		soap_serialize___ns1__delCarsInf(soap, (const struct __ns1__delCarsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getPersisCarsInfo:
		soap_serialize___ns1__getPersisCarsInfo(soap, (const struct __ns1__getPersisCarsInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__placeOrder:
		soap_serialize___ns1__placeOrder(soap, (const struct __ns1__placeOrder *)ptr);
		break;
	case SOAP_TYPE___ns1__browseZoneCars:
		soap_serialize___ns1__browseZoneCars(soap, (const struct __ns1__browseZoneCars *)ptr);
		break;
	case SOAP_TYPE___ns1__getPersisGoodsInfo:
		soap_serialize___ns1__getPersisGoodsInfo(soap, (const struct __ns1__getPersisGoodsInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__usrLogin:
		soap_serialize___ns1__usrLogin(soap, (const struct __ns1__usrLogin *)ptr);
		break;
	case SOAP_TYPE___ns1__delBulkGoodsInf:
		soap_serialize___ns1__delBulkGoodsInf(soap, (const struct __ns1__delBulkGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getClickSearchCarsInf:
		soap_serialize___ns1__getClickSearchCarsInf(soap, (const struct __ns1__getClickSearchCarsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__setPubCarsInf:
		soap_serialize___ns1__setPubCarsInf(soap, (const struct __ns1__setPubCarsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__setPubBulkGoodsInf:
		soap_serialize___ns1__setPubBulkGoodsInf(soap, (const struct __ns1__setPubBulkGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getSearchBulkGoodsInf:
		soap_serialize___ns1__getSearchBulkGoodsInf(soap, (const struct __ns1__getSearchBulkGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getNewCarsInf:
		soap_serialize___ns1__getNewCarsInf(soap, (const struct __ns1__getNewCarsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__setPubGoodsInf:
		soap_serialize___ns1__setPubGoodsInf(soap, (const struct __ns1__setPubGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getClickSearchGoodsInf:
		soap_serialize___ns1__getClickSearchGoodsInf(soap, (const struct __ns1__getClickSearchGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__addUserCustomInf:
		soap_serialize___ns1__addUserCustomInf(soap, (const struct __ns1__addUserCustomInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getMyBulkGoodsInf:
		soap_serialize___ns1__getMyBulkGoodsInf(soap, (const struct __ns1__getMyBulkGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__delSpecialLineInf:
		soap_serialize___ns1__delSpecialLineInf(soap, (const struct __ns1__delSpecialLineInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getClickSearchSpecialLineInf:
		soap_serialize___ns1__getClickSearchSpecialLineInf(soap, (const struct __ns1__getClickSearchSpecialLineInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getAllSpecialLineInf:
		soap_serialize___ns1__getAllSpecialLineInf(soap, (const struct __ns1__getAllSpecialLineInf *)ptr);
		break;
	case SOAP_TYPE___ns1__setServiceStationInf:
		soap_serialize___ns1__setServiceStationInf(soap, (const struct __ns1__setServiceStationInf *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteUserCustomInf:
		soap_serialize___ns1__deleteUserCustomInf(soap, (const struct __ns1__deleteUserCustomInf *)ptr);
		break;
	case SOAP_TYPE___ns1__checkChargeUser:
		soap_serialize___ns1__checkChargeUser(soap, (const struct __ns1__checkChargeUser *)ptr);
		break;
	case SOAP_TYPE___ns1__getClickSearchBulkGoodsInf:
		soap_serialize___ns1__getClickSearchBulkGoodsInf(soap, (const struct __ns1__getClickSearchBulkGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getCustomGoodsInf:
		soap_serialize___ns1__getCustomGoodsInf(soap, (const struct __ns1__getCustomGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getAgentScrollAd:
		soap_serialize___ns1__getAgentScrollAd(soap, (const struct __ns1__getAgentScrollAd *)ptr);
		break;
	case SOAP_TYPE___ns1__getSystemScrollAd:
		soap_serialize___ns1__getSystemScrollAd(soap, (const struct __ns1__getSystemScrollAd *)ptr);
		break;
	case SOAP_TYPE___ns1__getMyGoodsInf:
		soap_serialize___ns1__getMyGoodsInf(soap, (const struct __ns1__getMyGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getSearchGoodsInfNew:
		soap_serialize___ns1__getSearchGoodsInfNew(soap, (const struct __ns1__getSearchGoodsInfNew *)ptr);
		break;
	case SOAP_TYPE___ns1__getSearchGoodsInf:
		soap_serialize___ns1__getSearchGoodsInf(soap, (const struct __ns1__getSearchGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__delGoodsInf:
		soap_serialize___ns1__delGoodsInf(soap, (const struct __ns1__delGoodsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__setGoodsStatus:
		soap_serialize___ns1__setGoodsStatus(soap, (const struct __ns1__setGoodsStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__getCustomCarsInf:
		soap_serialize___ns1__getCustomCarsInf(soap, (const struct __ns1__getCustomCarsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getSearchSpecialLineInf:
		soap_serialize___ns1__getSearchSpecialLineInf(soap, (const struct __ns1__getSearchSpecialLineInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getClickServiceStationInf:
		soap_serialize___ns1__getClickServiceStationInf(soap, (const struct __ns1__getClickServiceStationInf *)ptr);
		break;
	case SOAP_TYPE___ns1__setCarsStatus:
		soap_serialize___ns1__setCarsStatus(soap, (const struct __ns1__setCarsStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__sendPhoneMessage:
		soap_serialize___ns1__sendPhoneMessage(soap, (const struct __ns1__sendPhoneMessage *)ptr);
		break;
	case SOAP_TYPE___ns1__getMyCarsInf:
		soap_serialize___ns1__getMyCarsInf(soap, (const struct __ns1__getMyCarsInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getUserCustomInf:
		soap_serialize___ns1__getUserCustomInf(soap, (const struct __ns1__getUserCustomInf *)ptr);
		break;
	case SOAP_TYPE___ns1__getFavoriteSpecialLineInf:
		soap_serialize___ns1__getFavoriteSpecialLineInf(soap, (const struct __ns1__getFavoriteSpecialLineInf *)ptr);
		break;
	case SOAP_TYPE___ns1__collectSpecialLine:
		soap_serialize___ns1__collectSpecialLine(soap, (const struct __ns1__collectSpecialLine *)ptr);
		break;
	case SOAP_TYPE___ns1__getNewBulkGoodsInf:
		soap_serialize___ns1__getNewBulkGoodsInf(soap, (const struct __ns1__getNewBulkGoodsInf *)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchCarsInfResponse:
		soap_serialize_PointerTons2__getSearchCarsInfResponse(soap, (ns2__getSearchCarsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchCarsInf:
		soap_serialize_PointerTons2__getSearchCarsInf(soap, (ns2__getSearchCarsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getAgentPopAdResponse:
		soap_serialize_PointerTons2__getAgentPopAdResponse(soap, (ns2__getAgentPopAdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getAgentPopAd:
		soap_serialize_PointerTons2__getAgentPopAd(soap, (ns2__getAgentPopAd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchCarsInfNewResponse:
		soap_serialize_PointerTons2__getSearchCarsInfNewResponse(soap, (ns2__getSearchCarsInfNewResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchCarsInfNew:
		soap_serialize_PointerTons2__getSearchCarsInfNew(soap, (ns2__getSearchCarsInfNew *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__delFavoriteSpecialLineResponse:
		soap_serialize_PointerTons2__delFavoriteSpecialLineResponse(soap, (ns2__delFavoriteSpecialLineResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__delFavoriteSpecialLine:
		soap_serialize_PointerTons2__delFavoriteSpecialLine(soap, (ns2__delFavoriteSpecialLine *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getNewGoodsInfResponse:
		soap_serialize_PointerTons2__getNewGoodsInfResponse(soap, (ns2__getNewGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getNewGoodsInf:
		soap_serialize_PointerTons2__getNewGoodsInf(soap, (ns2__getNewGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setPubSpecialLineInfResponse:
		soap_serialize_PointerTons2__setPubSpecialLineInfResponse(soap, (ns2__setPubSpecialLineInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setPubSpecialLineInf:
		soap_serialize_PointerTons2__setPubSpecialLineInf(soap, (ns2__setPubSpecialLineInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getMySpecialLineInfResponse:
		soap_serialize_PointerTons2__getMySpecialLineInfResponse(soap, (ns2__getMySpecialLineInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getMySpecialLineInf:
		soap_serialize_PointerTons2__getMySpecialLineInf(soap, (ns2__getMySpecialLineInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__delCarsInfResponse:
		soap_serialize_PointerTons2__delCarsInfResponse(soap, (ns2__delCarsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__delCarsInf:
		soap_serialize_PointerTons2__delCarsInf(soap, (ns2__delCarsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getPersisCarsInfoResponse:
		soap_serialize_PointerTons2__getPersisCarsInfoResponse(soap, (ns2__getPersisCarsInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getPersisCarsInfo:
		soap_serialize_PointerTons2__getPersisCarsInfo(soap, (ns2__getPersisCarsInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__placeOrderResponse:
		soap_serialize_PointerTons2__placeOrderResponse(soap, (ns2__placeOrderResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__placeOrder:
		soap_serialize_PointerTons2__placeOrder(soap, (ns2__placeOrder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__browseZoneCarsResponse:
		soap_serialize_PointerTons2__browseZoneCarsResponse(soap, (ns2__browseZoneCarsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__browseZoneCars:
		soap_serialize_PointerTons2__browseZoneCars(soap, (ns2__browseZoneCars *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getPersisGoodsInfoResponse:
		soap_serialize_PointerTons2__getPersisGoodsInfoResponse(soap, (ns2__getPersisGoodsInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getPersisGoodsInfo:
		soap_serialize_PointerTons2__getPersisGoodsInfo(soap, (ns2__getPersisGoodsInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__usrLoginResponse:
		soap_serialize_PointerTons2__usrLoginResponse(soap, (ns2__usrLoginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__usrLogin:
		soap_serialize_PointerTons2__usrLogin(soap, (ns2__usrLogin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__delBulkGoodsInfResponse:
		soap_serialize_PointerTons2__delBulkGoodsInfResponse(soap, (ns2__delBulkGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__delBulkGoodsInf:
		soap_serialize_PointerTons2__delBulkGoodsInf(soap, (ns2__delBulkGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClickSearchCarsInfResponse:
		soap_serialize_PointerTons2__getClickSearchCarsInfResponse(soap, (ns2__getClickSearchCarsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClickSearchCarsInf:
		soap_serialize_PointerTons2__getClickSearchCarsInf(soap, (ns2__getClickSearchCarsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setPubCarsInfResponse:
		soap_serialize_PointerTons2__setPubCarsInfResponse(soap, (ns2__setPubCarsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setPubCarsInf:
		soap_serialize_PointerTons2__setPubCarsInf(soap, (ns2__setPubCarsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setPubBulkGoodsInfResponse:
		soap_serialize_PointerTons2__setPubBulkGoodsInfResponse(soap, (ns2__setPubBulkGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setPubBulkGoodsInf:
		soap_serialize_PointerTons2__setPubBulkGoodsInf(soap, (ns2__setPubBulkGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchBulkGoodsInfResponse:
		soap_serialize_PointerTons2__getSearchBulkGoodsInfResponse(soap, (ns2__getSearchBulkGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchBulkGoodsInf:
		soap_serialize_PointerTons2__getSearchBulkGoodsInf(soap, (ns2__getSearchBulkGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getNewCarsInfResponse:
		soap_serialize_PointerTons2__getNewCarsInfResponse(soap, (ns2__getNewCarsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getNewCarsInf:
		soap_serialize_PointerTons2__getNewCarsInf(soap, (ns2__getNewCarsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setPubGoodsInfResponse:
		soap_serialize_PointerTons2__setPubGoodsInfResponse(soap, (ns2__setPubGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setPubGoodsInf:
		soap_serialize_PointerTons2__setPubGoodsInf(soap, (ns2__setPubGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClickSearchGoodsInfResponse:
		soap_serialize_PointerTons2__getClickSearchGoodsInfResponse(soap, (ns2__getClickSearchGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClickSearchGoodsInf:
		soap_serialize_PointerTons2__getClickSearchGoodsInf(soap, (ns2__getClickSearchGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__addUserCustomInfResponse:
		soap_serialize_PointerTons2__addUserCustomInfResponse(soap, (ns2__addUserCustomInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__addUserCustomInf:
		soap_serialize_PointerTons2__addUserCustomInf(soap, (ns2__addUserCustomInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getMyBulkGoodsInfResponse:
		soap_serialize_PointerTons2__getMyBulkGoodsInfResponse(soap, (ns2__getMyBulkGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getMyBulkGoodsInf:
		soap_serialize_PointerTons2__getMyBulkGoodsInf(soap, (ns2__getMyBulkGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__delSpecialLineInfResponse:
		soap_serialize_PointerTons2__delSpecialLineInfResponse(soap, (ns2__delSpecialLineInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__delSpecialLineInf:
		soap_serialize_PointerTons2__delSpecialLineInf(soap, (ns2__delSpecialLineInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClickSearchSpecialLineInfResponse:
		soap_serialize_PointerTons2__getClickSearchSpecialLineInfResponse(soap, (ns2__getClickSearchSpecialLineInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClickSearchSpecialLineInf:
		soap_serialize_PointerTons2__getClickSearchSpecialLineInf(soap, (ns2__getClickSearchSpecialLineInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getAllSpecialLineInfResponse:
		soap_serialize_PointerTons2__getAllSpecialLineInfResponse(soap, (ns2__getAllSpecialLineInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getAllSpecialLineInf:
		soap_serialize_PointerTons2__getAllSpecialLineInf(soap, (ns2__getAllSpecialLineInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setServiceStationInfResponse:
		soap_serialize_PointerTons2__setServiceStationInfResponse(soap, (ns2__setServiceStationInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setServiceStationInf:
		soap_serialize_PointerTons2__setServiceStationInf(soap, (ns2__setServiceStationInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__deleteUserCustomInfResponse:
		soap_serialize_PointerTons2__deleteUserCustomInfResponse(soap, (ns2__deleteUserCustomInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__deleteUserCustomInf:
		soap_serialize_PointerTons2__deleteUserCustomInf(soap, (ns2__deleteUserCustomInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__checkChargeUserResponse:
		soap_serialize_PointerTons2__checkChargeUserResponse(soap, (ns2__checkChargeUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__checkChargeUser:
		soap_serialize_PointerTons2__checkChargeUser(soap, (ns2__checkChargeUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClickSearchBulkGoodsInfResponse:
		soap_serialize_PointerTons2__getClickSearchBulkGoodsInfResponse(soap, (ns2__getClickSearchBulkGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClickSearchBulkGoodsInf:
		soap_serialize_PointerTons2__getClickSearchBulkGoodsInf(soap, (ns2__getClickSearchBulkGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getCustomGoodsInfResponse:
		soap_serialize_PointerTons2__getCustomGoodsInfResponse(soap, (ns2__getCustomGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getCustomGoodsInf:
		soap_serialize_PointerTons2__getCustomGoodsInf(soap, (ns2__getCustomGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getAgentScrollAdResponse:
		soap_serialize_PointerTons2__getAgentScrollAdResponse(soap, (ns2__getAgentScrollAdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getAgentScrollAd:
		soap_serialize_PointerTons2__getAgentScrollAd(soap, (ns2__getAgentScrollAd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSystemScrollAdResponse:
		soap_serialize_PointerTons2__getSystemScrollAdResponse(soap, (ns2__getSystemScrollAdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSystemScrollAd:
		soap_serialize_PointerTons2__getSystemScrollAd(soap, (ns2__getSystemScrollAd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getMyGoodsInfResponse:
		soap_serialize_PointerTons2__getMyGoodsInfResponse(soap, (ns2__getMyGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getMyGoodsInf:
		soap_serialize_PointerTons2__getMyGoodsInf(soap, (ns2__getMyGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchGoodsInfNewResponse:
		soap_serialize_PointerTons2__getSearchGoodsInfNewResponse(soap, (ns2__getSearchGoodsInfNewResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchGoodsInfNew:
		soap_serialize_PointerTons2__getSearchGoodsInfNew(soap, (ns2__getSearchGoodsInfNew *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchGoodsInfResponse:
		soap_serialize_PointerTons2__getSearchGoodsInfResponse(soap, (ns2__getSearchGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchGoodsInf:
		soap_serialize_PointerTons2__getSearchGoodsInf(soap, (ns2__getSearchGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__delGoodsInfResponse:
		soap_serialize_PointerTons2__delGoodsInfResponse(soap, (ns2__delGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__delGoodsInf:
		soap_serialize_PointerTons2__delGoodsInf(soap, (ns2__delGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setGoodsStatusResponse:
		soap_serialize_PointerTons2__setGoodsStatusResponse(soap, (ns2__setGoodsStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setGoodsStatus:
		soap_serialize_PointerTons2__setGoodsStatus(soap, (ns2__setGoodsStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getCustomCarsInfResponse:
		soap_serialize_PointerTons2__getCustomCarsInfResponse(soap, (ns2__getCustomCarsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getCustomCarsInf:
		soap_serialize_PointerTons2__getCustomCarsInf(soap, (ns2__getCustomCarsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchSpecialLineInfResponse:
		soap_serialize_PointerTons2__getSearchSpecialLineInfResponse(soap, (ns2__getSearchSpecialLineInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSearchSpecialLineInf:
		soap_serialize_PointerTons2__getSearchSpecialLineInf(soap, (ns2__getSearchSpecialLineInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClickServiceStationInfResponse:
		soap_serialize_PointerTons2__getClickServiceStationInfResponse(soap, (ns2__getClickServiceStationInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClickServiceStationInf:
		soap_serialize_PointerTons2__getClickServiceStationInf(soap, (ns2__getClickServiceStationInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setCarsStatusResponse:
		soap_serialize_PointerTons2__setCarsStatusResponse(soap, (ns2__setCarsStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setCarsStatus:
		soap_serialize_PointerTons2__setCarsStatus(soap, (ns2__setCarsStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__sendPhoneMessageResponse:
		soap_serialize_PointerTons2__sendPhoneMessageResponse(soap, (ns2__sendPhoneMessageResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__sendPhoneMessage:
		soap_serialize_PointerTons2__sendPhoneMessage(soap, (ns2__sendPhoneMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getMyCarsInfResponse:
		soap_serialize_PointerTons2__getMyCarsInfResponse(soap, (ns2__getMyCarsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getMyCarsInf:
		soap_serialize_PointerTons2__getMyCarsInf(soap, (ns2__getMyCarsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getUserCustomInfResponse:
		soap_serialize_PointerTons2__getUserCustomInfResponse(soap, (ns2__getUserCustomInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getUserCustomInf:
		soap_serialize_PointerTons2__getUserCustomInf(soap, (ns2__getUserCustomInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getFavoriteSpecialLineInfResponse:
		soap_serialize_PointerTons2__getFavoriteSpecialLineInfResponse(soap, (ns2__getFavoriteSpecialLineInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getFavoriteSpecialLineInf:
		soap_serialize_PointerTons2__getFavoriteSpecialLineInf(soap, (ns2__getFavoriteSpecialLineInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__collectSpecialLineResponse:
		soap_serialize_PointerTons2__collectSpecialLineResponse(soap, (ns2__collectSpecialLineResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__collectSpecialLine:
		soap_serialize_PointerTons2__collectSpecialLine(soap, (ns2__collectSpecialLine *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getNewBulkGoodsInfResponse:
		soap_serialize_PointerTons2__getNewBulkGoodsInfResponse(soap, (ns2__getNewBulkGoodsInfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getNewBulkGoodsInf:
		soap_serialize_PointerTons2__getNewBulkGoodsInf(soap, (ns2__getNewBulkGoodsInf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getNewBulkGoodsInf:
		return (void*)soap_instantiate_ns2__getNewBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getNewBulkGoodsInfResponse:
		return (void*)soap_instantiate_ns2__getNewBulkGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__collectSpecialLine:
		return (void*)soap_instantiate_ns2__collectSpecialLine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__collectSpecialLineResponse:
		return (void*)soap_instantiate_ns2__collectSpecialLineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getUserCustomInf:
		return (void*)soap_instantiate_ns2__getUserCustomInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getUserCustomInfResponse:
		return (void*)soap_instantiate_ns2__getUserCustomInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getFavoriteSpecialLineInf:
		return (void*)soap_instantiate_ns2__getFavoriteSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse:
		return (void*)soap_instantiate_ns2__getFavoriteSpecialLineInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMyCarsInf:
		return (void*)soap_instantiate_ns2__getMyCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMyCarsInfResponse:
		return (void*)soap_instantiate_ns2__getMyCarsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__sendPhoneMessage:
		return (void*)soap_instantiate_ns2__sendPhoneMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__sendPhoneMessageResponse:
		return (void*)soap_instantiate_ns2__sendPhoneMessageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setCarsStatus:
		return (void*)soap_instantiate_ns2__setCarsStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setCarsStatusResponse:
		return (void*)soap_instantiate_ns2__setCarsStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchSpecialLineInf:
		return (void*)soap_instantiate_ns2__getSearchSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchSpecialLineInfResponse:
		return (void*)soap_instantiate_ns2__getSearchSpecialLineInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClickServiceStationInf:
		return (void*)soap_instantiate_ns2__getClickServiceStationInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClickServiceStationInfResponse:
		return (void*)soap_instantiate_ns2__getClickServiceStationInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setGoodsStatus:
		return (void*)soap_instantiate_ns2__setGoodsStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setGoodsStatusResponse:
		return (void*)soap_instantiate_ns2__setGoodsStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getCustomCarsInf:
		return (void*)soap_instantiate_ns2__getCustomCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getCustomCarsInfResponse:
		return (void*)soap_instantiate_ns2__getCustomCarsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__delGoodsInf:
		return (void*)soap_instantiate_ns2__delGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__delGoodsInfResponse:
		return (void*)soap_instantiate_ns2__delGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchGoodsInf:
		return (void*)soap_instantiate_ns2__getSearchGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchGoodsInfResponse:
		return (void*)soap_instantiate_ns2__getSearchGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchGoodsInfNew:
		return (void*)soap_instantiate_ns2__getSearchGoodsInfNew(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchGoodsInfNewResponse:
		return (void*)soap_instantiate_ns2__getSearchGoodsInfNewResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMyGoodsInf:
		return (void*)soap_instantiate_ns2__getMyGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMyGoodsInfResponse:
		return (void*)soap_instantiate_ns2__getMyGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSystemScrollAd:
		return (void*)soap_instantiate_ns2__getSystemScrollAd(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSystemScrollAdResponse:
		return (void*)soap_instantiate_ns2__getSystemScrollAdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getAgentScrollAd:
		return (void*)soap_instantiate_ns2__getAgentScrollAd(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getAgentScrollAdResponse:
		return (void*)soap_instantiate_ns2__getAgentScrollAdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getCustomGoodsInf:
		return (void*)soap_instantiate_ns2__getCustomGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getCustomGoodsInfResponse:
		return (void*)soap_instantiate_ns2__getCustomGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClickSearchBulkGoodsInf:
		return (void*)soap_instantiate_ns2__getClickSearchBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse:
		return (void*)soap_instantiate_ns2__getClickSearchBulkGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setServiceStationInf:
		return (void*)soap_instantiate_ns2__setServiceStationInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setServiceStationInfResponse:
		return (void*)soap_instantiate_ns2__setServiceStationInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteUserCustomInf:
		return (void*)soap_instantiate_ns2__deleteUserCustomInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteUserCustomInfResponse:
		return (void*)soap_instantiate_ns2__deleteUserCustomInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__checkChargeUser:
		return (void*)soap_instantiate_ns2__checkChargeUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__checkChargeUserResponse:
		return (void*)soap_instantiate_ns2__checkChargeUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClickSearchSpecialLineInf:
		return (void*)soap_instantiate_ns2__getClickSearchSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse:
		return (void*)soap_instantiate_ns2__getClickSearchSpecialLineInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getAllSpecialLineInf:
		return (void*)soap_instantiate_ns2__getAllSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getAllSpecialLineInfResponse:
		return (void*)soap_instantiate_ns2__getAllSpecialLineInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__delSpecialLineInf:
		return (void*)soap_instantiate_ns2__delSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__delSpecialLineInfResponse:
		return (void*)soap_instantiate_ns2__delSpecialLineInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMyBulkGoodsInf:
		return (void*)soap_instantiate_ns2__getMyBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMyBulkGoodsInfResponse:
		return (void*)soap_instantiate_ns2__getMyBulkGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__addUserCustomInf:
		return (void*)soap_instantiate_ns2__addUserCustomInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__addUserCustomInfResponse:
		return (void*)soap_instantiate_ns2__addUserCustomInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setPubGoodsInf:
		return (void*)soap_instantiate_ns2__setPubGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setPubGoodsInfResponse:
		return (void*)soap_instantiate_ns2__setPubGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClickSearchGoodsInf:
		return (void*)soap_instantiate_ns2__getClickSearchGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClickSearchGoodsInfResponse:
		return (void*)soap_instantiate_ns2__getClickSearchGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getNewCarsInf:
		return (void*)soap_instantiate_ns2__getNewCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getNewCarsInfResponse:
		return (void*)soap_instantiate_ns2__getNewCarsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setPubBulkGoodsInf:
		return (void*)soap_instantiate_ns2__setPubBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setPubBulkGoodsInfResponse:
		return (void*)soap_instantiate_ns2__setPubBulkGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchBulkGoodsInf:
		return (void*)soap_instantiate_ns2__getSearchBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse:
		return (void*)soap_instantiate_ns2__getSearchBulkGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setPubCarsInf:
		return (void*)soap_instantiate_ns2__setPubCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setPubCarsInfResponse:
		return (void*)soap_instantiate_ns2__setPubCarsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClickSearchCarsInf:
		return (void*)soap_instantiate_ns2__getClickSearchCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClickSearchCarsInfResponse:
		return (void*)soap_instantiate_ns2__getClickSearchCarsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__delBulkGoodsInf:
		return (void*)soap_instantiate_ns2__delBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__delBulkGoodsInfResponse:
		return (void*)soap_instantiate_ns2__delBulkGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__usrLogin:
		return (void*)soap_instantiate_ns2__usrLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__usrLoginResponse:
		return (void*)soap_instantiate_ns2__usrLoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getPersisGoodsInfo:
		return (void*)soap_instantiate_ns2__getPersisGoodsInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getPersisGoodsInfoResponse:
		return (void*)soap_instantiate_ns2__getPersisGoodsInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__placeOrder:
		return (void*)soap_instantiate_ns2__placeOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__placeOrderResponse:
		return (void*)soap_instantiate_ns2__placeOrderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__browseZoneCars:
		return (void*)soap_instantiate_ns2__browseZoneCars(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__browseZoneCarsResponse:
		return (void*)soap_instantiate_ns2__browseZoneCarsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getPersisCarsInfo:
		return (void*)soap_instantiate_ns2__getPersisCarsInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getPersisCarsInfoResponse:
		return (void*)soap_instantiate_ns2__getPersisCarsInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__delCarsInf:
		return (void*)soap_instantiate_ns2__delCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__delCarsInfResponse:
		return (void*)soap_instantiate_ns2__delCarsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setPubSpecialLineInf:
		return (void*)soap_instantiate_ns2__setPubSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setPubSpecialLineInfResponse:
		return (void*)soap_instantiate_ns2__setPubSpecialLineInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMySpecialLineInf:
		return (void*)soap_instantiate_ns2__getMySpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMySpecialLineInfResponse:
		return (void*)soap_instantiate_ns2__getMySpecialLineInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getNewGoodsInf:
		return (void*)soap_instantiate_ns2__getNewGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getNewGoodsInfResponse:
		return (void*)soap_instantiate_ns2__getNewGoodsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__delFavoriteSpecialLine:
		return (void*)soap_instantiate_ns2__delFavoriteSpecialLine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__delFavoriteSpecialLineResponse:
		return (void*)soap_instantiate_ns2__delFavoriteSpecialLineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchCarsInfNew:
		return (void*)soap_instantiate_ns2__getSearchCarsInfNew(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchCarsInfNewResponse:
		return (void*)soap_instantiate_ns2__getSearchCarsInfNewResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getAgentPopAd:
		return (void*)soap_instantiate_ns2__getAgentPopAd(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getAgentPopAdResponse:
		return (void*)soap_instantiate_ns2__getAgentPopAdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchCarsInf:
		return (void*)soap_instantiate_ns2__getSearchCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSearchCarsInfResponse:
		return (void*)soap_instantiate_ns2__getSearchCarsInfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getNewBulkGoodsInf:
		return (void*)soap_instantiate___ns1__getNewBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__collectSpecialLine:
		return (void*)soap_instantiate___ns1__collectSpecialLine(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getFavoriteSpecialLineInf:
		return (void*)soap_instantiate___ns1__getFavoriteSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getUserCustomInf:
		return (void*)soap_instantiate___ns1__getUserCustomInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMyCarsInf:
		return (void*)soap_instantiate___ns1__getMyCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendPhoneMessage:
		return (void*)soap_instantiate___ns1__sendPhoneMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setCarsStatus:
		return (void*)soap_instantiate___ns1__setCarsStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getClickServiceStationInf:
		return (void*)soap_instantiate___ns1__getClickServiceStationInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSearchSpecialLineInf:
		return (void*)soap_instantiate___ns1__getSearchSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCustomCarsInf:
		return (void*)soap_instantiate___ns1__getCustomCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setGoodsStatus:
		return (void*)soap_instantiate___ns1__setGoodsStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__delGoodsInf:
		return (void*)soap_instantiate___ns1__delGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSearchGoodsInf:
		return (void*)soap_instantiate___ns1__getSearchGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSearchGoodsInfNew:
		return (void*)soap_instantiate___ns1__getSearchGoodsInfNew(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMyGoodsInf:
		return (void*)soap_instantiate___ns1__getMyGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSystemScrollAd:
		return (void*)soap_instantiate___ns1__getSystemScrollAd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAgentScrollAd:
		return (void*)soap_instantiate___ns1__getAgentScrollAd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCustomGoodsInf:
		return (void*)soap_instantiate___ns1__getCustomGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getClickSearchBulkGoodsInf:
		return (void*)soap_instantiate___ns1__getClickSearchBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkChargeUser:
		return (void*)soap_instantiate___ns1__checkChargeUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteUserCustomInf:
		return (void*)soap_instantiate___ns1__deleteUserCustomInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setServiceStationInf:
		return (void*)soap_instantiate___ns1__setServiceStationInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAllSpecialLineInf:
		return (void*)soap_instantiate___ns1__getAllSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getClickSearchSpecialLineInf:
		return (void*)soap_instantiate___ns1__getClickSearchSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__delSpecialLineInf:
		return (void*)soap_instantiate___ns1__delSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMyBulkGoodsInf:
		return (void*)soap_instantiate___ns1__getMyBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addUserCustomInf:
		return (void*)soap_instantiate___ns1__addUserCustomInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getClickSearchGoodsInf:
		return (void*)soap_instantiate___ns1__getClickSearchGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setPubGoodsInf:
		return (void*)soap_instantiate___ns1__setPubGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getNewCarsInf:
		return (void*)soap_instantiate___ns1__getNewCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSearchBulkGoodsInf:
		return (void*)soap_instantiate___ns1__getSearchBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setPubBulkGoodsInf:
		return (void*)soap_instantiate___ns1__setPubBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setPubCarsInf:
		return (void*)soap_instantiate___ns1__setPubCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getClickSearchCarsInf:
		return (void*)soap_instantiate___ns1__getClickSearchCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__delBulkGoodsInf:
		return (void*)soap_instantiate___ns1__delBulkGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__usrLogin:
		return (void*)soap_instantiate___ns1__usrLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPersisGoodsInfo:
		return (void*)soap_instantiate___ns1__getPersisGoodsInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__browseZoneCars:
		return (void*)soap_instantiate___ns1__browseZoneCars(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__placeOrder:
		return (void*)soap_instantiate___ns1__placeOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPersisCarsInfo:
		return (void*)soap_instantiate___ns1__getPersisCarsInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__delCarsInf:
		return (void*)soap_instantiate___ns1__delCarsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMySpecialLineInf:
		return (void*)soap_instantiate___ns1__getMySpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setPubSpecialLineInf:
		return (void*)soap_instantiate___ns1__setPubSpecialLineInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getNewGoodsInf:
		return (void*)soap_instantiate___ns1__getNewGoodsInf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__delFavoriteSpecialLine:
		return (void*)soap_instantiate___ns1__delFavoriteSpecialLine(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSearchCarsInfNew:
		return (void*)soap_instantiate___ns1__getSearchCarsInfNew(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAgentPopAd:
		return (void*)soap_instantiate___ns1__getAgentPopAd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSearchCarsInf:
		return (void*)soap_instantiate___ns1__getSearchCarsInf(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getNewBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getNewBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getNewBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getNewBulkGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getNewBulkGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getNewBulkGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__collectSpecialLine:
		if (p->size < 0)
			SOAP_DELETE((ns2__collectSpecialLine*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__collectSpecialLine*)p->ptr);
		break;
	case SOAP_TYPE_ns2__collectSpecialLineResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__collectSpecialLineResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__collectSpecialLineResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getUserCustomInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getUserCustomInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getUserCustomInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getUserCustomInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getUserCustomInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getUserCustomInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getFavoriteSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getFavoriteSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getFavoriteSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getFavoriteSpecialLineInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getFavoriteSpecialLineInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getMyCarsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getMyCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getMyCarsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getMyCarsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getMyCarsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getMyCarsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__sendPhoneMessage:
		if (p->size < 0)
			SOAP_DELETE((ns2__sendPhoneMessage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__sendPhoneMessage*)p->ptr);
		break;
	case SOAP_TYPE_ns2__sendPhoneMessageResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__sendPhoneMessageResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__sendPhoneMessageResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setCarsStatus:
		if (p->size < 0)
			SOAP_DELETE((ns2__setCarsStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setCarsStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setCarsStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__setCarsStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setCarsStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchSpecialLineInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchSpecialLineInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchSpecialLineInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getClickServiceStationInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getClickServiceStationInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getClickServiceStationInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getClickServiceStationInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getClickServiceStationInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getClickServiceStationInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setGoodsStatus:
		if (p->size < 0)
			SOAP_DELETE((ns2__setGoodsStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setGoodsStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setGoodsStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__setGoodsStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setGoodsStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getCustomCarsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getCustomCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getCustomCarsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getCustomCarsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getCustomCarsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getCustomCarsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__delGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__delGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__delGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__delGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__delGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__delGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchGoodsInfNew:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchGoodsInfNew*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchGoodsInfNew*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchGoodsInfNewResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchGoodsInfNewResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchGoodsInfNewResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getMyGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getMyGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getMyGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getMyGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getMyGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getMyGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSystemScrollAd:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSystemScrollAd*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSystemScrollAd*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSystemScrollAdResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSystemScrollAdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSystemScrollAdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getAgentScrollAd:
		if (p->size < 0)
			SOAP_DELETE((ns2__getAgentScrollAd*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getAgentScrollAd*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getAgentScrollAdResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getAgentScrollAdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getAgentScrollAdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getCustomGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getCustomGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getCustomGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getCustomGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getCustomGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getCustomGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getClickSearchBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getClickSearchBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getClickSearchBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getClickSearchBulkGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getClickSearchBulkGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setServiceStationInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__setServiceStationInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setServiceStationInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setServiceStationInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__setServiceStationInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setServiceStationInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__deleteUserCustomInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__deleteUserCustomInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__deleteUserCustomInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__deleteUserCustomInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__deleteUserCustomInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__deleteUserCustomInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__checkChargeUser:
		if (p->size < 0)
			SOAP_DELETE((ns2__checkChargeUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__checkChargeUser*)p->ptr);
		break;
	case SOAP_TYPE_ns2__checkChargeUserResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__checkChargeUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__checkChargeUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getClickSearchSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getClickSearchSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getClickSearchSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getClickSearchSpecialLineInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getClickSearchSpecialLineInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getAllSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getAllSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getAllSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getAllSpecialLineInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getAllSpecialLineInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getAllSpecialLineInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__delSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__delSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__delSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__delSpecialLineInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__delSpecialLineInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__delSpecialLineInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getMyBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getMyBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getMyBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getMyBulkGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getMyBulkGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getMyBulkGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__addUserCustomInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__addUserCustomInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__addUserCustomInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__addUserCustomInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__addUserCustomInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__addUserCustomInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setPubGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__setPubGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setPubGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setPubGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__setPubGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setPubGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getClickSearchGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getClickSearchGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getClickSearchGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getClickSearchGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getClickSearchGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getClickSearchGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getNewCarsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getNewCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getNewCarsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getNewCarsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getNewCarsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getNewCarsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setPubBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__setPubBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setPubBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setPubBulkGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__setPubBulkGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setPubBulkGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchBulkGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchBulkGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setPubCarsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__setPubCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setPubCarsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setPubCarsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__setPubCarsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setPubCarsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getClickSearchCarsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getClickSearchCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getClickSearchCarsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getClickSearchCarsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getClickSearchCarsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getClickSearchCarsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__delBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__delBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__delBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__delBulkGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__delBulkGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__delBulkGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__usrLogin:
		if (p->size < 0)
			SOAP_DELETE((ns2__usrLogin*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__usrLogin*)p->ptr);
		break;
	case SOAP_TYPE_ns2__usrLoginResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__usrLoginResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__usrLoginResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getPersisGoodsInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__getPersisGoodsInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getPersisGoodsInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getPersisGoodsInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getPersisGoodsInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getPersisGoodsInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__placeOrder:
		if (p->size < 0)
			SOAP_DELETE((ns2__placeOrder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__placeOrder*)p->ptr);
		break;
	case SOAP_TYPE_ns2__placeOrderResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__placeOrderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__placeOrderResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__browseZoneCars:
		if (p->size < 0)
			SOAP_DELETE((ns2__browseZoneCars*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__browseZoneCars*)p->ptr);
		break;
	case SOAP_TYPE_ns2__browseZoneCarsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__browseZoneCarsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__browseZoneCarsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getPersisCarsInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__getPersisCarsInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getPersisCarsInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getPersisCarsInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getPersisCarsInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getPersisCarsInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__delCarsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__delCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__delCarsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__delCarsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__delCarsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__delCarsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setPubSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__setPubSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setPubSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setPubSpecialLineInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__setPubSpecialLineInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setPubSpecialLineInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getMySpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getMySpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getMySpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getMySpecialLineInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getMySpecialLineInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getMySpecialLineInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getNewGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getNewGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getNewGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getNewGoodsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getNewGoodsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getNewGoodsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__delFavoriteSpecialLine:
		if (p->size < 0)
			SOAP_DELETE((ns2__delFavoriteSpecialLine*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__delFavoriteSpecialLine*)p->ptr);
		break;
	case SOAP_TYPE_ns2__delFavoriteSpecialLineResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__delFavoriteSpecialLineResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__delFavoriteSpecialLineResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchCarsInfNew:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchCarsInfNew*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchCarsInfNew*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchCarsInfNewResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchCarsInfNewResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchCarsInfNewResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getAgentPopAd:
		if (p->size < 0)
			SOAP_DELETE((ns2__getAgentPopAd*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getAgentPopAd*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getAgentPopAdResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getAgentPopAdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getAgentPopAdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchCarsInf:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchCarsInf*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSearchCarsInfResponse:
		if (p->size < 0)
			SOAP_DELETE((ns2__getSearchCarsInfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__getSearchCarsInfResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getNewBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getNewBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getNewBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__collectSpecialLine:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__collectSpecialLine*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__collectSpecialLine*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getFavoriteSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getFavoriteSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getFavoriteSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getUserCustomInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getUserCustomInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getUserCustomInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getMyCarsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getMyCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getMyCarsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__sendPhoneMessage:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__sendPhoneMessage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__sendPhoneMessage*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setCarsStatus:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setCarsStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setCarsStatus*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getClickServiceStationInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getClickServiceStationInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getClickServiceStationInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSearchSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSearchSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSearchSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getCustomCarsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getCustomCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getCustomCarsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setGoodsStatus:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setGoodsStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setGoodsStatus*)p->ptr);
		break;
	case SOAP_TYPE___ns1__delGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__delGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__delGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSearchGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSearchGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSearchGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSearchGoodsInfNew:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSearchGoodsInfNew*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSearchGoodsInfNew*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getMyGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getMyGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getMyGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSystemScrollAd:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSystemScrollAd*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSystemScrollAd*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAgentScrollAd:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAgentScrollAd*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAgentScrollAd*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getCustomGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getCustomGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getCustomGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getClickSearchBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getClickSearchBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getClickSearchBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__checkChargeUser:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__checkChargeUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__checkChargeUser*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteUserCustomInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteUserCustomInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteUserCustomInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setServiceStationInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setServiceStationInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setServiceStationInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAllSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAllSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAllSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getClickSearchSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getClickSearchSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getClickSearchSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__delSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__delSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__delSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getMyBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getMyBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getMyBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addUserCustomInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addUserCustomInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addUserCustomInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getClickSearchGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getClickSearchGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getClickSearchGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setPubGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setPubGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setPubGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getNewCarsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getNewCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getNewCarsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSearchBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSearchBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSearchBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setPubBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setPubBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setPubBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setPubCarsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setPubCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setPubCarsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getClickSearchCarsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getClickSearchCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getClickSearchCarsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__delBulkGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__delBulkGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__delBulkGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__usrLogin:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__usrLogin*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__usrLogin*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getPersisGoodsInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getPersisGoodsInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getPersisGoodsInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__browseZoneCars:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__browseZoneCars*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__browseZoneCars*)p->ptr);
		break;
	case SOAP_TYPE___ns1__placeOrder:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__placeOrder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__placeOrder*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getPersisCarsInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getPersisCarsInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getPersisCarsInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__delCarsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__delCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__delCarsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getMySpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getMySpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getMySpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setPubSpecialLineInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setPubSpecialLineInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setPubSpecialLineInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getNewGoodsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getNewGoodsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getNewGoodsInf*)p->ptr);
		break;
	case SOAP_TYPE___ns1__delFavoriteSpecialLine:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__delFavoriteSpecialLine*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__delFavoriteSpecialLine*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSearchCarsInfNew:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSearchCarsInfNew*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSearchCarsInfNew*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAgentPopAd:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAgentPopAd*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAgentPopAd*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSearchCarsInf:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSearchCarsInf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSearchCarsInf*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void ns2__getSearchCarsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchCarsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getSearchCarsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchCarsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getSearchCarsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchCarsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchCarsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getSearchCarsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchCarsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getSearchCarsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchCarsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchCarsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchCarsInfResponse * SOAP_FMAC4 soap_in_ns2__getSearchCarsInfResponse(struct soap *soap, const char *tag, ns2__getSearchCarsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchCarsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchCarsInfResponse, sizeof(ns2__getSearchCarsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchCarsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchCarsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getSearchCarsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchCarsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchCarsInfResponse, 0, sizeof(ns2__getSearchCarsInfResponse), 0, soap_copy_ns2__getSearchCarsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getSearchCarsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchCarsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchCarsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchCarsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchCarsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchCarsInfResponse * SOAP_FMAC4 soap_get_ns2__getSearchCarsInfResponse(struct soap *soap, ns2__getSearchCarsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchCarsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getSearchCarsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchCarsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchCarsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchCarsInfResponse);
		if (size)
			*size = sizeof(ns2__getSearchCarsInfResponse);
		((ns2__getSearchCarsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchCarsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchCarsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getSearchCarsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchCarsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchCarsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchCarsInfResponse %p -> %p\n", q, p));
	*(ns2__getSearchCarsInfResponse*)p = *(ns2__getSearchCarsInfResponse*)q;
}

void ns2__getSearchCarsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getSearchCarsInf::uid = NULL;
	this->ns2__getSearchCarsInf::input = NULL;
	soap_default_int(soap, &this->ns2__getSearchCarsInf::record);
	soap_default_int(soap, &this->ns2__getSearchCarsInf::curpage);
	/* transient soap skipped */
}

void ns2__getSearchCarsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchCarsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchCarsInf::input);
	/* transient soap skipped */
}

int ns2__getSearchCarsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchCarsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchCarsInf(struct soap *soap, const char *tag, int id, const ns2__getSearchCarsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchCarsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getSearchCarsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__getSearchCarsInf::input), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getSearchCarsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getSearchCarsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchCarsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchCarsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchCarsInf * SOAP_FMAC4 soap_in_ns2__getSearchCarsInf(struct soap *soap, const char *tag, ns2__getSearchCarsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchCarsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchCarsInf, sizeof(ns2__getSearchCarsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchCarsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchCarsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getSearchCarsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__getSearchCarsInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getSearchCarsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getSearchCarsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchCarsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchCarsInf, 0, sizeof(ns2__getSearchCarsInf), 0, soap_copy_ns2__getSearchCarsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getSearchCarsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchCarsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchCarsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchCarsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchCarsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchCarsInf * SOAP_FMAC4 soap_get_ns2__getSearchCarsInf(struct soap *soap, ns2__getSearchCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchCarsInf * SOAP_FMAC2 soap_instantiate_ns2__getSearchCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchCarsInf);
		if (size)
			*size = sizeof(ns2__getSearchCarsInf);
		((ns2__getSearchCarsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchCarsInf);
		for (int i = 0; i < n; i++)
			((ns2__getSearchCarsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchCarsInf %p -> %p\n", q, p));
	*(ns2__getSearchCarsInf*)p = *(ns2__getSearchCarsInf*)q;
}

void ns2__getAgentPopAdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getAgentPopAdResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__getAgentPopAdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getAgentPopAdResponse::return_);
	/* transient soap skipped */
}

int ns2__getAgentPopAdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getAgentPopAdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getAgentPopAdResponse(struct soap *soap, const char *tag, int id, const ns2__getAgentPopAdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getAgentPopAdResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__getAgentPopAdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getAgentPopAdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getAgentPopAdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getAgentPopAdResponse * SOAP_FMAC4 soap_in_ns2__getAgentPopAdResponse(struct soap *soap, const char *tag, ns2__getAgentPopAdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getAgentPopAdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getAgentPopAdResponse, sizeof(ns2__getAgentPopAdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getAgentPopAdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getAgentPopAdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__getAgentPopAdResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getAgentPopAdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getAgentPopAdResponse, 0, sizeof(ns2__getAgentPopAdResponse), 0, soap_copy_ns2__getAgentPopAdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getAgentPopAdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getAgentPopAdResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getAgentPopAdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getAgentPopAdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getAgentPopAdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getAgentPopAdResponse * SOAP_FMAC4 soap_get_ns2__getAgentPopAdResponse(struct soap *soap, ns2__getAgentPopAdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getAgentPopAdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getAgentPopAdResponse * SOAP_FMAC2 soap_instantiate_ns2__getAgentPopAdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getAgentPopAdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getAgentPopAdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAgentPopAdResponse);
		if (size)
			*size = sizeof(ns2__getAgentPopAdResponse);
		((ns2__getAgentPopAdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAgentPopAdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getAgentPopAdResponse);
		for (int i = 0; i < n; i++)
			((ns2__getAgentPopAdResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getAgentPopAdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getAgentPopAdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getAgentPopAdResponse %p -> %p\n", q, p));
	*(ns2__getAgentPopAdResponse*)p = *(ns2__getAgentPopAdResponse*)q;
}

void ns2__getAgentPopAd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getAgentPopAd::uid = NULL;
	this->ns2__getAgentPopAd::msgid = NULL;
	/* transient soap skipped */
}

void ns2__getAgentPopAd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getAgentPopAd::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getAgentPopAd::msgid);
	/* transient soap skipped */
}

int ns2__getAgentPopAd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getAgentPopAd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getAgentPopAd(struct soap *soap, const char *tag, int id, const ns2__getAgentPopAd *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getAgentPopAd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getAgentPopAd::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msgid", -1, &(a->ns2__getAgentPopAd::msgid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getAgentPopAd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getAgentPopAd(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getAgentPopAd * SOAP_FMAC4 soap_in_ns2__getAgentPopAd(struct soap *soap, const char *tag, ns2__getAgentPopAd *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getAgentPopAd *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getAgentPopAd, sizeof(ns2__getAgentPopAd), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getAgentPopAd)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getAgentPopAd *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_msgid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getAgentPopAd::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_msgid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msgid", &(a->ns2__getAgentPopAd::msgid), "xsd:string"))
				{	soap_flag_msgid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getAgentPopAd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getAgentPopAd, 0, sizeof(ns2__getAgentPopAd), 0, soap_copy_ns2__getAgentPopAd);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getAgentPopAd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getAgentPopAd);
	if (this->soap_out(soap, tag?tag:"ns2:getAgentPopAd", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getAgentPopAd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getAgentPopAd(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getAgentPopAd * SOAP_FMAC4 soap_get_ns2__getAgentPopAd(struct soap *soap, ns2__getAgentPopAd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getAgentPopAd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getAgentPopAd * SOAP_FMAC2 soap_instantiate_ns2__getAgentPopAd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getAgentPopAd(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getAgentPopAd, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAgentPopAd);
		if (size)
			*size = sizeof(ns2__getAgentPopAd);
		((ns2__getAgentPopAd*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAgentPopAd[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getAgentPopAd);
		for (int i = 0; i < n; i++)
			((ns2__getAgentPopAd*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getAgentPopAd*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getAgentPopAd(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getAgentPopAd %p -> %p\n", q, p));
	*(ns2__getAgentPopAd*)p = *(ns2__getAgentPopAd*)q;
}

void ns2__getSearchCarsInfNewResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchCarsInfNewResponse::return_);
	/* transient soap skipped */
}

void ns2__getSearchCarsInfNewResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchCarsInfNewResponse::return_);
	/* transient soap skipped */
}

int ns2__getSearchCarsInfNewResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchCarsInfNewResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchCarsInfNewResponse(struct soap *soap, const char *tag, int id, const ns2__getSearchCarsInfNewResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchCarsInfNewResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getSearchCarsInfNewResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchCarsInfNewResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchCarsInfNewResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchCarsInfNewResponse * SOAP_FMAC4 soap_in_ns2__getSearchCarsInfNewResponse(struct soap *soap, const char *tag, ns2__getSearchCarsInfNewResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchCarsInfNewResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchCarsInfNewResponse, sizeof(ns2__getSearchCarsInfNewResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchCarsInfNewResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchCarsInfNewResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getSearchCarsInfNewResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchCarsInfNewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchCarsInfNewResponse, 0, sizeof(ns2__getSearchCarsInfNewResponse), 0, soap_copy_ns2__getSearchCarsInfNewResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getSearchCarsInfNewResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchCarsInfNewResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchCarsInfNewResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchCarsInfNewResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchCarsInfNewResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchCarsInfNewResponse * SOAP_FMAC4 soap_get_ns2__getSearchCarsInfNewResponse(struct soap *soap, ns2__getSearchCarsInfNewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchCarsInfNewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchCarsInfNewResponse * SOAP_FMAC2 soap_instantiate_ns2__getSearchCarsInfNewResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchCarsInfNewResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchCarsInfNewResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchCarsInfNewResponse);
		if (size)
			*size = sizeof(ns2__getSearchCarsInfNewResponse);
		((ns2__getSearchCarsInfNewResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchCarsInfNewResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchCarsInfNewResponse);
		for (int i = 0; i < n; i++)
			((ns2__getSearchCarsInfNewResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchCarsInfNewResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchCarsInfNewResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchCarsInfNewResponse %p -> %p\n", q, p));
	*(ns2__getSearchCarsInfNewResponse*)p = *(ns2__getSearchCarsInfNewResponse*)q;
}

void ns2__getSearchCarsInfNew::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getSearchCarsInfNew::uid = NULL;
	this->ns2__getSearchCarsInfNew::input = NULL;
	soap_default_int(soap, &this->ns2__getSearchCarsInfNew::record);
	soap_default_int(soap, &this->ns2__getSearchCarsInfNew::curpage);
	/* transient soap skipped */
}

void ns2__getSearchCarsInfNew::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchCarsInfNew::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchCarsInfNew::input);
	/* transient soap skipped */
}

int ns2__getSearchCarsInfNew::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchCarsInfNew(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchCarsInfNew(struct soap *soap, const char *tag, int id, const ns2__getSearchCarsInfNew *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchCarsInfNew), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getSearchCarsInfNew::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__getSearchCarsInfNew::input), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getSearchCarsInfNew::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getSearchCarsInfNew::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchCarsInfNew::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchCarsInfNew(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchCarsInfNew * SOAP_FMAC4 soap_in_ns2__getSearchCarsInfNew(struct soap *soap, const char *tag, ns2__getSearchCarsInfNew *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchCarsInfNew *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchCarsInfNew, sizeof(ns2__getSearchCarsInfNew), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchCarsInfNew)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchCarsInfNew *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getSearchCarsInfNew::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__getSearchCarsInfNew::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getSearchCarsInfNew::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getSearchCarsInfNew::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchCarsInfNew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchCarsInfNew, 0, sizeof(ns2__getSearchCarsInfNew), 0, soap_copy_ns2__getSearchCarsInfNew);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getSearchCarsInfNew::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchCarsInfNew);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchCarsInfNew", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchCarsInfNew::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchCarsInfNew(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchCarsInfNew * SOAP_FMAC4 soap_get_ns2__getSearchCarsInfNew(struct soap *soap, ns2__getSearchCarsInfNew *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchCarsInfNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchCarsInfNew * SOAP_FMAC2 soap_instantiate_ns2__getSearchCarsInfNew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchCarsInfNew(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchCarsInfNew, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchCarsInfNew);
		if (size)
			*size = sizeof(ns2__getSearchCarsInfNew);
		((ns2__getSearchCarsInfNew*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchCarsInfNew[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchCarsInfNew);
		for (int i = 0; i < n; i++)
			((ns2__getSearchCarsInfNew*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchCarsInfNew*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchCarsInfNew(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchCarsInfNew %p -> %p\n", q, p));
	*(ns2__getSearchCarsInfNew*)p = *(ns2__getSearchCarsInfNew*)q;
}

void ns2__delFavoriteSpecialLineResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__delFavoriteSpecialLineResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__delFavoriteSpecialLineResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__delFavoriteSpecialLineResponse::return_);
	/* transient soap skipped */
}

int ns2__delFavoriteSpecialLineResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__delFavoriteSpecialLineResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__delFavoriteSpecialLineResponse(struct soap *soap, const char *tag, int id, const ns2__delFavoriteSpecialLineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__delFavoriteSpecialLineResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__delFavoriteSpecialLineResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__delFavoriteSpecialLineResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__delFavoriteSpecialLineResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__delFavoriteSpecialLineResponse * SOAP_FMAC4 soap_in_ns2__delFavoriteSpecialLineResponse(struct soap *soap, const char *tag, ns2__delFavoriteSpecialLineResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__delFavoriteSpecialLineResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__delFavoriteSpecialLineResponse, sizeof(ns2__delFavoriteSpecialLineResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__delFavoriteSpecialLineResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__delFavoriteSpecialLineResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__delFavoriteSpecialLineResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__delFavoriteSpecialLineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__delFavoriteSpecialLineResponse, 0, sizeof(ns2__delFavoriteSpecialLineResponse), 0, soap_copy_ns2__delFavoriteSpecialLineResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__delFavoriteSpecialLineResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__delFavoriteSpecialLineResponse);
	if (this->soap_out(soap, tag?tag:"ns2:delFavoriteSpecialLineResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__delFavoriteSpecialLineResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__delFavoriteSpecialLineResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__delFavoriteSpecialLineResponse * SOAP_FMAC4 soap_get_ns2__delFavoriteSpecialLineResponse(struct soap *soap, ns2__delFavoriteSpecialLineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__delFavoriteSpecialLineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__delFavoriteSpecialLineResponse * SOAP_FMAC2 soap_instantiate_ns2__delFavoriteSpecialLineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__delFavoriteSpecialLineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__delFavoriteSpecialLineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__delFavoriteSpecialLineResponse);
		if (size)
			*size = sizeof(ns2__delFavoriteSpecialLineResponse);
		((ns2__delFavoriteSpecialLineResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__delFavoriteSpecialLineResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__delFavoriteSpecialLineResponse);
		for (int i = 0; i < n; i++)
			((ns2__delFavoriteSpecialLineResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__delFavoriteSpecialLineResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__delFavoriteSpecialLineResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__delFavoriteSpecialLineResponse %p -> %p\n", q, p));
	*(ns2__delFavoriteSpecialLineResponse*)p = *(ns2__delFavoriteSpecialLineResponse*)q;
}

void ns2__delFavoriteSpecialLine::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__delFavoriteSpecialLine::uid = NULL;
	this->ns2__delFavoriteSpecialLine::recordID = NULL;
	/* transient soap skipped */
}

void ns2__delFavoriteSpecialLine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__delFavoriteSpecialLine::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__delFavoriteSpecialLine::recordID);
	/* transient soap skipped */
}

int ns2__delFavoriteSpecialLine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__delFavoriteSpecialLine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__delFavoriteSpecialLine(struct soap *soap, const char *tag, int id, const ns2__delFavoriteSpecialLine *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__delFavoriteSpecialLine), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__delFavoriteSpecialLine::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "recordID", -1, &(a->ns2__delFavoriteSpecialLine::recordID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__delFavoriteSpecialLine::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__delFavoriteSpecialLine(soap, tag, this, type);
}

SOAP_FMAC3 ns2__delFavoriteSpecialLine * SOAP_FMAC4 soap_in_ns2__delFavoriteSpecialLine(struct soap *soap, const char *tag, ns2__delFavoriteSpecialLine *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__delFavoriteSpecialLine *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__delFavoriteSpecialLine, sizeof(ns2__delFavoriteSpecialLine), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__delFavoriteSpecialLine)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__delFavoriteSpecialLine *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_recordID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__delFavoriteSpecialLine::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_recordID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "recordID", &(a->ns2__delFavoriteSpecialLine::recordID), "xsd:string"))
				{	soap_flag_recordID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__delFavoriteSpecialLine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__delFavoriteSpecialLine, 0, sizeof(ns2__delFavoriteSpecialLine), 0, soap_copy_ns2__delFavoriteSpecialLine);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__delFavoriteSpecialLine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__delFavoriteSpecialLine);
	if (this->soap_out(soap, tag?tag:"ns2:delFavoriteSpecialLine", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__delFavoriteSpecialLine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__delFavoriteSpecialLine(soap, this, tag, type);
}

SOAP_FMAC3 ns2__delFavoriteSpecialLine * SOAP_FMAC4 soap_get_ns2__delFavoriteSpecialLine(struct soap *soap, ns2__delFavoriteSpecialLine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__delFavoriteSpecialLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__delFavoriteSpecialLine * SOAP_FMAC2 soap_instantiate_ns2__delFavoriteSpecialLine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__delFavoriteSpecialLine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__delFavoriteSpecialLine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__delFavoriteSpecialLine);
		if (size)
			*size = sizeof(ns2__delFavoriteSpecialLine);
		((ns2__delFavoriteSpecialLine*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__delFavoriteSpecialLine[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__delFavoriteSpecialLine);
		for (int i = 0; i < n; i++)
			((ns2__delFavoriteSpecialLine*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__delFavoriteSpecialLine*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__delFavoriteSpecialLine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__delFavoriteSpecialLine %p -> %p\n", q, p));
	*(ns2__delFavoriteSpecialLine*)p = *(ns2__delFavoriteSpecialLine*)q;
}

void ns2__getNewGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getNewGoodsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getNewGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getNewGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getNewGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getNewGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNewGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getNewGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNewGoodsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getNewGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getNewGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getNewGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getNewGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__getNewGoodsInfResponse(struct soap *soap, const char *tag, ns2__getNewGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getNewGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNewGoodsInfResponse, sizeof(ns2__getNewGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getNewGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getNewGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getNewGoodsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getNewGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNewGoodsInfResponse, 0, sizeof(ns2__getNewGoodsInfResponse), 0, soap_copy_ns2__getNewGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getNewGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getNewGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getNewGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getNewGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getNewGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getNewGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__getNewGoodsInfResponse(struct soap *soap, ns2__getNewGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getNewGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getNewGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getNewGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNewGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNewGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__getNewGoodsInfResponse);
		((ns2__getNewGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getNewGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getNewGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getNewGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNewGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getNewGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__getNewGoodsInfResponse*)p = *(ns2__getNewGoodsInfResponse*)q;
}

void ns2__getNewGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getNewGoodsInf::uid = NULL;
	soap_default_int(soap, &this->ns2__getNewGoodsInf::record);
	soap_default_int(soap, &this->ns2__getNewGoodsInf::curpage);
	/* transient soap skipped */
}

void ns2__getNewGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getNewGoodsInf::uid);
	/* transient soap skipped */
}

int ns2__getNewGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getNewGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNewGoodsInf(struct soap *soap, const char *tag, int id, const ns2__getNewGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNewGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getNewGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getNewGoodsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getNewGoodsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getNewGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getNewGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getNewGoodsInf * SOAP_FMAC4 soap_in_ns2__getNewGoodsInf(struct soap *soap, const char *tag, ns2__getNewGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getNewGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNewGoodsInf, sizeof(ns2__getNewGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getNewGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getNewGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getNewGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getNewGoodsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getNewGoodsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getNewGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNewGoodsInf, 0, sizeof(ns2__getNewGoodsInf), 0, soap_copy_ns2__getNewGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getNewGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getNewGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getNewGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getNewGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getNewGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getNewGoodsInf * SOAP_FMAC4 soap_get_ns2__getNewGoodsInf(struct soap *soap, ns2__getNewGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getNewGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getNewGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__getNewGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNewGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNewGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewGoodsInf);
		if (size)
			*size = sizeof(ns2__getNewGoodsInf);
		((ns2__getNewGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getNewGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__getNewGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getNewGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNewGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getNewGoodsInf %p -> %p\n", q, p));
	*(ns2__getNewGoodsInf*)p = *(ns2__getNewGoodsInf*)q;
}

void ns2__getMySpecialLineInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getMySpecialLineInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getMySpecialLineInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getMySpecialLineInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getMySpecialLineInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMySpecialLineInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMySpecialLineInfResponse(struct soap *soap, const char *tag, int id, const ns2__getMySpecialLineInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMySpecialLineInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getMySpecialLineInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getMySpecialLineInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getMySpecialLineInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMySpecialLineInfResponse * SOAP_FMAC4 soap_in_ns2__getMySpecialLineInfResponse(struct soap *soap, const char *tag, ns2__getMySpecialLineInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMySpecialLineInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMySpecialLineInfResponse, sizeof(ns2__getMySpecialLineInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getMySpecialLineInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getMySpecialLineInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getMySpecialLineInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMySpecialLineInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMySpecialLineInfResponse, 0, sizeof(ns2__getMySpecialLineInfResponse), 0, soap_copy_ns2__getMySpecialLineInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getMySpecialLineInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getMySpecialLineInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getMySpecialLineInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMySpecialLineInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMySpecialLineInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMySpecialLineInfResponse * SOAP_FMAC4 soap_get_ns2__getMySpecialLineInfResponse(struct soap *soap, ns2__getMySpecialLineInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMySpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getMySpecialLineInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getMySpecialLineInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMySpecialLineInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMySpecialLineInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMySpecialLineInfResponse);
		if (size)
			*size = sizeof(ns2__getMySpecialLineInfResponse);
		((ns2__getMySpecialLineInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMySpecialLineInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getMySpecialLineInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getMySpecialLineInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getMySpecialLineInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMySpecialLineInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getMySpecialLineInfResponse %p -> %p\n", q, p));
	*(ns2__getMySpecialLineInfResponse*)p = *(ns2__getMySpecialLineInfResponse*)q;
}

void ns2__getMySpecialLineInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getMySpecialLineInf::uid = NULL;
	soap_default_int(soap, &this->ns2__getMySpecialLineInf::record);
	soap_default_int(soap, &this->ns2__getMySpecialLineInf::curpage);
	/* transient soap skipped */
}

void ns2__getMySpecialLineInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getMySpecialLineInf::uid);
	/* transient soap skipped */
}

int ns2__getMySpecialLineInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMySpecialLineInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMySpecialLineInf(struct soap *soap, const char *tag, int id, const ns2__getMySpecialLineInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMySpecialLineInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getMySpecialLineInf::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getMySpecialLineInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getMySpecialLineInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getMySpecialLineInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getMySpecialLineInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMySpecialLineInf * SOAP_FMAC4 soap_in_ns2__getMySpecialLineInf(struct soap *soap, const char *tag, ns2__getMySpecialLineInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMySpecialLineInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMySpecialLineInf, sizeof(ns2__getMySpecialLineInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getMySpecialLineInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getMySpecialLineInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getMySpecialLineInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getMySpecialLineInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getMySpecialLineInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMySpecialLineInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMySpecialLineInf, 0, sizeof(ns2__getMySpecialLineInf), 0, soap_copy_ns2__getMySpecialLineInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getMySpecialLineInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getMySpecialLineInf);
	if (this->soap_out(soap, tag?tag:"ns2:getMySpecialLineInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMySpecialLineInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMySpecialLineInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMySpecialLineInf * SOAP_FMAC4 soap_get_ns2__getMySpecialLineInf(struct soap *soap, ns2__getMySpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMySpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getMySpecialLineInf * SOAP_FMAC2 soap_instantiate_ns2__getMySpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMySpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMySpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMySpecialLineInf);
		if (size)
			*size = sizeof(ns2__getMySpecialLineInf);
		((ns2__getMySpecialLineInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMySpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getMySpecialLineInf);
		for (int i = 0; i < n; i++)
			((ns2__getMySpecialLineInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getMySpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMySpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getMySpecialLineInf %p -> %p\n", q, p));
	*(ns2__getMySpecialLineInf*)p = *(ns2__getMySpecialLineInf*)q;
}

void ns2__setPubSpecialLineInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setPubSpecialLineInfResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__setPubSpecialLineInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubSpecialLineInfResponse::return_);
	/* transient soap skipped */
}

int ns2__setPubSpecialLineInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setPubSpecialLineInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setPubSpecialLineInfResponse(struct soap *soap, const char *tag, int id, const ns2__setPubSpecialLineInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setPubSpecialLineInfResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__setPubSpecialLineInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setPubSpecialLineInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setPubSpecialLineInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setPubSpecialLineInfResponse * SOAP_FMAC4 soap_in_ns2__setPubSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__setPubSpecialLineInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setPubSpecialLineInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setPubSpecialLineInfResponse, sizeof(ns2__setPubSpecialLineInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setPubSpecialLineInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setPubSpecialLineInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__setPubSpecialLineInfResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setPubSpecialLineInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setPubSpecialLineInfResponse, 0, sizeof(ns2__setPubSpecialLineInfResponse), 0, soap_copy_ns2__setPubSpecialLineInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setPubSpecialLineInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setPubSpecialLineInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:setPubSpecialLineInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setPubSpecialLineInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setPubSpecialLineInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setPubSpecialLineInfResponse * SOAP_FMAC4 soap_get_ns2__setPubSpecialLineInfResponse(struct soap *soap, ns2__setPubSpecialLineInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setPubSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setPubSpecialLineInfResponse * SOAP_FMAC2 soap_instantiate_ns2__setPubSpecialLineInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setPubSpecialLineInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setPubSpecialLineInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubSpecialLineInfResponse);
		if (size)
			*size = sizeof(ns2__setPubSpecialLineInfResponse);
		((ns2__setPubSpecialLineInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubSpecialLineInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setPubSpecialLineInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__setPubSpecialLineInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setPubSpecialLineInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setPubSpecialLineInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setPubSpecialLineInfResponse %p -> %p\n", q, p));
	*(ns2__setPubSpecialLineInfResponse*)p = *(ns2__setPubSpecialLineInfResponse*)q;
}

void ns2__setPubSpecialLineInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setPubSpecialLineInf::uid = NULL;
	this->ns2__setPubSpecialLineInf::input = NULL;
	/* transient soap skipped */
}

void ns2__setPubSpecialLineInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubSpecialLineInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubSpecialLineInf::input);
	/* transient soap skipped */
}

int ns2__setPubSpecialLineInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setPubSpecialLineInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setPubSpecialLineInf(struct soap *soap, const char *tag, int id, const ns2__setPubSpecialLineInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setPubSpecialLineInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__setPubSpecialLineInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__setPubSpecialLineInf::input), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setPubSpecialLineInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setPubSpecialLineInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setPubSpecialLineInf * SOAP_FMAC4 soap_in_ns2__setPubSpecialLineInf(struct soap *soap, const char *tag, ns2__setPubSpecialLineInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setPubSpecialLineInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setPubSpecialLineInf, sizeof(ns2__setPubSpecialLineInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setPubSpecialLineInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setPubSpecialLineInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__setPubSpecialLineInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__setPubSpecialLineInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setPubSpecialLineInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setPubSpecialLineInf, 0, sizeof(ns2__setPubSpecialLineInf), 0, soap_copy_ns2__setPubSpecialLineInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setPubSpecialLineInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setPubSpecialLineInf);
	if (this->soap_out(soap, tag?tag:"ns2:setPubSpecialLineInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setPubSpecialLineInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setPubSpecialLineInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setPubSpecialLineInf * SOAP_FMAC4 soap_get_ns2__setPubSpecialLineInf(struct soap *soap, ns2__setPubSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setPubSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setPubSpecialLineInf * SOAP_FMAC2 soap_instantiate_ns2__setPubSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setPubSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setPubSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubSpecialLineInf);
		if (size)
			*size = sizeof(ns2__setPubSpecialLineInf);
		((ns2__setPubSpecialLineInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setPubSpecialLineInf);
		for (int i = 0; i < n; i++)
			((ns2__setPubSpecialLineInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setPubSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setPubSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setPubSpecialLineInf %p -> %p\n", q, p));
	*(ns2__setPubSpecialLineInf*)p = *(ns2__setPubSpecialLineInf*)q;
}

void ns2__delCarsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__delCarsInfResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__delCarsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__delCarsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__delCarsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__delCarsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__delCarsInfResponse(struct soap *soap, const char *tag, int id, const ns2__delCarsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__delCarsInfResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__delCarsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__delCarsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__delCarsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__delCarsInfResponse * SOAP_FMAC4 soap_in_ns2__delCarsInfResponse(struct soap *soap, const char *tag, ns2__delCarsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__delCarsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__delCarsInfResponse, sizeof(ns2__delCarsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__delCarsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__delCarsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__delCarsInfResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__delCarsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__delCarsInfResponse, 0, sizeof(ns2__delCarsInfResponse), 0, soap_copy_ns2__delCarsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__delCarsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__delCarsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:delCarsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__delCarsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__delCarsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__delCarsInfResponse * SOAP_FMAC4 soap_get_ns2__delCarsInfResponse(struct soap *soap, ns2__delCarsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__delCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__delCarsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__delCarsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__delCarsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__delCarsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__delCarsInfResponse);
		if (size)
			*size = sizeof(ns2__delCarsInfResponse);
		((ns2__delCarsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__delCarsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__delCarsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__delCarsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__delCarsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__delCarsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__delCarsInfResponse %p -> %p\n", q, p));
	*(ns2__delCarsInfResponse*)p = *(ns2__delCarsInfResponse*)q;
}

void ns2__delCarsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__delCarsInf::uid = NULL;
	this->ns2__delCarsInf::recordID = NULL;
	/* transient soap skipped */
}

void ns2__delCarsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__delCarsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__delCarsInf::recordID);
	/* transient soap skipped */
}

int ns2__delCarsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__delCarsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__delCarsInf(struct soap *soap, const char *tag, int id, const ns2__delCarsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__delCarsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__delCarsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "recordID", -1, &(a->ns2__delCarsInf::recordID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__delCarsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__delCarsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__delCarsInf * SOAP_FMAC4 soap_in_ns2__delCarsInf(struct soap *soap, const char *tag, ns2__delCarsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__delCarsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__delCarsInf, sizeof(ns2__delCarsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__delCarsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__delCarsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_recordID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__delCarsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_recordID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "recordID", &(a->ns2__delCarsInf::recordID), "xsd:string"))
				{	soap_flag_recordID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__delCarsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__delCarsInf, 0, sizeof(ns2__delCarsInf), 0, soap_copy_ns2__delCarsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__delCarsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__delCarsInf);
	if (this->soap_out(soap, tag?tag:"ns2:delCarsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__delCarsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__delCarsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__delCarsInf * SOAP_FMAC4 soap_get_ns2__delCarsInf(struct soap *soap, ns2__delCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__delCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__delCarsInf * SOAP_FMAC2 soap_instantiate_ns2__delCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__delCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__delCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__delCarsInf);
		if (size)
			*size = sizeof(ns2__delCarsInf);
		((ns2__delCarsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__delCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__delCarsInf);
		for (int i = 0; i < n; i++)
			((ns2__delCarsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__delCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__delCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__delCarsInf %p -> %p\n", q, p));
	*(ns2__delCarsInf*)p = *(ns2__delCarsInf*)q;
}

void ns2__getPersisCarsInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getPersisCarsInfoResponse::return_);
	/* transient soap skipped */
}

void ns2__getPersisCarsInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getPersisCarsInfoResponse::return_);
	/* transient soap skipped */
}

int ns2__getPersisCarsInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getPersisCarsInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getPersisCarsInfoResponse(struct soap *soap, const char *tag, int id, const ns2__getPersisCarsInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getPersisCarsInfoResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getPersisCarsInfoResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getPersisCarsInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getPersisCarsInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getPersisCarsInfoResponse * SOAP_FMAC4 soap_in_ns2__getPersisCarsInfoResponse(struct soap *soap, const char *tag, ns2__getPersisCarsInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getPersisCarsInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getPersisCarsInfoResponse, sizeof(ns2__getPersisCarsInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getPersisCarsInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getPersisCarsInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getPersisCarsInfoResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getPersisCarsInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getPersisCarsInfoResponse, 0, sizeof(ns2__getPersisCarsInfoResponse), 0, soap_copy_ns2__getPersisCarsInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getPersisCarsInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getPersisCarsInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getPersisCarsInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getPersisCarsInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getPersisCarsInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getPersisCarsInfoResponse * SOAP_FMAC4 soap_get_ns2__getPersisCarsInfoResponse(struct soap *soap, ns2__getPersisCarsInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getPersisCarsInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getPersisCarsInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__getPersisCarsInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getPersisCarsInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getPersisCarsInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getPersisCarsInfoResponse);
		if (size)
			*size = sizeof(ns2__getPersisCarsInfoResponse);
		((ns2__getPersisCarsInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getPersisCarsInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getPersisCarsInfoResponse);
		for (int i = 0; i < n; i++)
			((ns2__getPersisCarsInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getPersisCarsInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getPersisCarsInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getPersisCarsInfoResponse %p -> %p\n", q, p));
	*(ns2__getPersisCarsInfoResponse*)p = *(ns2__getPersisCarsInfoResponse*)q;
}

void ns2__getPersisCarsInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getPersisCarsInfo::uid = NULL;
	soap_default_int(soap, &this->ns2__getPersisCarsInfo::record);
	soap_default_int(soap, &this->ns2__getPersisCarsInfo::curpage);
	/* transient soap skipped */
}

void ns2__getPersisCarsInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getPersisCarsInfo::uid);
	/* transient soap skipped */
}

int ns2__getPersisCarsInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getPersisCarsInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getPersisCarsInfo(struct soap *soap, const char *tag, int id, const ns2__getPersisCarsInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getPersisCarsInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getPersisCarsInfo::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getPersisCarsInfo::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getPersisCarsInfo::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getPersisCarsInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getPersisCarsInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getPersisCarsInfo * SOAP_FMAC4 soap_in_ns2__getPersisCarsInfo(struct soap *soap, const char *tag, ns2__getPersisCarsInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getPersisCarsInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getPersisCarsInfo, sizeof(ns2__getPersisCarsInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getPersisCarsInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getPersisCarsInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getPersisCarsInfo::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getPersisCarsInfo::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getPersisCarsInfo::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getPersisCarsInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getPersisCarsInfo, 0, sizeof(ns2__getPersisCarsInfo), 0, soap_copy_ns2__getPersisCarsInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getPersisCarsInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getPersisCarsInfo);
	if (this->soap_out(soap, tag?tag:"ns2:getPersisCarsInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getPersisCarsInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getPersisCarsInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getPersisCarsInfo * SOAP_FMAC4 soap_get_ns2__getPersisCarsInfo(struct soap *soap, ns2__getPersisCarsInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getPersisCarsInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getPersisCarsInfo * SOAP_FMAC2 soap_instantiate_ns2__getPersisCarsInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getPersisCarsInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getPersisCarsInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getPersisCarsInfo);
		if (size)
			*size = sizeof(ns2__getPersisCarsInfo);
		((ns2__getPersisCarsInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getPersisCarsInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getPersisCarsInfo);
		for (int i = 0; i < n; i++)
			((ns2__getPersisCarsInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getPersisCarsInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getPersisCarsInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getPersisCarsInfo %p -> %p\n", q, p));
	*(ns2__getPersisCarsInfo*)p = *(ns2__getPersisCarsInfo*)q;
}

void ns2__browseZoneCarsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__browseZoneCarsResponse::return_);
	/* transient soap skipped */
}

void ns2__browseZoneCarsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__browseZoneCarsResponse::return_);
	/* transient soap skipped */
}

int ns2__browseZoneCarsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__browseZoneCarsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__browseZoneCarsResponse(struct soap *soap, const char *tag, int id, const ns2__browseZoneCarsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__browseZoneCarsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__browseZoneCarsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__browseZoneCarsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__browseZoneCarsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__browseZoneCarsResponse * SOAP_FMAC4 soap_in_ns2__browseZoneCarsResponse(struct soap *soap, const char *tag, ns2__browseZoneCarsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__browseZoneCarsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__browseZoneCarsResponse, sizeof(ns2__browseZoneCarsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__browseZoneCarsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__browseZoneCarsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__browseZoneCarsResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__browseZoneCarsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__browseZoneCarsResponse, 0, sizeof(ns2__browseZoneCarsResponse), 0, soap_copy_ns2__browseZoneCarsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__browseZoneCarsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__browseZoneCarsResponse);
	if (this->soap_out(soap, tag?tag:"ns2:browseZoneCarsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__browseZoneCarsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__browseZoneCarsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__browseZoneCarsResponse * SOAP_FMAC4 soap_get_ns2__browseZoneCarsResponse(struct soap *soap, ns2__browseZoneCarsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__browseZoneCarsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__browseZoneCarsResponse * SOAP_FMAC2 soap_instantiate_ns2__browseZoneCarsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__browseZoneCarsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__browseZoneCarsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__browseZoneCarsResponse);
		if (size)
			*size = sizeof(ns2__browseZoneCarsResponse);
		((ns2__browseZoneCarsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__browseZoneCarsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__browseZoneCarsResponse);
		for (int i = 0; i < n; i++)
			((ns2__browseZoneCarsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__browseZoneCarsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__browseZoneCarsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__browseZoneCarsResponse %p -> %p\n", q, p));
	*(ns2__browseZoneCarsResponse*)p = *(ns2__browseZoneCarsResponse*)q;
}

void ns2__browseZoneCars::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__browseZoneCars::uid = NULL;
	soap_default_int(soap, &this->ns2__browseZoneCars::record);
	soap_default_int(soap, &this->ns2__browseZoneCars::curpage);
	/* transient soap skipped */
}

void ns2__browseZoneCars::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__browseZoneCars::uid);
	/* transient soap skipped */
}

int ns2__browseZoneCars::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__browseZoneCars(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__browseZoneCars(struct soap *soap, const char *tag, int id, const ns2__browseZoneCars *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__browseZoneCars), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__browseZoneCars::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__browseZoneCars::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__browseZoneCars::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__browseZoneCars::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__browseZoneCars(soap, tag, this, type);
}

SOAP_FMAC3 ns2__browseZoneCars * SOAP_FMAC4 soap_in_ns2__browseZoneCars(struct soap *soap, const char *tag, ns2__browseZoneCars *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__browseZoneCars *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__browseZoneCars, sizeof(ns2__browseZoneCars), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__browseZoneCars)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__browseZoneCars *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__browseZoneCars::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__browseZoneCars::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__browseZoneCars::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__browseZoneCars *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__browseZoneCars, 0, sizeof(ns2__browseZoneCars), 0, soap_copy_ns2__browseZoneCars);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__browseZoneCars::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__browseZoneCars);
	if (this->soap_out(soap, tag?tag:"ns2:browseZoneCars", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__browseZoneCars::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__browseZoneCars(soap, this, tag, type);
}

SOAP_FMAC3 ns2__browseZoneCars * SOAP_FMAC4 soap_get_ns2__browseZoneCars(struct soap *soap, ns2__browseZoneCars *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__browseZoneCars(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__browseZoneCars * SOAP_FMAC2 soap_instantiate_ns2__browseZoneCars(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__browseZoneCars(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__browseZoneCars, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__browseZoneCars);
		if (size)
			*size = sizeof(ns2__browseZoneCars);
		((ns2__browseZoneCars*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__browseZoneCars[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__browseZoneCars);
		for (int i = 0; i < n; i++)
			((ns2__browseZoneCars*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__browseZoneCars*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__browseZoneCars(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__browseZoneCars %p -> %p\n", q, p));
	*(ns2__browseZoneCars*)p = *(ns2__browseZoneCars*)q;
}

void ns2__placeOrderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__placeOrderResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__placeOrderResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__placeOrderResponse::return_);
	/* transient soap skipped */
}

int ns2__placeOrderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__placeOrderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__placeOrderResponse(struct soap *soap, const char *tag, int id, const ns2__placeOrderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__placeOrderResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__placeOrderResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__placeOrderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__placeOrderResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__placeOrderResponse * SOAP_FMAC4 soap_in_ns2__placeOrderResponse(struct soap *soap, const char *tag, ns2__placeOrderResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__placeOrderResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__placeOrderResponse, sizeof(ns2__placeOrderResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__placeOrderResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__placeOrderResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__placeOrderResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__placeOrderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__placeOrderResponse, 0, sizeof(ns2__placeOrderResponse), 0, soap_copy_ns2__placeOrderResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__placeOrderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__placeOrderResponse);
	if (this->soap_out(soap, tag?tag:"ns2:placeOrderResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__placeOrderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__placeOrderResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__placeOrderResponse * SOAP_FMAC4 soap_get_ns2__placeOrderResponse(struct soap *soap, ns2__placeOrderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__placeOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__placeOrderResponse * SOAP_FMAC2 soap_instantiate_ns2__placeOrderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__placeOrderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__placeOrderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__placeOrderResponse);
		if (size)
			*size = sizeof(ns2__placeOrderResponse);
		((ns2__placeOrderResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__placeOrderResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__placeOrderResponse);
		for (int i = 0; i < n; i++)
			((ns2__placeOrderResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__placeOrderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__placeOrderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__placeOrderResponse %p -> %p\n", q, p));
	*(ns2__placeOrderResponse*)p = *(ns2__placeOrderResponse*)q;
}

void ns2__placeOrder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__placeOrder::uid = NULL;
	this->ns2__placeOrder::infID = NULL;
	/* transient soap skipped */
}

void ns2__placeOrder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__placeOrder::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__placeOrder::infID);
	/* transient soap skipped */
}

int ns2__placeOrder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__placeOrder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__placeOrder(struct soap *soap, const char *tag, int id, const ns2__placeOrder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__placeOrder), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__placeOrder::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "infID", -1, &(a->ns2__placeOrder::infID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__placeOrder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__placeOrder(soap, tag, this, type);
}

SOAP_FMAC3 ns2__placeOrder * SOAP_FMAC4 soap_in_ns2__placeOrder(struct soap *soap, const char *tag, ns2__placeOrder *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__placeOrder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__placeOrder, sizeof(ns2__placeOrder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__placeOrder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__placeOrder *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_infID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__placeOrder::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_infID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "infID", &(a->ns2__placeOrder::infID), "xsd:string"))
				{	soap_flag_infID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__placeOrder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__placeOrder, 0, sizeof(ns2__placeOrder), 0, soap_copy_ns2__placeOrder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__placeOrder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__placeOrder);
	if (this->soap_out(soap, tag?tag:"ns2:placeOrder", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__placeOrder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__placeOrder(soap, this, tag, type);
}

SOAP_FMAC3 ns2__placeOrder * SOAP_FMAC4 soap_get_ns2__placeOrder(struct soap *soap, ns2__placeOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__placeOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__placeOrder * SOAP_FMAC2 soap_instantiate_ns2__placeOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__placeOrder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__placeOrder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__placeOrder);
		if (size)
			*size = sizeof(ns2__placeOrder);
		((ns2__placeOrder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__placeOrder[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__placeOrder);
		for (int i = 0; i < n; i++)
			((ns2__placeOrder*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__placeOrder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__placeOrder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__placeOrder %p -> %p\n", q, p));
	*(ns2__placeOrder*)p = *(ns2__placeOrder*)q;
}

void ns2__getPersisGoodsInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getPersisGoodsInfoResponse::return_);
	/* transient soap skipped */
}

void ns2__getPersisGoodsInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getPersisGoodsInfoResponse::return_);
	/* transient soap skipped */
}

int ns2__getPersisGoodsInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getPersisGoodsInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getPersisGoodsInfoResponse(struct soap *soap, const char *tag, int id, const ns2__getPersisGoodsInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getPersisGoodsInfoResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getPersisGoodsInfoResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getPersisGoodsInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getPersisGoodsInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getPersisGoodsInfoResponse * SOAP_FMAC4 soap_in_ns2__getPersisGoodsInfoResponse(struct soap *soap, const char *tag, ns2__getPersisGoodsInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getPersisGoodsInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getPersisGoodsInfoResponse, sizeof(ns2__getPersisGoodsInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getPersisGoodsInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getPersisGoodsInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getPersisGoodsInfoResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getPersisGoodsInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getPersisGoodsInfoResponse, 0, sizeof(ns2__getPersisGoodsInfoResponse), 0, soap_copy_ns2__getPersisGoodsInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getPersisGoodsInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getPersisGoodsInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getPersisGoodsInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getPersisGoodsInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getPersisGoodsInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getPersisGoodsInfoResponse * SOAP_FMAC4 soap_get_ns2__getPersisGoodsInfoResponse(struct soap *soap, ns2__getPersisGoodsInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getPersisGoodsInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getPersisGoodsInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__getPersisGoodsInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getPersisGoodsInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getPersisGoodsInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getPersisGoodsInfoResponse);
		if (size)
			*size = sizeof(ns2__getPersisGoodsInfoResponse);
		((ns2__getPersisGoodsInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getPersisGoodsInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getPersisGoodsInfoResponse);
		for (int i = 0; i < n; i++)
			((ns2__getPersisGoodsInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getPersisGoodsInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getPersisGoodsInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getPersisGoodsInfoResponse %p -> %p\n", q, p));
	*(ns2__getPersisGoodsInfoResponse*)p = *(ns2__getPersisGoodsInfoResponse*)q;
}

void ns2__getPersisGoodsInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getPersisGoodsInfo::uid = NULL;
	soap_default_int(soap, &this->ns2__getPersisGoodsInfo::record);
	soap_default_int(soap, &this->ns2__getPersisGoodsInfo::curpage);
	/* transient soap skipped */
}

void ns2__getPersisGoodsInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getPersisGoodsInfo::uid);
	/* transient soap skipped */
}

int ns2__getPersisGoodsInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getPersisGoodsInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getPersisGoodsInfo(struct soap *soap, const char *tag, int id, const ns2__getPersisGoodsInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getPersisGoodsInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getPersisGoodsInfo::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getPersisGoodsInfo::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getPersisGoodsInfo::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getPersisGoodsInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getPersisGoodsInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getPersisGoodsInfo * SOAP_FMAC4 soap_in_ns2__getPersisGoodsInfo(struct soap *soap, const char *tag, ns2__getPersisGoodsInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getPersisGoodsInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getPersisGoodsInfo, sizeof(ns2__getPersisGoodsInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getPersisGoodsInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getPersisGoodsInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getPersisGoodsInfo::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getPersisGoodsInfo::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getPersisGoodsInfo::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getPersisGoodsInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getPersisGoodsInfo, 0, sizeof(ns2__getPersisGoodsInfo), 0, soap_copy_ns2__getPersisGoodsInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getPersisGoodsInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getPersisGoodsInfo);
	if (this->soap_out(soap, tag?tag:"ns2:getPersisGoodsInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getPersisGoodsInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getPersisGoodsInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getPersisGoodsInfo * SOAP_FMAC4 soap_get_ns2__getPersisGoodsInfo(struct soap *soap, ns2__getPersisGoodsInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getPersisGoodsInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getPersisGoodsInfo * SOAP_FMAC2 soap_instantiate_ns2__getPersisGoodsInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getPersisGoodsInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getPersisGoodsInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getPersisGoodsInfo);
		if (size)
			*size = sizeof(ns2__getPersisGoodsInfo);
		((ns2__getPersisGoodsInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getPersisGoodsInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getPersisGoodsInfo);
		for (int i = 0; i < n; i++)
			((ns2__getPersisGoodsInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getPersisGoodsInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getPersisGoodsInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getPersisGoodsInfo %p -> %p\n", q, p));
	*(ns2__getPersisGoodsInfo*)p = *(ns2__getPersisGoodsInfo*)q;
}

void ns2__usrLoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__usrLoginResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__usrLoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__usrLoginResponse::return_);
	/* transient soap skipped */
}

int ns2__usrLoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__usrLoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__usrLoginResponse(struct soap *soap, const char *tag, int id, const ns2__usrLoginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__usrLoginResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__usrLoginResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__usrLoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__usrLoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__usrLoginResponse * SOAP_FMAC4 soap_in_ns2__usrLoginResponse(struct soap *soap, const char *tag, ns2__usrLoginResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__usrLoginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__usrLoginResponse, sizeof(ns2__usrLoginResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__usrLoginResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__usrLoginResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__usrLoginResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__usrLoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__usrLoginResponse, 0, sizeof(ns2__usrLoginResponse), 0, soap_copy_ns2__usrLoginResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__usrLoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__usrLoginResponse);
	if (this->soap_out(soap, tag?tag:"ns2:usrLoginResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__usrLoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__usrLoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__usrLoginResponse * SOAP_FMAC4 soap_get_ns2__usrLoginResponse(struct soap *soap, ns2__usrLoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__usrLoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__usrLoginResponse * SOAP_FMAC2 soap_instantiate_ns2__usrLoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__usrLoginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__usrLoginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__usrLoginResponse);
		if (size)
			*size = sizeof(ns2__usrLoginResponse);
		((ns2__usrLoginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__usrLoginResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__usrLoginResponse);
		for (int i = 0; i < n; i++)
			((ns2__usrLoginResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__usrLoginResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__usrLoginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__usrLoginResponse %p -> %p\n", q, p));
	*(ns2__usrLoginResponse*)p = *(ns2__usrLoginResponse*)q;
}

void ns2__usrLogin::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__usrLogin::username = NULL;
	this->ns2__usrLogin::pwd = NULL;
	/* transient soap skipped */
}

void ns2__usrLogin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__usrLogin::username);
	soap_serialize_PointerTostd__string(soap, &this->ns2__usrLogin::pwd);
	/* transient soap skipped */
}

int ns2__usrLogin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__usrLogin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__usrLogin(struct soap *soap, const char *tag, int id, const ns2__usrLogin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__usrLogin), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "username", -1, &(a->ns2__usrLogin::username), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "pwd", -1, &(a->ns2__usrLogin::pwd), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__usrLogin::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__usrLogin(soap, tag, this, type);
}

SOAP_FMAC3 ns2__usrLogin * SOAP_FMAC4 soap_in_ns2__usrLogin(struct soap *soap, const char *tag, ns2__usrLogin *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__usrLogin *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__usrLogin, sizeof(ns2__usrLogin), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__usrLogin)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__usrLogin *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_username1 = 1;
	size_t soap_flag_pwd1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "username", &(a->ns2__usrLogin::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_pwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "pwd", &(a->ns2__usrLogin::pwd), "xsd:string"))
				{	soap_flag_pwd1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__usrLogin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__usrLogin, 0, sizeof(ns2__usrLogin), 0, soap_copy_ns2__usrLogin);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__usrLogin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__usrLogin);
	if (this->soap_out(soap, tag?tag:"ns2:usrLogin", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__usrLogin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__usrLogin(soap, this, tag, type);
}

SOAP_FMAC3 ns2__usrLogin * SOAP_FMAC4 soap_get_ns2__usrLogin(struct soap *soap, ns2__usrLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__usrLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__usrLogin * SOAP_FMAC2 soap_instantiate_ns2__usrLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__usrLogin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__usrLogin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__usrLogin);
		if (size)
			*size = sizeof(ns2__usrLogin);
		((ns2__usrLogin*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__usrLogin[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__usrLogin);
		for (int i = 0; i < n; i++)
			((ns2__usrLogin*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__usrLogin*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__usrLogin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__usrLogin %p -> %p\n", q, p));
	*(ns2__usrLogin*)p = *(ns2__usrLogin*)q;
}

void ns2__delBulkGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__delBulkGoodsInfResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__delBulkGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__delBulkGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__delBulkGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__delBulkGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__delBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__delBulkGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__delBulkGoodsInfResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__delBulkGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__delBulkGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__delBulkGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__delBulkGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__delBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__delBulkGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__delBulkGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__delBulkGoodsInfResponse, sizeof(ns2__delBulkGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__delBulkGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__delBulkGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__delBulkGoodsInfResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__delBulkGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__delBulkGoodsInfResponse, 0, sizeof(ns2__delBulkGoodsInfResponse), 0, soap_copy_ns2__delBulkGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__delBulkGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__delBulkGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:delBulkGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__delBulkGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__delBulkGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__delBulkGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__delBulkGoodsInfResponse(struct soap *soap, ns2__delBulkGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__delBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__delBulkGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__delBulkGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__delBulkGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__delBulkGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__delBulkGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__delBulkGoodsInfResponse);
		((ns2__delBulkGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__delBulkGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__delBulkGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__delBulkGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__delBulkGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__delBulkGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__delBulkGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__delBulkGoodsInfResponse*)p = *(ns2__delBulkGoodsInfResponse*)q;
}

void ns2__delBulkGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__delBulkGoodsInf::uid = NULL;
	this->ns2__delBulkGoodsInf::recordID = NULL;
	/* transient soap skipped */
}

void ns2__delBulkGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__delBulkGoodsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__delBulkGoodsInf::recordID);
	/* transient soap skipped */
}

int ns2__delBulkGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__delBulkGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__delBulkGoodsInf(struct soap *soap, const char *tag, int id, const ns2__delBulkGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__delBulkGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__delBulkGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "recordID", -1, &(a->ns2__delBulkGoodsInf::recordID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__delBulkGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__delBulkGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__delBulkGoodsInf * SOAP_FMAC4 soap_in_ns2__delBulkGoodsInf(struct soap *soap, const char *tag, ns2__delBulkGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__delBulkGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__delBulkGoodsInf, sizeof(ns2__delBulkGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__delBulkGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__delBulkGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_recordID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__delBulkGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_recordID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "recordID", &(a->ns2__delBulkGoodsInf::recordID), "xsd:string"))
				{	soap_flag_recordID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__delBulkGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__delBulkGoodsInf, 0, sizeof(ns2__delBulkGoodsInf), 0, soap_copy_ns2__delBulkGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__delBulkGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__delBulkGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:delBulkGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__delBulkGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__delBulkGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__delBulkGoodsInf * SOAP_FMAC4 soap_get_ns2__delBulkGoodsInf(struct soap *soap, ns2__delBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__delBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__delBulkGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__delBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__delBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__delBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__delBulkGoodsInf);
		if (size)
			*size = sizeof(ns2__delBulkGoodsInf);
		((ns2__delBulkGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__delBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__delBulkGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__delBulkGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__delBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__delBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__delBulkGoodsInf %p -> %p\n", q, p));
	*(ns2__delBulkGoodsInf*)p = *(ns2__delBulkGoodsInf*)q;
}

void ns2__getClickSearchCarsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getClickSearchCarsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getClickSearchCarsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getClickSearchCarsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getClickSearchCarsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClickSearchCarsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClickSearchCarsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getClickSearchCarsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClickSearchCarsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getClickSearchCarsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getClickSearchCarsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getClickSearchCarsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClickSearchCarsInfResponse * SOAP_FMAC4 soap_in_ns2__getClickSearchCarsInfResponse(struct soap *soap, const char *tag, ns2__getClickSearchCarsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClickSearchCarsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClickSearchCarsInfResponse, sizeof(ns2__getClickSearchCarsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getClickSearchCarsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getClickSearchCarsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getClickSearchCarsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClickSearchCarsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClickSearchCarsInfResponse, 0, sizeof(ns2__getClickSearchCarsInfResponse), 0, soap_copy_ns2__getClickSearchCarsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getClickSearchCarsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getClickSearchCarsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getClickSearchCarsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClickSearchCarsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClickSearchCarsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClickSearchCarsInfResponse * SOAP_FMAC4 soap_get_ns2__getClickSearchCarsInfResponse(struct soap *soap, ns2__getClickSearchCarsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClickSearchCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getClickSearchCarsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getClickSearchCarsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClickSearchCarsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getClickSearchCarsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchCarsInfResponse);
		if (size)
			*size = sizeof(ns2__getClickSearchCarsInfResponse);
		((ns2__getClickSearchCarsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchCarsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getClickSearchCarsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getClickSearchCarsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getClickSearchCarsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getClickSearchCarsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getClickSearchCarsInfResponse %p -> %p\n", q, p));
	*(ns2__getClickSearchCarsInfResponse*)p = *(ns2__getClickSearchCarsInfResponse*)q;
}

void ns2__getClickSearchCarsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getClickSearchCarsInf::uid = NULL;
	this->ns2__getClickSearchCarsInf::input = NULL;
	soap_default_int(soap, &this->ns2__getClickSearchCarsInf::record);
	soap_default_int(soap, &this->ns2__getClickSearchCarsInf::curpage);
	/* transient soap skipped */
}

void ns2__getClickSearchCarsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClickSearchCarsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClickSearchCarsInf::input);
	/* transient soap skipped */
}

int ns2__getClickSearchCarsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClickSearchCarsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClickSearchCarsInf(struct soap *soap, const char *tag, int id, const ns2__getClickSearchCarsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClickSearchCarsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getClickSearchCarsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__getClickSearchCarsInf::input), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getClickSearchCarsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getClickSearchCarsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getClickSearchCarsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getClickSearchCarsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClickSearchCarsInf * SOAP_FMAC4 soap_in_ns2__getClickSearchCarsInf(struct soap *soap, const char *tag, ns2__getClickSearchCarsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClickSearchCarsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClickSearchCarsInf, sizeof(ns2__getClickSearchCarsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getClickSearchCarsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getClickSearchCarsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getClickSearchCarsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__getClickSearchCarsInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getClickSearchCarsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getClickSearchCarsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClickSearchCarsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClickSearchCarsInf, 0, sizeof(ns2__getClickSearchCarsInf), 0, soap_copy_ns2__getClickSearchCarsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getClickSearchCarsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getClickSearchCarsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getClickSearchCarsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClickSearchCarsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClickSearchCarsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClickSearchCarsInf * SOAP_FMAC4 soap_get_ns2__getClickSearchCarsInf(struct soap *soap, ns2__getClickSearchCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClickSearchCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getClickSearchCarsInf * SOAP_FMAC2 soap_instantiate_ns2__getClickSearchCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClickSearchCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getClickSearchCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchCarsInf);
		if (size)
			*size = sizeof(ns2__getClickSearchCarsInf);
		((ns2__getClickSearchCarsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getClickSearchCarsInf);
		for (int i = 0; i < n; i++)
			((ns2__getClickSearchCarsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getClickSearchCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getClickSearchCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getClickSearchCarsInf %p -> %p\n", q, p));
	*(ns2__getClickSearchCarsInf*)p = *(ns2__getClickSearchCarsInf*)q;
}

void ns2__setPubCarsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setPubCarsInfResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__setPubCarsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubCarsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__setPubCarsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setPubCarsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setPubCarsInfResponse(struct soap *soap, const char *tag, int id, const ns2__setPubCarsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setPubCarsInfResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__setPubCarsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setPubCarsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setPubCarsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setPubCarsInfResponse * SOAP_FMAC4 soap_in_ns2__setPubCarsInfResponse(struct soap *soap, const char *tag, ns2__setPubCarsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setPubCarsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setPubCarsInfResponse, sizeof(ns2__setPubCarsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setPubCarsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setPubCarsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__setPubCarsInfResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setPubCarsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setPubCarsInfResponse, 0, sizeof(ns2__setPubCarsInfResponse), 0, soap_copy_ns2__setPubCarsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setPubCarsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setPubCarsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:setPubCarsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setPubCarsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setPubCarsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setPubCarsInfResponse * SOAP_FMAC4 soap_get_ns2__setPubCarsInfResponse(struct soap *soap, ns2__setPubCarsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setPubCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setPubCarsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__setPubCarsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setPubCarsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setPubCarsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubCarsInfResponse);
		if (size)
			*size = sizeof(ns2__setPubCarsInfResponse);
		((ns2__setPubCarsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubCarsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setPubCarsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__setPubCarsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setPubCarsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setPubCarsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setPubCarsInfResponse %p -> %p\n", q, p));
	*(ns2__setPubCarsInfResponse*)p = *(ns2__setPubCarsInfResponse*)q;
}

void ns2__setPubCarsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setPubCarsInf::uid = NULL;
	this->ns2__setPubCarsInf::input = NULL;
	/* transient soap skipped */
}

void ns2__setPubCarsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubCarsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubCarsInf::input);
	/* transient soap skipped */
}

int ns2__setPubCarsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setPubCarsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setPubCarsInf(struct soap *soap, const char *tag, int id, const ns2__setPubCarsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setPubCarsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__setPubCarsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__setPubCarsInf::input), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setPubCarsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setPubCarsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setPubCarsInf * SOAP_FMAC4 soap_in_ns2__setPubCarsInf(struct soap *soap, const char *tag, ns2__setPubCarsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setPubCarsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setPubCarsInf, sizeof(ns2__setPubCarsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setPubCarsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setPubCarsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__setPubCarsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__setPubCarsInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setPubCarsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setPubCarsInf, 0, sizeof(ns2__setPubCarsInf), 0, soap_copy_ns2__setPubCarsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setPubCarsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setPubCarsInf);
	if (this->soap_out(soap, tag?tag:"ns2:setPubCarsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setPubCarsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setPubCarsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setPubCarsInf * SOAP_FMAC4 soap_get_ns2__setPubCarsInf(struct soap *soap, ns2__setPubCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setPubCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setPubCarsInf * SOAP_FMAC2 soap_instantiate_ns2__setPubCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setPubCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setPubCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubCarsInf);
		if (size)
			*size = sizeof(ns2__setPubCarsInf);
		((ns2__setPubCarsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setPubCarsInf);
		for (int i = 0; i < n; i++)
			((ns2__setPubCarsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setPubCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setPubCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setPubCarsInf %p -> %p\n", q, p));
	*(ns2__setPubCarsInf*)p = *(ns2__setPubCarsInf*)q;
}

void ns2__getSearchBulkGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchBulkGoodsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getSearchBulkGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchBulkGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getSearchBulkGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchBulkGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getSearchBulkGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getSearchBulkGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchBulkGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchBulkGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchBulkGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__getSearchBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__getSearchBulkGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchBulkGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse, sizeof(ns2__getSearchBulkGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchBulkGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getSearchBulkGoodsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchBulkGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse, 0, sizeof(ns2__getSearchBulkGoodsInfResponse), 0, soap_copy_ns2__getSearchBulkGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getSearchBulkGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchBulkGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchBulkGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchBulkGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchBulkGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__getSearchBulkGoodsInfResponse(struct soap *soap, ns2__getSearchBulkGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchBulkGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getSearchBulkGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchBulkGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchBulkGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__getSearchBulkGoodsInfResponse);
		((ns2__getSearchBulkGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchBulkGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchBulkGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getSearchBulkGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchBulkGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchBulkGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchBulkGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__getSearchBulkGoodsInfResponse*)p = *(ns2__getSearchBulkGoodsInfResponse*)q;
}

void ns2__getSearchBulkGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getSearchBulkGoodsInf::uid = NULL;
	this->ns2__getSearchBulkGoodsInf::input = NULL;
	soap_default_int(soap, &this->ns2__getSearchBulkGoodsInf::record);
	soap_default_int(soap, &this->ns2__getSearchBulkGoodsInf::curpage);
	/* transient soap skipped */
}

void ns2__getSearchBulkGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchBulkGoodsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchBulkGoodsInf::input);
	/* transient soap skipped */
}

int ns2__getSearchBulkGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchBulkGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchBulkGoodsInf(struct soap *soap, const char *tag, int id, const ns2__getSearchBulkGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchBulkGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getSearchBulkGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__getSearchBulkGoodsInf::input), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getSearchBulkGoodsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getSearchBulkGoodsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchBulkGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchBulkGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchBulkGoodsInf * SOAP_FMAC4 soap_in_ns2__getSearchBulkGoodsInf(struct soap *soap, const char *tag, ns2__getSearchBulkGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchBulkGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchBulkGoodsInf, sizeof(ns2__getSearchBulkGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchBulkGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchBulkGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getSearchBulkGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__getSearchBulkGoodsInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getSearchBulkGoodsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getSearchBulkGoodsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchBulkGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchBulkGoodsInf, 0, sizeof(ns2__getSearchBulkGoodsInf), 0, soap_copy_ns2__getSearchBulkGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getSearchBulkGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchBulkGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchBulkGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchBulkGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchBulkGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchBulkGoodsInf * SOAP_FMAC4 soap_get_ns2__getSearchBulkGoodsInf(struct soap *soap, ns2__getSearchBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchBulkGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__getSearchBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchBulkGoodsInf);
		if (size)
			*size = sizeof(ns2__getSearchBulkGoodsInf);
		((ns2__getSearchBulkGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchBulkGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__getSearchBulkGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchBulkGoodsInf %p -> %p\n", q, p));
	*(ns2__getSearchBulkGoodsInf*)p = *(ns2__getSearchBulkGoodsInf*)q;
}

void ns2__setPubBulkGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setPubBulkGoodsInfResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__setPubBulkGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubBulkGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__setPubBulkGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setPubBulkGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setPubBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__setPubBulkGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setPubBulkGoodsInfResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__setPubBulkGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setPubBulkGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setPubBulkGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setPubBulkGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__setPubBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__setPubBulkGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setPubBulkGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setPubBulkGoodsInfResponse, sizeof(ns2__setPubBulkGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setPubBulkGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setPubBulkGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__setPubBulkGoodsInfResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setPubBulkGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setPubBulkGoodsInfResponse, 0, sizeof(ns2__setPubBulkGoodsInfResponse), 0, soap_copy_ns2__setPubBulkGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setPubBulkGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setPubBulkGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:setPubBulkGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setPubBulkGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setPubBulkGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setPubBulkGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__setPubBulkGoodsInfResponse(struct soap *soap, ns2__setPubBulkGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setPubBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setPubBulkGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__setPubBulkGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setPubBulkGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setPubBulkGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubBulkGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__setPubBulkGoodsInfResponse);
		((ns2__setPubBulkGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubBulkGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setPubBulkGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__setPubBulkGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setPubBulkGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setPubBulkGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setPubBulkGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__setPubBulkGoodsInfResponse*)p = *(ns2__setPubBulkGoodsInfResponse*)q;
}

void ns2__setPubBulkGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setPubBulkGoodsInf::uid = NULL;
	this->ns2__setPubBulkGoodsInf::input = NULL;
	/* transient soap skipped */
}

void ns2__setPubBulkGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubBulkGoodsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubBulkGoodsInf::input);
	/* transient soap skipped */
}

int ns2__setPubBulkGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setPubBulkGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setPubBulkGoodsInf(struct soap *soap, const char *tag, int id, const ns2__setPubBulkGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setPubBulkGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__setPubBulkGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__setPubBulkGoodsInf::input), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setPubBulkGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setPubBulkGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setPubBulkGoodsInf * SOAP_FMAC4 soap_in_ns2__setPubBulkGoodsInf(struct soap *soap, const char *tag, ns2__setPubBulkGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setPubBulkGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setPubBulkGoodsInf, sizeof(ns2__setPubBulkGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setPubBulkGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setPubBulkGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__setPubBulkGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__setPubBulkGoodsInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setPubBulkGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setPubBulkGoodsInf, 0, sizeof(ns2__setPubBulkGoodsInf), 0, soap_copy_ns2__setPubBulkGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setPubBulkGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setPubBulkGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:setPubBulkGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setPubBulkGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setPubBulkGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setPubBulkGoodsInf * SOAP_FMAC4 soap_get_ns2__setPubBulkGoodsInf(struct soap *soap, ns2__setPubBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setPubBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setPubBulkGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__setPubBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setPubBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setPubBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubBulkGoodsInf);
		if (size)
			*size = sizeof(ns2__setPubBulkGoodsInf);
		((ns2__setPubBulkGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setPubBulkGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__setPubBulkGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setPubBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setPubBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setPubBulkGoodsInf %p -> %p\n", q, p));
	*(ns2__setPubBulkGoodsInf*)p = *(ns2__setPubBulkGoodsInf*)q;
}

void ns2__getNewCarsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getNewCarsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getNewCarsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getNewCarsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getNewCarsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getNewCarsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNewCarsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getNewCarsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNewCarsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getNewCarsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getNewCarsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getNewCarsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getNewCarsInfResponse * SOAP_FMAC4 soap_in_ns2__getNewCarsInfResponse(struct soap *soap, const char *tag, ns2__getNewCarsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getNewCarsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNewCarsInfResponse, sizeof(ns2__getNewCarsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getNewCarsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getNewCarsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getNewCarsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getNewCarsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNewCarsInfResponse, 0, sizeof(ns2__getNewCarsInfResponse), 0, soap_copy_ns2__getNewCarsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getNewCarsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getNewCarsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getNewCarsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getNewCarsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getNewCarsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getNewCarsInfResponse * SOAP_FMAC4 soap_get_ns2__getNewCarsInfResponse(struct soap *soap, ns2__getNewCarsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getNewCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getNewCarsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getNewCarsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNewCarsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNewCarsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewCarsInfResponse);
		if (size)
			*size = sizeof(ns2__getNewCarsInfResponse);
		((ns2__getNewCarsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewCarsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getNewCarsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getNewCarsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getNewCarsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNewCarsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getNewCarsInfResponse %p -> %p\n", q, p));
	*(ns2__getNewCarsInfResponse*)p = *(ns2__getNewCarsInfResponse*)q;
}

void ns2__getNewCarsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getNewCarsInf::uid = NULL;
	soap_default_int(soap, &this->ns2__getNewCarsInf::record);
	soap_default_int(soap, &this->ns2__getNewCarsInf::curpage);
	/* transient soap skipped */
}

void ns2__getNewCarsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getNewCarsInf::uid);
	/* transient soap skipped */
}

int ns2__getNewCarsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getNewCarsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNewCarsInf(struct soap *soap, const char *tag, int id, const ns2__getNewCarsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNewCarsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getNewCarsInf::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getNewCarsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getNewCarsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getNewCarsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getNewCarsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getNewCarsInf * SOAP_FMAC4 soap_in_ns2__getNewCarsInf(struct soap *soap, const char *tag, ns2__getNewCarsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getNewCarsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNewCarsInf, sizeof(ns2__getNewCarsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getNewCarsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getNewCarsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getNewCarsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getNewCarsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getNewCarsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getNewCarsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNewCarsInf, 0, sizeof(ns2__getNewCarsInf), 0, soap_copy_ns2__getNewCarsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getNewCarsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getNewCarsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getNewCarsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getNewCarsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getNewCarsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getNewCarsInf * SOAP_FMAC4 soap_get_ns2__getNewCarsInf(struct soap *soap, ns2__getNewCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getNewCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getNewCarsInf * SOAP_FMAC2 soap_instantiate_ns2__getNewCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNewCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNewCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewCarsInf);
		if (size)
			*size = sizeof(ns2__getNewCarsInf);
		((ns2__getNewCarsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getNewCarsInf);
		for (int i = 0; i < n; i++)
			((ns2__getNewCarsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getNewCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNewCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getNewCarsInf %p -> %p\n", q, p));
	*(ns2__getNewCarsInf*)p = *(ns2__getNewCarsInf*)q;
}

void ns2__getClickSearchGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getClickSearchGoodsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getClickSearchGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getClickSearchGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getClickSearchGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClickSearchGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClickSearchGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getClickSearchGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClickSearchGoodsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getClickSearchGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getClickSearchGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getClickSearchGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClickSearchGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__getClickSearchGoodsInfResponse(struct soap *soap, const char *tag, ns2__getClickSearchGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClickSearchGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClickSearchGoodsInfResponse, sizeof(ns2__getClickSearchGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getClickSearchGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getClickSearchGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getClickSearchGoodsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClickSearchGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClickSearchGoodsInfResponse, 0, sizeof(ns2__getClickSearchGoodsInfResponse), 0, soap_copy_ns2__getClickSearchGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getClickSearchGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getClickSearchGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getClickSearchGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClickSearchGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClickSearchGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClickSearchGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__getClickSearchGoodsInfResponse(struct soap *soap, ns2__getClickSearchGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClickSearchGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getClickSearchGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getClickSearchGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClickSearchGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getClickSearchGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__getClickSearchGoodsInfResponse);
		((ns2__getClickSearchGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getClickSearchGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getClickSearchGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getClickSearchGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getClickSearchGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getClickSearchGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__getClickSearchGoodsInfResponse*)p = *(ns2__getClickSearchGoodsInfResponse*)q;
}

void ns2__getClickSearchGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getClickSearchGoodsInf::uid = NULL;
	this->ns2__getClickSearchGoodsInf::input = NULL;
	soap_default_int(soap, &this->ns2__getClickSearchGoodsInf::record);
	soap_default_int(soap, &this->ns2__getClickSearchGoodsInf::curpage);
	/* transient soap skipped */
}

void ns2__getClickSearchGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClickSearchGoodsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClickSearchGoodsInf::input);
	/* transient soap skipped */
}

int ns2__getClickSearchGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClickSearchGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClickSearchGoodsInf(struct soap *soap, const char *tag, int id, const ns2__getClickSearchGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClickSearchGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getClickSearchGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__getClickSearchGoodsInf::input), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getClickSearchGoodsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getClickSearchGoodsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getClickSearchGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getClickSearchGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClickSearchGoodsInf * SOAP_FMAC4 soap_in_ns2__getClickSearchGoodsInf(struct soap *soap, const char *tag, ns2__getClickSearchGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClickSearchGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClickSearchGoodsInf, sizeof(ns2__getClickSearchGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getClickSearchGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getClickSearchGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getClickSearchGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__getClickSearchGoodsInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getClickSearchGoodsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getClickSearchGoodsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClickSearchGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClickSearchGoodsInf, 0, sizeof(ns2__getClickSearchGoodsInf), 0, soap_copy_ns2__getClickSearchGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getClickSearchGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getClickSearchGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getClickSearchGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClickSearchGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClickSearchGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClickSearchGoodsInf * SOAP_FMAC4 soap_get_ns2__getClickSearchGoodsInf(struct soap *soap, ns2__getClickSearchGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClickSearchGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getClickSearchGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__getClickSearchGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClickSearchGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getClickSearchGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchGoodsInf);
		if (size)
			*size = sizeof(ns2__getClickSearchGoodsInf);
		((ns2__getClickSearchGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getClickSearchGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__getClickSearchGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getClickSearchGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getClickSearchGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getClickSearchGoodsInf %p -> %p\n", q, p));
	*(ns2__getClickSearchGoodsInf*)p = *(ns2__getClickSearchGoodsInf*)q;
}

void ns2__setPubGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setPubGoodsInfResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__setPubGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__setPubGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setPubGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setPubGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__setPubGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setPubGoodsInfResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__setPubGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setPubGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setPubGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setPubGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__setPubGoodsInfResponse(struct soap *soap, const char *tag, ns2__setPubGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setPubGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setPubGoodsInfResponse, sizeof(ns2__setPubGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setPubGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setPubGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__setPubGoodsInfResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setPubGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setPubGoodsInfResponse, 0, sizeof(ns2__setPubGoodsInfResponse), 0, soap_copy_ns2__setPubGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setPubGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setPubGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:setPubGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setPubGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setPubGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setPubGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__setPubGoodsInfResponse(struct soap *soap, ns2__setPubGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setPubGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setPubGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__setPubGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setPubGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setPubGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__setPubGoodsInfResponse);
		((ns2__setPubGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setPubGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__setPubGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setPubGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setPubGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setPubGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__setPubGoodsInfResponse*)p = *(ns2__setPubGoodsInfResponse*)q;
}

void ns2__setPubGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setPubGoodsInf::uid = NULL;
	this->ns2__setPubGoodsInf::input = NULL;
	/* transient soap skipped */
}

void ns2__setPubGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubGoodsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__setPubGoodsInf::input);
	/* transient soap skipped */
}

int ns2__setPubGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setPubGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setPubGoodsInf(struct soap *soap, const char *tag, int id, const ns2__setPubGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setPubGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__setPubGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__setPubGoodsInf::input), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setPubGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setPubGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setPubGoodsInf * SOAP_FMAC4 soap_in_ns2__setPubGoodsInf(struct soap *soap, const char *tag, ns2__setPubGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setPubGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setPubGoodsInf, sizeof(ns2__setPubGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setPubGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setPubGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__setPubGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__setPubGoodsInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setPubGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setPubGoodsInf, 0, sizeof(ns2__setPubGoodsInf), 0, soap_copy_ns2__setPubGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setPubGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setPubGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:setPubGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setPubGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setPubGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setPubGoodsInf * SOAP_FMAC4 soap_get_ns2__setPubGoodsInf(struct soap *soap, ns2__setPubGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setPubGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setPubGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__setPubGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setPubGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setPubGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubGoodsInf);
		if (size)
			*size = sizeof(ns2__setPubGoodsInf);
		((ns2__setPubGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setPubGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setPubGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__setPubGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setPubGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setPubGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setPubGoodsInf %p -> %p\n", q, p));
	*(ns2__setPubGoodsInf*)p = *(ns2__setPubGoodsInf*)q;
}

void ns2__addUserCustomInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__addUserCustomInfResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__addUserCustomInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__addUserCustomInfResponse::return_);
	/* transient soap skipped */
}

int ns2__addUserCustomInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__addUserCustomInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__addUserCustomInfResponse(struct soap *soap, const char *tag, int id, const ns2__addUserCustomInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__addUserCustomInfResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__addUserCustomInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__addUserCustomInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__addUserCustomInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__addUserCustomInfResponse * SOAP_FMAC4 soap_in_ns2__addUserCustomInfResponse(struct soap *soap, const char *tag, ns2__addUserCustomInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__addUserCustomInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__addUserCustomInfResponse, sizeof(ns2__addUserCustomInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__addUserCustomInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__addUserCustomInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__addUserCustomInfResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__addUserCustomInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__addUserCustomInfResponse, 0, sizeof(ns2__addUserCustomInfResponse), 0, soap_copy_ns2__addUserCustomInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__addUserCustomInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__addUserCustomInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:addUserCustomInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__addUserCustomInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__addUserCustomInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__addUserCustomInfResponse * SOAP_FMAC4 soap_get_ns2__addUserCustomInfResponse(struct soap *soap, ns2__addUserCustomInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__addUserCustomInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__addUserCustomInfResponse * SOAP_FMAC2 soap_instantiate_ns2__addUserCustomInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__addUserCustomInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__addUserCustomInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__addUserCustomInfResponse);
		if (size)
			*size = sizeof(ns2__addUserCustomInfResponse);
		((ns2__addUserCustomInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__addUserCustomInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__addUserCustomInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__addUserCustomInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__addUserCustomInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__addUserCustomInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__addUserCustomInfResponse %p -> %p\n", q, p));
	*(ns2__addUserCustomInfResponse*)p = *(ns2__addUserCustomInfResponse*)q;
}

void ns2__addUserCustomInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__addUserCustomInf::uid = NULL;
	this->ns2__addUserCustomInf::input = NULL;
	/* transient soap skipped */
}

void ns2__addUserCustomInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__addUserCustomInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__addUserCustomInf::input);
	/* transient soap skipped */
}

int ns2__addUserCustomInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__addUserCustomInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__addUserCustomInf(struct soap *soap, const char *tag, int id, const ns2__addUserCustomInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__addUserCustomInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__addUserCustomInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__addUserCustomInf::input), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__addUserCustomInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__addUserCustomInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__addUserCustomInf * SOAP_FMAC4 soap_in_ns2__addUserCustomInf(struct soap *soap, const char *tag, ns2__addUserCustomInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__addUserCustomInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__addUserCustomInf, sizeof(ns2__addUserCustomInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__addUserCustomInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__addUserCustomInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__addUserCustomInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__addUserCustomInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__addUserCustomInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__addUserCustomInf, 0, sizeof(ns2__addUserCustomInf), 0, soap_copy_ns2__addUserCustomInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__addUserCustomInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__addUserCustomInf);
	if (this->soap_out(soap, tag?tag:"ns2:addUserCustomInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__addUserCustomInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__addUserCustomInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__addUserCustomInf * SOAP_FMAC4 soap_get_ns2__addUserCustomInf(struct soap *soap, ns2__addUserCustomInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__addUserCustomInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__addUserCustomInf * SOAP_FMAC2 soap_instantiate_ns2__addUserCustomInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__addUserCustomInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__addUserCustomInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__addUserCustomInf);
		if (size)
			*size = sizeof(ns2__addUserCustomInf);
		((ns2__addUserCustomInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__addUserCustomInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__addUserCustomInf);
		for (int i = 0; i < n; i++)
			((ns2__addUserCustomInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__addUserCustomInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__addUserCustomInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__addUserCustomInf %p -> %p\n", q, p));
	*(ns2__addUserCustomInf*)p = *(ns2__addUserCustomInf*)q;
}

void ns2__getMyBulkGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getMyBulkGoodsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getMyBulkGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getMyBulkGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getMyBulkGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMyBulkGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMyBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getMyBulkGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMyBulkGoodsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getMyBulkGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getMyBulkGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getMyBulkGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMyBulkGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__getMyBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__getMyBulkGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMyBulkGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMyBulkGoodsInfResponse, sizeof(ns2__getMyBulkGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getMyBulkGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getMyBulkGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getMyBulkGoodsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMyBulkGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMyBulkGoodsInfResponse, 0, sizeof(ns2__getMyBulkGoodsInfResponse), 0, soap_copy_ns2__getMyBulkGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getMyBulkGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getMyBulkGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getMyBulkGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMyBulkGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMyBulkGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMyBulkGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__getMyBulkGoodsInfResponse(struct soap *soap, ns2__getMyBulkGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMyBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getMyBulkGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getMyBulkGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMyBulkGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMyBulkGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyBulkGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__getMyBulkGoodsInfResponse);
		((ns2__getMyBulkGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyBulkGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getMyBulkGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getMyBulkGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getMyBulkGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMyBulkGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getMyBulkGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__getMyBulkGoodsInfResponse*)p = *(ns2__getMyBulkGoodsInfResponse*)q;
}

void ns2__getMyBulkGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getMyBulkGoodsInf::uid = NULL;
	soap_default_int(soap, &this->ns2__getMyBulkGoodsInf::record);
	soap_default_int(soap, &this->ns2__getMyBulkGoodsInf::curpage);
	/* transient soap skipped */
}

void ns2__getMyBulkGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getMyBulkGoodsInf::uid);
	/* transient soap skipped */
}

int ns2__getMyBulkGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMyBulkGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMyBulkGoodsInf(struct soap *soap, const char *tag, int id, const ns2__getMyBulkGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMyBulkGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getMyBulkGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getMyBulkGoodsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getMyBulkGoodsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getMyBulkGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getMyBulkGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMyBulkGoodsInf * SOAP_FMAC4 soap_in_ns2__getMyBulkGoodsInf(struct soap *soap, const char *tag, ns2__getMyBulkGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMyBulkGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMyBulkGoodsInf, sizeof(ns2__getMyBulkGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getMyBulkGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getMyBulkGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getMyBulkGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getMyBulkGoodsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getMyBulkGoodsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMyBulkGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMyBulkGoodsInf, 0, sizeof(ns2__getMyBulkGoodsInf), 0, soap_copy_ns2__getMyBulkGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getMyBulkGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getMyBulkGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getMyBulkGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMyBulkGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMyBulkGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMyBulkGoodsInf * SOAP_FMAC4 soap_get_ns2__getMyBulkGoodsInf(struct soap *soap, ns2__getMyBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMyBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getMyBulkGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__getMyBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMyBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMyBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyBulkGoodsInf);
		if (size)
			*size = sizeof(ns2__getMyBulkGoodsInf);
		((ns2__getMyBulkGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getMyBulkGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__getMyBulkGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getMyBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMyBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getMyBulkGoodsInf %p -> %p\n", q, p));
	*(ns2__getMyBulkGoodsInf*)p = *(ns2__getMyBulkGoodsInf*)q;
}

void ns2__delSpecialLineInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__delSpecialLineInfResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__delSpecialLineInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__delSpecialLineInfResponse::return_);
	/* transient soap skipped */
}

int ns2__delSpecialLineInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__delSpecialLineInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__delSpecialLineInfResponse(struct soap *soap, const char *tag, int id, const ns2__delSpecialLineInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__delSpecialLineInfResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__delSpecialLineInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__delSpecialLineInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__delSpecialLineInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__delSpecialLineInfResponse * SOAP_FMAC4 soap_in_ns2__delSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__delSpecialLineInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__delSpecialLineInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__delSpecialLineInfResponse, sizeof(ns2__delSpecialLineInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__delSpecialLineInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__delSpecialLineInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__delSpecialLineInfResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__delSpecialLineInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__delSpecialLineInfResponse, 0, sizeof(ns2__delSpecialLineInfResponse), 0, soap_copy_ns2__delSpecialLineInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__delSpecialLineInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__delSpecialLineInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:delSpecialLineInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__delSpecialLineInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__delSpecialLineInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__delSpecialLineInfResponse * SOAP_FMAC4 soap_get_ns2__delSpecialLineInfResponse(struct soap *soap, ns2__delSpecialLineInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__delSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__delSpecialLineInfResponse * SOAP_FMAC2 soap_instantiate_ns2__delSpecialLineInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__delSpecialLineInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__delSpecialLineInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__delSpecialLineInfResponse);
		if (size)
			*size = sizeof(ns2__delSpecialLineInfResponse);
		((ns2__delSpecialLineInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__delSpecialLineInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__delSpecialLineInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__delSpecialLineInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__delSpecialLineInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__delSpecialLineInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__delSpecialLineInfResponse %p -> %p\n", q, p));
	*(ns2__delSpecialLineInfResponse*)p = *(ns2__delSpecialLineInfResponse*)q;
}

void ns2__delSpecialLineInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__delSpecialLineInf::uid = NULL;
	this->ns2__delSpecialLineInf::recordID = NULL;
	/* transient soap skipped */
}

void ns2__delSpecialLineInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__delSpecialLineInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__delSpecialLineInf::recordID);
	/* transient soap skipped */
}

int ns2__delSpecialLineInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__delSpecialLineInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__delSpecialLineInf(struct soap *soap, const char *tag, int id, const ns2__delSpecialLineInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__delSpecialLineInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__delSpecialLineInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "recordID", -1, &(a->ns2__delSpecialLineInf::recordID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__delSpecialLineInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__delSpecialLineInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__delSpecialLineInf * SOAP_FMAC4 soap_in_ns2__delSpecialLineInf(struct soap *soap, const char *tag, ns2__delSpecialLineInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__delSpecialLineInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__delSpecialLineInf, sizeof(ns2__delSpecialLineInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__delSpecialLineInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__delSpecialLineInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_recordID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__delSpecialLineInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_recordID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "recordID", &(a->ns2__delSpecialLineInf::recordID), "xsd:string"))
				{	soap_flag_recordID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__delSpecialLineInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__delSpecialLineInf, 0, sizeof(ns2__delSpecialLineInf), 0, soap_copy_ns2__delSpecialLineInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__delSpecialLineInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__delSpecialLineInf);
	if (this->soap_out(soap, tag?tag:"ns2:delSpecialLineInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__delSpecialLineInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__delSpecialLineInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__delSpecialLineInf * SOAP_FMAC4 soap_get_ns2__delSpecialLineInf(struct soap *soap, ns2__delSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__delSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__delSpecialLineInf * SOAP_FMAC2 soap_instantiate_ns2__delSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__delSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__delSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__delSpecialLineInf);
		if (size)
			*size = sizeof(ns2__delSpecialLineInf);
		((ns2__delSpecialLineInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__delSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__delSpecialLineInf);
		for (int i = 0; i < n; i++)
			((ns2__delSpecialLineInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__delSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__delSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__delSpecialLineInf %p -> %p\n", q, p));
	*(ns2__delSpecialLineInf*)p = *(ns2__delSpecialLineInf*)q;
}

void ns2__getAllSpecialLineInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getAllSpecialLineInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getAllSpecialLineInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getAllSpecialLineInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getAllSpecialLineInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getAllSpecialLineInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getAllSpecialLineInfResponse(struct soap *soap, const char *tag, int id, const ns2__getAllSpecialLineInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getAllSpecialLineInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getAllSpecialLineInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getAllSpecialLineInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getAllSpecialLineInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getAllSpecialLineInfResponse * SOAP_FMAC4 soap_in_ns2__getAllSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__getAllSpecialLineInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getAllSpecialLineInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getAllSpecialLineInfResponse, sizeof(ns2__getAllSpecialLineInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getAllSpecialLineInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getAllSpecialLineInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getAllSpecialLineInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getAllSpecialLineInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getAllSpecialLineInfResponse, 0, sizeof(ns2__getAllSpecialLineInfResponse), 0, soap_copy_ns2__getAllSpecialLineInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getAllSpecialLineInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getAllSpecialLineInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getAllSpecialLineInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getAllSpecialLineInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getAllSpecialLineInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getAllSpecialLineInfResponse * SOAP_FMAC4 soap_get_ns2__getAllSpecialLineInfResponse(struct soap *soap, ns2__getAllSpecialLineInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getAllSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getAllSpecialLineInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getAllSpecialLineInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getAllSpecialLineInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getAllSpecialLineInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAllSpecialLineInfResponse);
		if (size)
			*size = sizeof(ns2__getAllSpecialLineInfResponse);
		((ns2__getAllSpecialLineInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAllSpecialLineInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getAllSpecialLineInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getAllSpecialLineInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getAllSpecialLineInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getAllSpecialLineInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getAllSpecialLineInfResponse %p -> %p\n", q, p));
	*(ns2__getAllSpecialLineInfResponse*)p = *(ns2__getAllSpecialLineInfResponse*)q;
}

void ns2__getAllSpecialLineInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getAllSpecialLineInf::uid = NULL;
	soap_default_int(soap, &this->ns2__getAllSpecialLineInf::record);
	soap_default_int(soap, &this->ns2__getAllSpecialLineInf::curpage);
	/* transient soap skipped */
}

void ns2__getAllSpecialLineInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getAllSpecialLineInf::uid);
	/* transient soap skipped */
}

int ns2__getAllSpecialLineInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getAllSpecialLineInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getAllSpecialLineInf(struct soap *soap, const char *tag, int id, const ns2__getAllSpecialLineInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getAllSpecialLineInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getAllSpecialLineInf::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getAllSpecialLineInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getAllSpecialLineInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getAllSpecialLineInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getAllSpecialLineInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getAllSpecialLineInf * SOAP_FMAC4 soap_in_ns2__getAllSpecialLineInf(struct soap *soap, const char *tag, ns2__getAllSpecialLineInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getAllSpecialLineInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getAllSpecialLineInf, sizeof(ns2__getAllSpecialLineInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getAllSpecialLineInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getAllSpecialLineInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getAllSpecialLineInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getAllSpecialLineInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getAllSpecialLineInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getAllSpecialLineInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getAllSpecialLineInf, 0, sizeof(ns2__getAllSpecialLineInf), 0, soap_copy_ns2__getAllSpecialLineInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getAllSpecialLineInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getAllSpecialLineInf);
	if (this->soap_out(soap, tag?tag:"ns2:getAllSpecialLineInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getAllSpecialLineInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getAllSpecialLineInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getAllSpecialLineInf * SOAP_FMAC4 soap_get_ns2__getAllSpecialLineInf(struct soap *soap, ns2__getAllSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getAllSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getAllSpecialLineInf * SOAP_FMAC2 soap_instantiate_ns2__getAllSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getAllSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getAllSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAllSpecialLineInf);
		if (size)
			*size = sizeof(ns2__getAllSpecialLineInf);
		((ns2__getAllSpecialLineInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAllSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getAllSpecialLineInf);
		for (int i = 0; i < n; i++)
			((ns2__getAllSpecialLineInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getAllSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getAllSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getAllSpecialLineInf %p -> %p\n", q, p));
	*(ns2__getAllSpecialLineInf*)p = *(ns2__getAllSpecialLineInf*)q;
}

void ns2__getClickSearchSpecialLineInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getClickSearchSpecialLineInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getClickSearchSpecialLineInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getClickSearchSpecialLineInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getClickSearchSpecialLineInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClickSearchSpecialLineInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClickSearchSpecialLineInfResponse(struct soap *soap, const char *tag, int id, const ns2__getClickSearchSpecialLineInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getClickSearchSpecialLineInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getClickSearchSpecialLineInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getClickSearchSpecialLineInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClickSearchSpecialLineInfResponse * SOAP_FMAC4 soap_in_ns2__getClickSearchSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__getClickSearchSpecialLineInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClickSearchSpecialLineInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse, sizeof(ns2__getClickSearchSpecialLineInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getClickSearchSpecialLineInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getClickSearchSpecialLineInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClickSearchSpecialLineInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse, 0, sizeof(ns2__getClickSearchSpecialLineInfResponse), 0, soap_copy_ns2__getClickSearchSpecialLineInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getClickSearchSpecialLineInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getClickSearchSpecialLineInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClickSearchSpecialLineInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClickSearchSpecialLineInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClickSearchSpecialLineInfResponse * SOAP_FMAC4 soap_get_ns2__getClickSearchSpecialLineInfResponse(struct soap *soap, ns2__getClickSearchSpecialLineInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClickSearchSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getClickSearchSpecialLineInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getClickSearchSpecialLineInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClickSearchSpecialLineInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchSpecialLineInfResponse);
		if (size)
			*size = sizeof(ns2__getClickSearchSpecialLineInfResponse);
		((ns2__getClickSearchSpecialLineInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchSpecialLineInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getClickSearchSpecialLineInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getClickSearchSpecialLineInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getClickSearchSpecialLineInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getClickSearchSpecialLineInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getClickSearchSpecialLineInfResponse %p -> %p\n", q, p));
	*(ns2__getClickSearchSpecialLineInfResponse*)p = *(ns2__getClickSearchSpecialLineInfResponse*)q;
}

void ns2__getClickSearchSpecialLineInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getClickSearchSpecialLineInf::uid = NULL;
	this->ns2__getClickSearchSpecialLineInf::input = NULL;
	soap_default_int(soap, &this->ns2__getClickSearchSpecialLineInf::record);
	soap_default_int(soap, &this->ns2__getClickSearchSpecialLineInf::curpage);
	/* transient soap skipped */
}

void ns2__getClickSearchSpecialLineInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClickSearchSpecialLineInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClickSearchSpecialLineInf::input);
	/* transient soap skipped */
}

int ns2__getClickSearchSpecialLineInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClickSearchSpecialLineInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClickSearchSpecialLineInf(struct soap *soap, const char *tag, int id, const ns2__getClickSearchSpecialLineInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClickSearchSpecialLineInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getClickSearchSpecialLineInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__getClickSearchSpecialLineInf::input), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getClickSearchSpecialLineInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getClickSearchSpecialLineInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getClickSearchSpecialLineInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getClickSearchSpecialLineInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClickSearchSpecialLineInf * SOAP_FMAC4 soap_in_ns2__getClickSearchSpecialLineInf(struct soap *soap, const char *tag, ns2__getClickSearchSpecialLineInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClickSearchSpecialLineInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClickSearchSpecialLineInf, sizeof(ns2__getClickSearchSpecialLineInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getClickSearchSpecialLineInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getClickSearchSpecialLineInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getClickSearchSpecialLineInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__getClickSearchSpecialLineInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getClickSearchSpecialLineInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getClickSearchSpecialLineInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClickSearchSpecialLineInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClickSearchSpecialLineInf, 0, sizeof(ns2__getClickSearchSpecialLineInf), 0, soap_copy_ns2__getClickSearchSpecialLineInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getClickSearchSpecialLineInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getClickSearchSpecialLineInf);
	if (this->soap_out(soap, tag?tag:"ns2:getClickSearchSpecialLineInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClickSearchSpecialLineInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClickSearchSpecialLineInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClickSearchSpecialLineInf * SOAP_FMAC4 soap_get_ns2__getClickSearchSpecialLineInf(struct soap *soap, ns2__getClickSearchSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClickSearchSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getClickSearchSpecialLineInf * SOAP_FMAC2 soap_instantiate_ns2__getClickSearchSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClickSearchSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getClickSearchSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchSpecialLineInf);
		if (size)
			*size = sizeof(ns2__getClickSearchSpecialLineInf);
		((ns2__getClickSearchSpecialLineInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getClickSearchSpecialLineInf);
		for (int i = 0; i < n; i++)
			((ns2__getClickSearchSpecialLineInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getClickSearchSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getClickSearchSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getClickSearchSpecialLineInf %p -> %p\n", q, p));
	*(ns2__getClickSearchSpecialLineInf*)p = *(ns2__getClickSearchSpecialLineInf*)q;
}

void ns2__checkChargeUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__checkChargeUserResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__checkChargeUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__checkChargeUserResponse::return_);
	/* transient soap skipped */
}

int ns2__checkChargeUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__checkChargeUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__checkChargeUserResponse(struct soap *soap, const char *tag, int id, const ns2__checkChargeUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__checkChargeUserResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__checkChargeUserResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__checkChargeUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__checkChargeUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__checkChargeUserResponse * SOAP_FMAC4 soap_in_ns2__checkChargeUserResponse(struct soap *soap, const char *tag, ns2__checkChargeUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__checkChargeUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__checkChargeUserResponse, sizeof(ns2__checkChargeUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__checkChargeUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__checkChargeUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__checkChargeUserResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__checkChargeUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__checkChargeUserResponse, 0, sizeof(ns2__checkChargeUserResponse), 0, soap_copy_ns2__checkChargeUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__checkChargeUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__checkChargeUserResponse);
	if (this->soap_out(soap, tag?tag:"ns2:checkChargeUserResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__checkChargeUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__checkChargeUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__checkChargeUserResponse * SOAP_FMAC4 soap_get_ns2__checkChargeUserResponse(struct soap *soap, ns2__checkChargeUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__checkChargeUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__checkChargeUserResponse * SOAP_FMAC2 soap_instantiate_ns2__checkChargeUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__checkChargeUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__checkChargeUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__checkChargeUserResponse);
		if (size)
			*size = sizeof(ns2__checkChargeUserResponse);
		((ns2__checkChargeUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__checkChargeUserResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__checkChargeUserResponse);
		for (int i = 0; i < n; i++)
			((ns2__checkChargeUserResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__checkChargeUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__checkChargeUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__checkChargeUserResponse %p -> %p\n", q, p));
	*(ns2__checkChargeUserResponse*)p = *(ns2__checkChargeUserResponse*)q;
}

void ns2__checkChargeUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__checkChargeUser::loginname = NULL;
	/* transient soap skipped */
}

void ns2__checkChargeUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__checkChargeUser::loginname);
	/* transient soap skipped */
}

int ns2__checkChargeUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__checkChargeUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__checkChargeUser(struct soap *soap, const char *tag, int id, const ns2__checkChargeUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__checkChargeUser), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "loginname", -1, &(a->ns2__checkChargeUser::loginname), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__checkChargeUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__checkChargeUser(soap, tag, this, type);
}

SOAP_FMAC3 ns2__checkChargeUser * SOAP_FMAC4 soap_in_ns2__checkChargeUser(struct soap *soap, const char *tag, ns2__checkChargeUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__checkChargeUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__checkChargeUser, sizeof(ns2__checkChargeUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__checkChargeUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__checkChargeUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_loginname1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "loginname", &(a->ns2__checkChargeUser::loginname), "xsd:string"))
				{	soap_flag_loginname1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__checkChargeUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__checkChargeUser, 0, sizeof(ns2__checkChargeUser), 0, soap_copy_ns2__checkChargeUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__checkChargeUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__checkChargeUser);
	if (this->soap_out(soap, tag?tag:"ns2:checkChargeUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__checkChargeUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__checkChargeUser(soap, this, tag, type);
}

SOAP_FMAC3 ns2__checkChargeUser * SOAP_FMAC4 soap_get_ns2__checkChargeUser(struct soap *soap, ns2__checkChargeUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__checkChargeUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__checkChargeUser * SOAP_FMAC2 soap_instantiate_ns2__checkChargeUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__checkChargeUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__checkChargeUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__checkChargeUser);
		if (size)
			*size = sizeof(ns2__checkChargeUser);
		((ns2__checkChargeUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__checkChargeUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__checkChargeUser);
		for (int i = 0; i < n; i++)
			((ns2__checkChargeUser*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__checkChargeUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__checkChargeUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__checkChargeUser %p -> %p\n", q, p));
	*(ns2__checkChargeUser*)p = *(ns2__checkChargeUser*)q;
}

void ns2__deleteUserCustomInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__deleteUserCustomInfResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__deleteUserCustomInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__deleteUserCustomInfResponse::return_);
	/* transient soap skipped */
}

int ns2__deleteUserCustomInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteUserCustomInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteUserCustomInfResponse(struct soap *soap, const char *tag, int id, const ns2__deleteUserCustomInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteUserCustomInfResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__deleteUserCustomInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteUserCustomInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__deleteUserCustomInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteUserCustomInfResponse * SOAP_FMAC4 soap_in_ns2__deleteUserCustomInfResponse(struct soap *soap, const char *tag, ns2__deleteUserCustomInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteUserCustomInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteUserCustomInfResponse, sizeof(ns2__deleteUserCustomInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__deleteUserCustomInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__deleteUserCustomInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__deleteUserCustomInfResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteUserCustomInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteUserCustomInfResponse, 0, sizeof(ns2__deleteUserCustomInfResponse), 0, soap_copy_ns2__deleteUserCustomInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__deleteUserCustomInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__deleteUserCustomInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:deleteUserCustomInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteUserCustomInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteUserCustomInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteUserCustomInfResponse * SOAP_FMAC4 soap_get_ns2__deleteUserCustomInfResponse(struct soap *soap, ns2__deleteUserCustomInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteUserCustomInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__deleteUserCustomInfResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteUserCustomInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteUserCustomInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__deleteUserCustomInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__deleteUserCustomInfResponse);
		if (size)
			*size = sizeof(ns2__deleteUserCustomInfResponse);
		((ns2__deleteUserCustomInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__deleteUserCustomInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__deleteUserCustomInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__deleteUserCustomInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__deleteUserCustomInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__deleteUserCustomInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__deleteUserCustomInfResponse %p -> %p\n", q, p));
	*(ns2__deleteUserCustomInfResponse*)p = *(ns2__deleteUserCustomInfResponse*)q;
}

void ns2__deleteUserCustomInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__deleteUserCustomInf::uid = NULL;
	this->ns2__deleteUserCustomInf::input = NULL;
	/* transient soap skipped */
}

void ns2__deleteUserCustomInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__deleteUserCustomInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__deleteUserCustomInf::input);
	/* transient soap skipped */
}

int ns2__deleteUserCustomInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteUserCustomInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteUserCustomInf(struct soap *soap, const char *tag, int id, const ns2__deleteUserCustomInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteUserCustomInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__deleteUserCustomInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__deleteUserCustomInf::input), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteUserCustomInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__deleteUserCustomInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteUserCustomInf * SOAP_FMAC4 soap_in_ns2__deleteUserCustomInf(struct soap *soap, const char *tag, ns2__deleteUserCustomInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteUserCustomInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteUserCustomInf, sizeof(ns2__deleteUserCustomInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__deleteUserCustomInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__deleteUserCustomInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__deleteUserCustomInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__deleteUserCustomInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteUserCustomInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteUserCustomInf, 0, sizeof(ns2__deleteUserCustomInf), 0, soap_copy_ns2__deleteUserCustomInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__deleteUserCustomInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__deleteUserCustomInf);
	if (this->soap_out(soap, tag?tag:"ns2:deleteUserCustomInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteUserCustomInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteUserCustomInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteUserCustomInf * SOAP_FMAC4 soap_get_ns2__deleteUserCustomInf(struct soap *soap, ns2__deleteUserCustomInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteUserCustomInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__deleteUserCustomInf * SOAP_FMAC2 soap_instantiate_ns2__deleteUserCustomInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteUserCustomInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__deleteUserCustomInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__deleteUserCustomInf);
		if (size)
			*size = sizeof(ns2__deleteUserCustomInf);
		((ns2__deleteUserCustomInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__deleteUserCustomInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__deleteUserCustomInf);
		for (int i = 0; i < n; i++)
			((ns2__deleteUserCustomInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__deleteUserCustomInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__deleteUserCustomInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__deleteUserCustomInf %p -> %p\n", q, p));
	*(ns2__deleteUserCustomInf*)p = *(ns2__deleteUserCustomInf*)q;
}

void ns2__setServiceStationInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setServiceStationInfResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__setServiceStationInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setServiceStationInfResponse::return_);
	/* transient soap skipped */
}

int ns2__setServiceStationInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setServiceStationInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setServiceStationInfResponse(struct soap *soap, const char *tag, int id, const ns2__setServiceStationInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setServiceStationInfResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__setServiceStationInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setServiceStationInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setServiceStationInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setServiceStationInfResponse * SOAP_FMAC4 soap_in_ns2__setServiceStationInfResponse(struct soap *soap, const char *tag, ns2__setServiceStationInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setServiceStationInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setServiceStationInfResponse, sizeof(ns2__setServiceStationInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setServiceStationInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setServiceStationInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__setServiceStationInfResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setServiceStationInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setServiceStationInfResponse, 0, sizeof(ns2__setServiceStationInfResponse), 0, soap_copy_ns2__setServiceStationInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setServiceStationInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setServiceStationInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:setServiceStationInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setServiceStationInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setServiceStationInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setServiceStationInfResponse * SOAP_FMAC4 soap_get_ns2__setServiceStationInfResponse(struct soap *soap, ns2__setServiceStationInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setServiceStationInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setServiceStationInfResponse * SOAP_FMAC2 soap_instantiate_ns2__setServiceStationInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setServiceStationInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setServiceStationInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setServiceStationInfResponse);
		if (size)
			*size = sizeof(ns2__setServiceStationInfResponse);
		((ns2__setServiceStationInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setServiceStationInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setServiceStationInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__setServiceStationInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setServiceStationInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setServiceStationInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setServiceStationInfResponse %p -> %p\n", q, p));
	*(ns2__setServiceStationInfResponse*)p = *(ns2__setServiceStationInfResponse*)q;
}

void ns2__setServiceStationInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setServiceStationInf::uid = NULL;
	this->ns2__setServiceStationInf::sid = NULL;
	this->ns2__setServiceStationInf::msg = NULL;
	/* transient soap skipped */
}

void ns2__setServiceStationInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setServiceStationInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__setServiceStationInf::sid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__setServiceStationInf::msg);
	/* transient soap skipped */
}

int ns2__setServiceStationInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setServiceStationInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setServiceStationInf(struct soap *soap, const char *tag, int id, const ns2__setServiceStationInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setServiceStationInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__setServiceStationInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sid", -1, &(a->ns2__setServiceStationInf::sid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msg", -1, &(a->ns2__setServiceStationInf::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setServiceStationInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setServiceStationInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setServiceStationInf * SOAP_FMAC4 soap_in_ns2__setServiceStationInf(struct soap *soap, const char *tag, ns2__setServiceStationInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setServiceStationInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setServiceStationInf, sizeof(ns2__setServiceStationInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setServiceStationInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setServiceStationInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__setServiceStationInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sid", &(a->ns2__setServiceStationInf::sid), "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msg", &(a->ns2__setServiceStationInf::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setServiceStationInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setServiceStationInf, 0, sizeof(ns2__setServiceStationInf), 0, soap_copy_ns2__setServiceStationInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setServiceStationInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setServiceStationInf);
	if (this->soap_out(soap, tag?tag:"ns2:setServiceStationInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setServiceStationInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setServiceStationInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setServiceStationInf * SOAP_FMAC4 soap_get_ns2__setServiceStationInf(struct soap *soap, ns2__setServiceStationInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setServiceStationInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setServiceStationInf * SOAP_FMAC2 soap_instantiate_ns2__setServiceStationInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setServiceStationInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setServiceStationInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setServiceStationInf);
		if (size)
			*size = sizeof(ns2__setServiceStationInf);
		((ns2__setServiceStationInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setServiceStationInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setServiceStationInf);
		for (int i = 0; i < n; i++)
			((ns2__setServiceStationInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setServiceStationInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setServiceStationInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setServiceStationInf %p -> %p\n", q, p));
	*(ns2__setServiceStationInf*)p = *(ns2__setServiceStationInf*)q;
}

void ns2__getClickSearchBulkGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getClickSearchBulkGoodsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getClickSearchBulkGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getClickSearchBulkGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getClickSearchBulkGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClickSearchBulkGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClickSearchBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getClickSearchBulkGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getClickSearchBulkGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getClickSearchBulkGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getClickSearchBulkGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClickSearchBulkGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__getClickSearchBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__getClickSearchBulkGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClickSearchBulkGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse, sizeof(ns2__getClickSearchBulkGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getClickSearchBulkGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getClickSearchBulkGoodsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClickSearchBulkGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse, 0, sizeof(ns2__getClickSearchBulkGoodsInfResponse), 0, soap_copy_ns2__getClickSearchBulkGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getClickSearchBulkGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getClickSearchBulkGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClickSearchBulkGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClickSearchBulkGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClickSearchBulkGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__getClickSearchBulkGoodsInfResponse(struct soap *soap, ns2__getClickSearchBulkGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClickSearchBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getClickSearchBulkGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getClickSearchBulkGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClickSearchBulkGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchBulkGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__getClickSearchBulkGoodsInfResponse);
		((ns2__getClickSearchBulkGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchBulkGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getClickSearchBulkGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getClickSearchBulkGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getClickSearchBulkGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getClickSearchBulkGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getClickSearchBulkGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__getClickSearchBulkGoodsInfResponse*)p = *(ns2__getClickSearchBulkGoodsInfResponse*)q;
}

void ns2__getClickSearchBulkGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getClickSearchBulkGoodsInf::uid = NULL;
	this->ns2__getClickSearchBulkGoodsInf::input = NULL;
	soap_default_int(soap, &this->ns2__getClickSearchBulkGoodsInf::record);
	soap_default_int(soap, &this->ns2__getClickSearchBulkGoodsInf::curpage);
	/* transient soap skipped */
}

void ns2__getClickSearchBulkGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClickSearchBulkGoodsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClickSearchBulkGoodsInf::input);
	/* transient soap skipped */
}

int ns2__getClickSearchBulkGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClickSearchBulkGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClickSearchBulkGoodsInf(struct soap *soap, const char *tag, int id, const ns2__getClickSearchBulkGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClickSearchBulkGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getClickSearchBulkGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__getClickSearchBulkGoodsInf::input), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getClickSearchBulkGoodsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getClickSearchBulkGoodsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getClickSearchBulkGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getClickSearchBulkGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClickSearchBulkGoodsInf * SOAP_FMAC4 soap_in_ns2__getClickSearchBulkGoodsInf(struct soap *soap, const char *tag, ns2__getClickSearchBulkGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClickSearchBulkGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClickSearchBulkGoodsInf, sizeof(ns2__getClickSearchBulkGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getClickSearchBulkGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getClickSearchBulkGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getClickSearchBulkGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__getClickSearchBulkGoodsInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getClickSearchBulkGoodsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getClickSearchBulkGoodsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClickSearchBulkGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClickSearchBulkGoodsInf, 0, sizeof(ns2__getClickSearchBulkGoodsInf), 0, soap_copy_ns2__getClickSearchBulkGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getClickSearchBulkGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getClickSearchBulkGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getClickSearchBulkGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClickSearchBulkGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClickSearchBulkGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClickSearchBulkGoodsInf * SOAP_FMAC4 soap_get_ns2__getClickSearchBulkGoodsInf(struct soap *soap, ns2__getClickSearchBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClickSearchBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getClickSearchBulkGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__getClickSearchBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClickSearchBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getClickSearchBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchBulkGoodsInf);
		if (size)
			*size = sizeof(ns2__getClickSearchBulkGoodsInf);
		((ns2__getClickSearchBulkGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickSearchBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getClickSearchBulkGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__getClickSearchBulkGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getClickSearchBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getClickSearchBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getClickSearchBulkGoodsInf %p -> %p\n", q, p));
	*(ns2__getClickSearchBulkGoodsInf*)p = *(ns2__getClickSearchBulkGoodsInf*)q;
}

void ns2__getCustomGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getCustomGoodsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getCustomGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getCustomGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getCustomGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getCustomGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getCustomGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getCustomGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getCustomGoodsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getCustomGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getCustomGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getCustomGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getCustomGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__getCustomGoodsInfResponse(struct soap *soap, const char *tag, ns2__getCustomGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getCustomGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getCustomGoodsInfResponse, sizeof(ns2__getCustomGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getCustomGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getCustomGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getCustomGoodsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getCustomGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getCustomGoodsInfResponse, 0, sizeof(ns2__getCustomGoodsInfResponse), 0, soap_copy_ns2__getCustomGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getCustomGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getCustomGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getCustomGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getCustomGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getCustomGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getCustomGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__getCustomGoodsInfResponse(struct soap *soap, ns2__getCustomGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getCustomGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getCustomGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getCustomGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getCustomGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getCustomGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getCustomGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__getCustomGoodsInfResponse);
		((ns2__getCustomGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getCustomGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getCustomGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getCustomGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getCustomGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getCustomGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getCustomGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__getCustomGoodsInfResponse*)p = *(ns2__getCustomGoodsInfResponse*)q;
}

void ns2__getCustomGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getCustomGoodsInf::uid = NULL;
	soap_default_int(soap, &this->ns2__getCustomGoodsInf::customid);
	soap_default_int(soap, &this->ns2__getCustomGoodsInf::record);
	soap_default_int(soap, &this->ns2__getCustomGoodsInf::curpage);
	/* transient soap skipped */
}

void ns2__getCustomGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getCustomGoodsInf::uid);
	/* transient soap skipped */
}

int ns2__getCustomGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getCustomGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getCustomGoodsInf(struct soap *soap, const char *tag, int id, const ns2__getCustomGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getCustomGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getCustomGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "customid", -1, &(a->ns2__getCustomGoodsInf::customid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getCustomGoodsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getCustomGoodsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getCustomGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getCustomGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getCustomGoodsInf * SOAP_FMAC4 soap_in_ns2__getCustomGoodsInf(struct soap *soap, const char *tag, ns2__getCustomGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getCustomGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getCustomGoodsInf, sizeof(ns2__getCustomGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getCustomGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getCustomGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_customid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getCustomGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_customid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "customid", &(a->ns2__getCustomGoodsInf::customid), "xsd:int"))
				{	soap_flag_customid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getCustomGoodsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getCustomGoodsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getCustomGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getCustomGoodsInf, 0, sizeof(ns2__getCustomGoodsInf), 0, soap_copy_ns2__getCustomGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_customid1 > 0 || soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getCustomGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getCustomGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getCustomGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getCustomGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getCustomGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getCustomGoodsInf * SOAP_FMAC4 soap_get_ns2__getCustomGoodsInf(struct soap *soap, ns2__getCustomGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getCustomGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getCustomGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__getCustomGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getCustomGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getCustomGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getCustomGoodsInf);
		if (size)
			*size = sizeof(ns2__getCustomGoodsInf);
		((ns2__getCustomGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getCustomGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getCustomGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__getCustomGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getCustomGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getCustomGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getCustomGoodsInf %p -> %p\n", q, p));
	*(ns2__getCustomGoodsInf*)p = *(ns2__getCustomGoodsInf*)q;
}

void ns2__getAgentScrollAdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getAgentScrollAdResponse::return_);
	/* transient soap skipped */
}

void ns2__getAgentScrollAdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getAgentScrollAdResponse::return_);
	/* transient soap skipped */
}

int ns2__getAgentScrollAdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getAgentScrollAdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getAgentScrollAdResponse(struct soap *soap, const char *tag, int id, const ns2__getAgentScrollAdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getAgentScrollAdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getAgentScrollAdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getAgentScrollAdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getAgentScrollAdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getAgentScrollAdResponse * SOAP_FMAC4 soap_in_ns2__getAgentScrollAdResponse(struct soap *soap, const char *tag, ns2__getAgentScrollAdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getAgentScrollAdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getAgentScrollAdResponse, sizeof(ns2__getAgentScrollAdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getAgentScrollAdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getAgentScrollAdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getAgentScrollAdResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getAgentScrollAdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getAgentScrollAdResponse, 0, sizeof(ns2__getAgentScrollAdResponse), 0, soap_copy_ns2__getAgentScrollAdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getAgentScrollAdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getAgentScrollAdResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getAgentScrollAdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getAgentScrollAdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getAgentScrollAdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getAgentScrollAdResponse * SOAP_FMAC4 soap_get_ns2__getAgentScrollAdResponse(struct soap *soap, ns2__getAgentScrollAdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getAgentScrollAdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getAgentScrollAdResponse * SOAP_FMAC2 soap_instantiate_ns2__getAgentScrollAdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getAgentScrollAdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getAgentScrollAdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAgentScrollAdResponse);
		if (size)
			*size = sizeof(ns2__getAgentScrollAdResponse);
		((ns2__getAgentScrollAdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAgentScrollAdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getAgentScrollAdResponse);
		for (int i = 0; i < n; i++)
			((ns2__getAgentScrollAdResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getAgentScrollAdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getAgentScrollAdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getAgentScrollAdResponse %p -> %p\n", q, p));
	*(ns2__getAgentScrollAdResponse*)p = *(ns2__getAgentScrollAdResponse*)q;
}

void ns2__getAgentScrollAd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getAgentScrollAd::uid = NULL;
	this->ns2__getAgentScrollAd::msgid = NULL;
	/* transient soap skipped */
}

void ns2__getAgentScrollAd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getAgentScrollAd::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getAgentScrollAd::msgid);
	/* transient soap skipped */
}

int ns2__getAgentScrollAd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getAgentScrollAd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getAgentScrollAd(struct soap *soap, const char *tag, int id, const ns2__getAgentScrollAd *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getAgentScrollAd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getAgentScrollAd::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msgid", -1, &(a->ns2__getAgentScrollAd::msgid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getAgentScrollAd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getAgentScrollAd(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getAgentScrollAd * SOAP_FMAC4 soap_in_ns2__getAgentScrollAd(struct soap *soap, const char *tag, ns2__getAgentScrollAd *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getAgentScrollAd *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getAgentScrollAd, sizeof(ns2__getAgentScrollAd), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getAgentScrollAd)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getAgentScrollAd *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_msgid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getAgentScrollAd::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_msgid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msgid", &(a->ns2__getAgentScrollAd::msgid), "xsd:string"))
				{	soap_flag_msgid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getAgentScrollAd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getAgentScrollAd, 0, sizeof(ns2__getAgentScrollAd), 0, soap_copy_ns2__getAgentScrollAd);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getAgentScrollAd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getAgentScrollAd);
	if (this->soap_out(soap, tag?tag:"ns2:getAgentScrollAd", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getAgentScrollAd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getAgentScrollAd(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getAgentScrollAd * SOAP_FMAC4 soap_get_ns2__getAgentScrollAd(struct soap *soap, ns2__getAgentScrollAd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getAgentScrollAd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getAgentScrollAd * SOAP_FMAC2 soap_instantiate_ns2__getAgentScrollAd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getAgentScrollAd(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getAgentScrollAd, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAgentScrollAd);
		if (size)
			*size = sizeof(ns2__getAgentScrollAd);
		((ns2__getAgentScrollAd*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getAgentScrollAd[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getAgentScrollAd);
		for (int i = 0; i < n; i++)
			((ns2__getAgentScrollAd*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getAgentScrollAd*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getAgentScrollAd(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getAgentScrollAd %p -> %p\n", q, p));
	*(ns2__getAgentScrollAd*)p = *(ns2__getAgentScrollAd*)q;
}

void ns2__getSystemScrollAdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getSystemScrollAdResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__getSystemScrollAdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSystemScrollAdResponse::return_);
	/* transient soap skipped */
}

int ns2__getSystemScrollAdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSystemScrollAdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSystemScrollAdResponse(struct soap *soap, const char *tag, int id, const ns2__getSystemScrollAdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSystemScrollAdResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__getSystemScrollAdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSystemScrollAdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSystemScrollAdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSystemScrollAdResponse * SOAP_FMAC4 soap_in_ns2__getSystemScrollAdResponse(struct soap *soap, const char *tag, ns2__getSystemScrollAdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSystemScrollAdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSystemScrollAdResponse, sizeof(ns2__getSystemScrollAdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSystemScrollAdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSystemScrollAdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__getSystemScrollAdResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSystemScrollAdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSystemScrollAdResponse, 0, sizeof(ns2__getSystemScrollAdResponse), 0, soap_copy_ns2__getSystemScrollAdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getSystemScrollAdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSystemScrollAdResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getSystemScrollAdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSystemScrollAdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSystemScrollAdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSystemScrollAdResponse * SOAP_FMAC4 soap_get_ns2__getSystemScrollAdResponse(struct soap *soap, ns2__getSystemScrollAdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSystemScrollAdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSystemScrollAdResponse * SOAP_FMAC2 soap_instantiate_ns2__getSystemScrollAdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSystemScrollAdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSystemScrollAdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSystemScrollAdResponse);
		if (size)
			*size = sizeof(ns2__getSystemScrollAdResponse);
		((ns2__getSystemScrollAdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSystemScrollAdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSystemScrollAdResponse);
		for (int i = 0; i < n; i++)
			((ns2__getSystemScrollAdResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSystemScrollAdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSystemScrollAdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSystemScrollAdResponse %p -> %p\n", q, p));
	*(ns2__getSystemScrollAdResponse*)p = *(ns2__getSystemScrollAdResponse*)q;
}

void ns2__getSystemScrollAd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getSystemScrollAd::uid = NULL;
	this->ns2__getSystemScrollAd::msgid = NULL;
	/* transient soap skipped */
}

void ns2__getSystemScrollAd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSystemScrollAd::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSystemScrollAd::msgid);
	/* transient soap skipped */
}

int ns2__getSystemScrollAd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSystemScrollAd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSystemScrollAd(struct soap *soap, const char *tag, int id, const ns2__getSystemScrollAd *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSystemScrollAd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getSystemScrollAd::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msgid", -1, &(a->ns2__getSystemScrollAd::msgid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSystemScrollAd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSystemScrollAd(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSystemScrollAd * SOAP_FMAC4 soap_in_ns2__getSystemScrollAd(struct soap *soap, const char *tag, ns2__getSystemScrollAd *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSystemScrollAd *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSystemScrollAd, sizeof(ns2__getSystemScrollAd), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSystemScrollAd)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSystemScrollAd *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_msgid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getSystemScrollAd::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_msgid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msgid", &(a->ns2__getSystemScrollAd::msgid), "xsd:string"))
				{	soap_flag_msgid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSystemScrollAd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSystemScrollAd, 0, sizeof(ns2__getSystemScrollAd), 0, soap_copy_ns2__getSystemScrollAd);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getSystemScrollAd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSystemScrollAd);
	if (this->soap_out(soap, tag?tag:"ns2:getSystemScrollAd", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSystemScrollAd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSystemScrollAd(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSystemScrollAd * SOAP_FMAC4 soap_get_ns2__getSystemScrollAd(struct soap *soap, ns2__getSystemScrollAd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSystemScrollAd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSystemScrollAd * SOAP_FMAC2 soap_instantiate_ns2__getSystemScrollAd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSystemScrollAd(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSystemScrollAd, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSystemScrollAd);
		if (size)
			*size = sizeof(ns2__getSystemScrollAd);
		((ns2__getSystemScrollAd*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSystemScrollAd[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSystemScrollAd);
		for (int i = 0; i < n; i++)
			((ns2__getSystemScrollAd*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSystemScrollAd*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSystemScrollAd(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSystemScrollAd %p -> %p\n", q, p));
	*(ns2__getSystemScrollAd*)p = *(ns2__getSystemScrollAd*)q;
}

void ns2__getMyGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getMyGoodsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getMyGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getMyGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getMyGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMyGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMyGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getMyGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMyGoodsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getMyGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getMyGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getMyGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMyGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__getMyGoodsInfResponse(struct soap *soap, const char *tag, ns2__getMyGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMyGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMyGoodsInfResponse, sizeof(ns2__getMyGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getMyGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getMyGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getMyGoodsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMyGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMyGoodsInfResponse, 0, sizeof(ns2__getMyGoodsInfResponse), 0, soap_copy_ns2__getMyGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getMyGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getMyGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getMyGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMyGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMyGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMyGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__getMyGoodsInfResponse(struct soap *soap, ns2__getMyGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMyGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getMyGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getMyGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMyGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMyGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__getMyGoodsInfResponse);
		((ns2__getMyGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getMyGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getMyGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getMyGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMyGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getMyGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__getMyGoodsInfResponse*)p = *(ns2__getMyGoodsInfResponse*)q;
}

void ns2__getMyGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getMyGoodsInf::uid = NULL;
	soap_default_int(soap, &this->ns2__getMyGoodsInf::record);
	soap_default_int(soap, &this->ns2__getMyGoodsInf::curpage);
	/* transient soap skipped */
}

void ns2__getMyGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getMyGoodsInf::uid);
	/* transient soap skipped */
}

int ns2__getMyGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMyGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMyGoodsInf(struct soap *soap, const char *tag, int id, const ns2__getMyGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMyGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getMyGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getMyGoodsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getMyGoodsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getMyGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getMyGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMyGoodsInf * SOAP_FMAC4 soap_in_ns2__getMyGoodsInf(struct soap *soap, const char *tag, ns2__getMyGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMyGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMyGoodsInf, sizeof(ns2__getMyGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getMyGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getMyGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getMyGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getMyGoodsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getMyGoodsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMyGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMyGoodsInf, 0, sizeof(ns2__getMyGoodsInf), 0, soap_copy_ns2__getMyGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getMyGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getMyGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getMyGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMyGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMyGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMyGoodsInf * SOAP_FMAC4 soap_get_ns2__getMyGoodsInf(struct soap *soap, ns2__getMyGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMyGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getMyGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__getMyGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMyGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMyGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyGoodsInf);
		if (size)
			*size = sizeof(ns2__getMyGoodsInf);
		((ns2__getMyGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getMyGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__getMyGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getMyGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMyGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getMyGoodsInf %p -> %p\n", q, p));
	*(ns2__getMyGoodsInf*)p = *(ns2__getMyGoodsInf*)q;
}

void ns2__getSearchGoodsInfNewResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchGoodsInfNewResponse::return_);
	/* transient soap skipped */
}

void ns2__getSearchGoodsInfNewResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchGoodsInfNewResponse::return_);
	/* transient soap skipped */
}

int ns2__getSearchGoodsInfNewResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchGoodsInfNewResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchGoodsInfNewResponse(struct soap *soap, const char *tag, int id, const ns2__getSearchGoodsInfNewResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchGoodsInfNewResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getSearchGoodsInfNewResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchGoodsInfNewResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchGoodsInfNewResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInfNewResponse * SOAP_FMAC4 soap_in_ns2__getSearchGoodsInfNewResponse(struct soap *soap, const char *tag, ns2__getSearchGoodsInfNewResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchGoodsInfNewResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchGoodsInfNewResponse, sizeof(ns2__getSearchGoodsInfNewResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchGoodsInfNewResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchGoodsInfNewResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getSearchGoodsInfNewResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchGoodsInfNewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchGoodsInfNewResponse, 0, sizeof(ns2__getSearchGoodsInfNewResponse), 0, soap_copy_ns2__getSearchGoodsInfNewResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getSearchGoodsInfNewResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchGoodsInfNewResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchGoodsInfNewResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchGoodsInfNewResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchGoodsInfNewResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInfNewResponse * SOAP_FMAC4 soap_get_ns2__getSearchGoodsInfNewResponse(struct soap *soap, ns2__getSearchGoodsInfNewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchGoodsInfNewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchGoodsInfNewResponse * SOAP_FMAC2 soap_instantiate_ns2__getSearchGoodsInfNewResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchGoodsInfNewResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchGoodsInfNewResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchGoodsInfNewResponse);
		if (size)
			*size = sizeof(ns2__getSearchGoodsInfNewResponse);
		((ns2__getSearchGoodsInfNewResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchGoodsInfNewResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchGoodsInfNewResponse);
		for (int i = 0; i < n; i++)
			((ns2__getSearchGoodsInfNewResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchGoodsInfNewResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchGoodsInfNewResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchGoodsInfNewResponse %p -> %p\n", q, p));
	*(ns2__getSearchGoodsInfNewResponse*)p = *(ns2__getSearchGoodsInfNewResponse*)q;
}

void ns2__getSearchGoodsInfNew::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getSearchGoodsInfNew::uid = NULL;
	this->ns2__getSearchGoodsInfNew::input = NULL;
	soap_default_int(soap, &this->ns2__getSearchGoodsInfNew::record);
	soap_default_int(soap, &this->ns2__getSearchGoodsInfNew::curpage);
	/* transient soap skipped */
}

void ns2__getSearchGoodsInfNew::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchGoodsInfNew::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchGoodsInfNew::input);
	/* transient soap skipped */
}

int ns2__getSearchGoodsInfNew::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchGoodsInfNew(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchGoodsInfNew(struct soap *soap, const char *tag, int id, const ns2__getSearchGoodsInfNew *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchGoodsInfNew), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getSearchGoodsInfNew::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__getSearchGoodsInfNew::input), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getSearchGoodsInfNew::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getSearchGoodsInfNew::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchGoodsInfNew::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchGoodsInfNew(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInfNew * SOAP_FMAC4 soap_in_ns2__getSearchGoodsInfNew(struct soap *soap, const char *tag, ns2__getSearchGoodsInfNew *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchGoodsInfNew *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchGoodsInfNew, sizeof(ns2__getSearchGoodsInfNew), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchGoodsInfNew)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchGoodsInfNew *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getSearchGoodsInfNew::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__getSearchGoodsInfNew::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getSearchGoodsInfNew::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getSearchGoodsInfNew::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchGoodsInfNew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchGoodsInfNew, 0, sizeof(ns2__getSearchGoodsInfNew), 0, soap_copy_ns2__getSearchGoodsInfNew);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getSearchGoodsInfNew::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchGoodsInfNew);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchGoodsInfNew", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchGoodsInfNew::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchGoodsInfNew(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInfNew * SOAP_FMAC4 soap_get_ns2__getSearchGoodsInfNew(struct soap *soap, ns2__getSearchGoodsInfNew *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchGoodsInfNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchGoodsInfNew * SOAP_FMAC2 soap_instantiate_ns2__getSearchGoodsInfNew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchGoodsInfNew(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchGoodsInfNew, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchGoodsInfNew);
		if (size)
			*size = sizeof(ns2__getSearchGoodsInfNew);
		((ns2__getSearchGoodsInfNew*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchGoodsInfNew[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchGoodsInfNew);
		for (int i = 0; i < n; i++)
			((ns2__getSearchGoodsInfNew*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchGoodsInfNew*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchGoodsInfNew(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchGoodsInfNew %p -> %p\n", q, p));
	*(ns2__getSearchGoodsInfNew*)p = *(ns2__getSearchGoodsInfNew*)q;
}

void ns2__getSearchGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchGoodsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getSearchGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getSearchGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getSearchGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchGoodsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getSearchGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__getSearchGoodsInfResponse(struct soap *soap, const char *tag, ns2__getSearchGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchGoodsInfResponse, sizeof(ns2__getSearchGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getSearchGoodsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchGoodsInfResponse, 0, sizeof(ns2__getSearchGoodsInfResponse), 0, soap_copy_ns2__getSearchGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getSearchGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__getSearchGoodsInfResponse(struct soap *soap, ns2__getSearchGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getSearchGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__getSearchGoodsInfResponse);
		((ns2__getSearchGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getSearchGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__getSearchGoodsInfResponse*)p = *(ns2__getSearchGoodsInfResponse*)q;
}

void ns2__getSearchGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getSearchGoodsInf::uid = NULL;
	this->ns2__getSearchGoodsInf::input = NULL;
	soap_default_int(soap, &this->ns2__getSearchGoodsInf::record);
	soap_default_int(soap, &this->ns2__getSearchGoodsInf::curpage);
	/* transient soap skipped */
}

void ns2__getSearchGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchGoodsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchGoodsInf::input);
	/* transient soap skipped */
}

int ns2__getSearchGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchGoodsInf(struct soap *soap, const char *tag, int id, const ns2__getSearchGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getSearchGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__getSearchGoodsInf::input), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getSearchGoodsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getSearchGoodsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInf * SOAP_FMAC4 soap_in_ns2__getSearchGoodsInf(struct soap *soap, const char *tag, ns2__getSearchGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchGoodsInf, sizeof(ns2__getSearchGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getSearchGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__getSearchGoodsInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getSearchGoodsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getSearchGoodsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchGoodsInf, 0, sizeof(ns2__getSearchGoodsInf), 0, soap_copy_ns2__getSearchGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getSearchGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInf * SOAP_FMAC4 soap_get_ns2__getSearchGoodsInf(struct soap *soap, ns2__getSearchGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__getSearchGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchGoodsInf);
		if (size)
			*size = sizeof(ns2__getSearchGoodsInf);
		((ns2__getSearchGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__getSearchGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchGoodsInf %p -> %p\n", q, p));
	*(ns2__getSearchGoodsInf*)p = *(ns2__getSearchGoodsInf*)q;
}

void ns2__delGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__delGoodsInfResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__delGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__delGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__delGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__delGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__delGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__delGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__delGoodsInfResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__delGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__delGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__delGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__delGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__delGoodsInfResponse(struct soap *soap, const char *tag, ns2__delGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__delGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__delGoodsInfResponse, sizeof(ns2__delGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__delGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__delGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__delGoodsInfResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__delGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__delGoodsInfResponse, 0, sizeof(ns2__delGoodsInfResponse), 0, soap_copy_ns2__delGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__delGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__delGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:delGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__delGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__delGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__delGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__delGoodsInfResponse(struct soap *soap, ns2__delGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__delGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__delGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__delGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__delGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__delGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__delGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__delGoodsInfResponse);
		((ns2__delGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__delGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__delGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__delGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__delGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__delGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__delGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__delGoodsInfResponse*)p = *(ns2__delGoodsInfResponse*)q;
}

void ns2__delGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__delGoodsInf::uid = NULL;
	this->ns2__delGoodsInf::recordID = NULL;
	/* transient soap skipped */
}

void ns2__delGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__delGoodsInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__delGoodsInf::recordID);
	/* transient soap skipped */
}

int ns2__delGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__delGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__delGoodsInf(struct soap *soap, const char *tag, int id, const ns2__delGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__delGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__delGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "recordID", -1, &(a->ns2__delGoodsInf::recordID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__delGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__delGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__delGoodsInf * SOAP_FMAC4 soap_in_ns2__delGoodsInf(struct soap *soap, const char *tag, ns2__delGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__delGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__delGoodsInf, sizeof(ns2__delGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__delGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__delGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_recordID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__delGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_recordID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "recordID", &(a->ns2__delGoodsInf::recordID), "xsd:string"))
				{	soap_flag_recordID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__delGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__delGoodsInf, 0, sizeof(ns2__delGoodsInf), 0, soap_copy_ns2__delGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__delGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__delGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:delGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__delGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__delGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__delGoodsInf * SOAP_FMAC4 soap_get_ns2__delGoodsInf(struct soap *soap, ns2__delGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__delGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__delGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__delGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__delGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__delGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__delGoodsInf);
		if (size)
			*size = sizeof(ns2__delGoodsInf);
		((ns2__delGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__delGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__delGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__delGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__delGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__delGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__delGoodsInf %p -> %p\n", q, p));
	*(ns2__delGoodsInf*)p = *(ns2__delGoodsInf*)q;
}

void ns2__getCustomCarsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getCustomCarsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getCustomCarsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getCustomCarsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getCustomCarsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getCustomCarsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getCustomCarsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getCustomCarsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getCustomCarsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getCustomCarsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getCustomCarsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getCustomCarsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getCustomCarsInfResponse * SOAP_FMAC4 soap_in_ns2__getCustomCarsInfResponse(struct soap *soap, const char *tag, ns2__getCustomCarsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getCustomCarsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getCustomCarsInfResponse, sizeof(ns2__getCustomCarsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getCustomCarsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getCustomCarsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getCustomCarsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getCustomCarsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getCustomCarsInfResponse, 0, sizeof(ns2__getCustomCarsInfResponse), 0, soap_copy_ns2__getCustomCarsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getCustomCarsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getCustomCarsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getCustomCarsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getCustomCarsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getCustomCarsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getCustomCarsInfResponse * SOAP_FMAC4 soap_get_ns2__getCustomCarsInfResponse(struct soap *soap, ns2__getCustomCarsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getCustomCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getCustomCarsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getCustomCarsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getCustomCarsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getCustomCarsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getCustomCarsInfResponse);
		if (size)
			*size = sizeof(ns2__getCustomCarsInfResponse);
		((ns2__getCustomCarsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getCustomCarsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getCustomCarsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getCustomCarsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getCustomCarsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getCustomCarsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getCustomCarsInfResponse %p -> %p\n", q, p));
	*(ns2__getCustomCarsInfResponse*)p = *(ns2__getCustomCarsInfResponse*)q;
}

void ns2__getCustomCarsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getCustomCarsInf::uid = NULL;
	soap_default_int(soap, &this->ns2__getCustomCarsInf::customid);
	soap_default_int(soap, &this->ns2__getCustomCarsInf::record);
	soap_default_int(soap, &this->ns2__getCustomCarsInf::curpage);
	/* transient soap skipped */
}

void ns2__getCustomCarsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getCustomCarsInf::uid);
	/* transient soap skipped */
}

int ns2__getCustomCarsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getCustomCarsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getCustomCarsInf(struct soap *soap, const char *tag, int id, const ns2__getCustomCarsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getCustomCarsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getCustomCarsInf::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "customid", -1, &(a->ns2__getCustomCarsInf::customid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getCustomCarsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getCustomCarsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getCustomCarsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getCustomCarsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getCustomCarsInf * SOAP_FMAC4 soap_in_ns2__getCustomCarsInf(struct soap *soap, const char *tag, ns2__getCustomCarsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getCustomCarsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getCustomCarsInf, sizeof(ns2__getCustomCarsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getCustomCarsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getCustomCarsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_customid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getCustomCarsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_customid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "customid", &(a->ns2__getCustomCarsInf::customid), "xsd:int"))
				{	soap_flag_customid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getCustomCarsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getCustomCarsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getCustomCarsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getCustomCarsInf, 0, sizeof(ns2__getCustomCarsInf), 0, soap_copy_ns2__getCustomCarsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_customid1 > 0 || soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getCustomCarsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getCustomCarsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getCustomCarsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getCustomCarsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getCustomCarsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getCustomCarsInf * SOAP_FMAC4 soap_get_ns2__getCustomCarsInf(struct soap *soap, ns2__getCustomCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getCustomCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getCustomCarsInf * SOAP_FMAC2 soap_instantiate_ns2__getCustomCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getCustomCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getCustomCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getCustomCarsInf);
		if (size)
			*size = sizeof(ns2__getCustomCarsInf);
		((ns2__getCustomCarsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getCustomCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getCustomCarsInf);
		for (int i = 0; i < n; i++)
			((ns2__getCustomCarsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getCustomCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getCustomCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getCustomCarsInf %p -> %p\n", q, p));
	*(ns2__getCustomCarsInf*)p = *(ns2__getCustomCarsInf*)q;
}

void ns2__setGoodsStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setGoodsStatusResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__setGoodsStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setGoodsStatusResponse::return_);
	/* transient soap skipped */
}

int ns2__setGoodsStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setGoodsStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setGoodsStatusResponse(struct soap *soap, const char *tag, int id, const ns2__setGoodsStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setGoodsStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__setGoodsStatusResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setGoodsStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setGoodsStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setGoodsStatusResponse * SOAP_FMAC4 soap_in_ns2__setGoodsStatusResponse(struct soap *soap, const char *tag, ns2__setGoodsStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setGoodsStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setGoodsStatusResponse, sizeof(ns2__setGoodsStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setGoodsStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setGoodsStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__setGoodsStatusResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setGoodsStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setGoodsStatusResponse, 0, sizeof(ns2__setGoodsStatusResponse), 0, soap_copy_ns2__setGoodsStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setGoodsStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setGoodsStatusResponse);
	if (this->soap_out(soap, tag?tag:"ns2:setGoodsStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setGoodsStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setGoodsStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setGoodsStatusResponse * SOAP_FMAC4 soap_get_ns2__setGoodsStatusResponse(struct soap *soap, ns2__setGoodsStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setGoodsStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setGoodsStatusResponse * SOAP_FMAC2 soap_instantiate_ns2__setGoodsStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setGoodsStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setGoodsStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setGoodsStatusResponse);
		if (size)
			*size = sizeof(ns2__setGoodsStatusResponse);
		((ns2__setGoodsStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setGoodsStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setGoodsStatusResponse);
		for (int i = 0; i < n; i++)
			((ns2__setGoodsStatusResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setGoodsStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setGoodsStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setGoodsStatusResponse %p -> %p\n", q, p));
	*(ns2__setGoodsStatusResponse*)p = *(ns2__setGoodsStatusResponse*)q;
}

void ns2__setGoodsStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setGoodsStatus::uid = NULL;
	this->ns2__setGoodsStatus::gid = NULL;
	this->ns2__setGoodsStatus::status = NULL;
	/* transient soap skipped */
}

void ns2__setGoodsStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setGoodsStatus::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__setGoodsStatus::gid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__setGoodsStatus::status);
	/* transient soap skipped */
}

int ns2__setGoodsStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setGoodsStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setGoodsStatus(struct soap *soap, const char *tag, int id, const ns2__setGoodsStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setGoodsStatus), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__setGoodsStatus::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "gid", -1, &(a->ns2__setGoodsStatus::gid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "status", -1, &(a->ns2__setGoodsStatus::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setGoodsStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setGoodsStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setGoodsStatus * SOAP_FMAC4 soap_in_ns2__setGoodsStatus(struct soap *soap, const char *tag, ns2__setGoodsStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setGoodsStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setGoodsStatus, sizeof(ns2__setGoodsStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setGoodsStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setGoodsStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_gid1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__setGoodsStatus::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_gid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "gid", &(a->ns2__setGoodsStatus::gid), "xsd:string"))
				{	soap_flag_gid1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "status", &(a->ns2__setGoodsStatus::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setGoodsStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setGoodsStatus, 0, sizeof(ns2__setGoodsStatus), 0, soap_copy_ns2__setGoodsStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setGoodsStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setGoodsStatus);
	if (this->soap_out(soap, tag?tag:"ns2:setGoodsStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setGoodsStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setGoodsStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setGoodsStatus * SOAP_FMAC4 soap_get_ns2__setGoodsStatus(struct soap *soap, ns2__setGoodsStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setGoodsStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setGoodsStatus * SOAP_FMAC2 soap_instantiate_ns2__setGoodsStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setGoodsStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setGoodsStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setGoodsStatus);
		if (size)
			*size = sizeof(ns2__setGoodsStatus);
		((ns2__setGoodsStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setGoodsStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setGoodsStatus);
		for (int i = 0; i < n; i++)
			((ns2__setGoodsStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setGoodsStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setGoodsStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setGoodsStatus %p -> %p\n", q, p));
	*(ns2__setGoodsStatus*)p = *(ns2__setGoodsStatus*)q;
}

void ns2__getClickServiceStationInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getClickServiceStationInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getClickServiceStationInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getClickServiceStationInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getClickServiceStationInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClickServiceStationInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClickServiceStationInfResponse(struct soap *soap, const char *tag, int id, const ns2__getClickServiceStationInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClickServiceStationInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getClickServiceStationInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getClickServiceStationInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getClickServiceStationInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClickServiceStationInfResponse * SOAP_FMAC4 soap_in_ns2__getClickServiceStationInfResponse(struct soap *soap, const char *tag, ns2__getClickServiceStationInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClickServiceStationInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClickServiceStationInfResponse, sizeof(ns2__getClickServiceStationInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getClickServiceStationInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getClickServiceStationInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getClickServiceStationInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClickServiceStationInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClickServiceStationInfResponse, 0, sizeof(ns2__getClickServiceStationInfResponse), 0, soap_copy_ns2__getClickServiceStationInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getClickServiceStationInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getClickServiceStationInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getClickServiceStationInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClickServiceStationInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClickServiceStationInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClickServiceStationInfResponse * SOAP_FMAC4 soap_get_ns2__getClickServiceStationInfResponse(struct soap *soap, ns2__getClickServiceStationInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClickServiceStationInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getClickServiceStationInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getClickServiceStationInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClickServiceStationInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getClickServiceStationInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickServiceStationInfResponse);
		if (size)
			*size = sizeof(ns2__getClickServiceStationInfResponse);
		((ns2__getClickServiceStationInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickServiceStationInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getClickServiceStationInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getClickServiceStationInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getClickServiceStationInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getClickServiceStationInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getClickServiceStationInfResponse %p -> %p\n", q, p));
	*(ns2__getClickServiceStationInfResponse*)p = *(ns2__getClickServiceStationInfResponse*)q;
}

void ns2__getClickServiceStationInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getClickServiceStationInf::uid = NULL;
	this->ns2__getClickServiceStationInf::input = NULL;
	soap_default_int(soap, &this->ns2__getClickServiceStationInf::record);
	soap_default_int(soap, &this->ns2__getClickServiceStationInf::curpage);
	/* transient soap skipped */
}

void ns2__getClickServiceStationInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClickServiceStationInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClickServiceStationInf::input);
	/* transient soap skipped */
}

int ns2__getClickServiceStationInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClickServiceStationInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClickServiceStationInf(struct soap *soap, const char *tag, int id, const ns2__getClickServiceStationInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClickServiceStationInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getClickServiceStationInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__getClickServiceStationInf::input), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getClickServiceStationInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getClickServiceStationInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getClickServiceStationInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getClickServiceStationInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClickServiceStationInf * SOAP_FMAC4 soap_in_ns2__getClickServiceStationInf(struct soap *soap, const char *tag, ns2__getClickServiceStationInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClickServiceStationInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClickServiceStationInf, sizeof(ns2__getClickServiceStationInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getClickServiceStationInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getClickServiceStationInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getClickServiceStationInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__getClickServiceStationInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getClickServiceStationInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getClickServiceStationInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClickServiceStationInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClickServiceStationInf, 0, sizeof(ns2__getClickServiceStationInf), 0, soap_copy_ns2__getClickServiceStationInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getClickServiceStationInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getClickServiceStationInf);
	if (this->soap_out(soap, tag?tag:"ns2:getClickServiceStationInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClickServiceStationInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClickServiceStationInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClickServiceStationInf * SOAP_FMAC4 soap_get_ns2__getClickServiceStationInf(struct soap *soap, ns2__getClickServiceStationInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClickServiceStationInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getClickServiceStationInf * SOAP_FMAC2 soap_instantiate_ns2__getClickServiceStationInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClickServiceStationInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getClickServiceStationInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickServiceStationInf);
		if (size)
			*size = sizeof(ns2__getClickServiceStationInf);
		((ns2__getClickServiceStationInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getClickServiceStationInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getClickServiceStationInf);
		for (int i = 0; i < n; i++)
			((ns2__getClickServiceStationInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getClickServiceStationInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getClickServiceStationInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getClickServiceStationInf %p -> %p\n", q, p));
	*(ns2__getClickServiceStationInf*)p = *(ns2__getClickServiceStationInf*)q;
}

void ns2__getSearchSpecialLineInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchSpecialLineInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getSearchSpecialLineInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getSearchSpecialLineInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getSearchSpecialLineInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchSpecialLineInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchSpecialLineInfResponse(struct soap *soap, const char *tag, int id, const ns2__getSearchSpecialLineInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchSpecialLineInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getSearchSpecialLineInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchSpecialLineInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchSpecialLineInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchSpecialLineInfResponse * SOAP_FMAC4 soap_in_ns2__getSearchSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__getSearchSpecialLineInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchSpecialLineInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchSpecialLineInfResponse, sizeof(ns2__getSearchSpecialLineInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchSpecialLineInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchSpecialLineInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getSearchSpecialLineInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchSpecialLineInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchSpecialLineInfResponse, 0, sizeof(ns2__getSearchSpecialLineInfResponse), 0, soap_copy_ns2__getSearchSpecialLineInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getSearchSpecialLineInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchSpecialLineInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchSpecialLineInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchSpecialLineInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchSpecialLineInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchSpecialLineInfResponse * SOAP_FMAC4 soap_get_ns2__getSearchSpecialLineInfResponse(struct soap *soap, ns2__getSearchSpecialLineInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchSpecialLineInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getSearchSpecialLineInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchSpecialLineInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchSpecialLineInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchSpecialLineInfResponse);
		if (size)
			*size = sizeof(ns2__getSearchSpecialLineInfResponse);
		((ns2__getSearchSpecialLineInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchSpecialLineInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchSpecialLineInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getSearchSpecialLineInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchSpecialLineInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchSpecialLineInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchSpecialLineInfResponse %p -> %p\n", q, p));
	*(ns2__getSearchSpecialLineInfResponse*)p = *(ns2__getSearchSpecialLineInfResponse*)q;
}

void ns2__getSearchSpecialLineInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getSearchSpecialLineInf::uid = NULL;
	this->ns2__getSearchSpecialLineInf::input = NULL;
	soap_default_int(soap, &this->ns2__getSearchSpecialLineInf::record);
	soap_default_int(soap, &this->ns2__getSearchSpecialLineInf::curpage);
	/* transient soap skipped */
}

void ns2__getSearchSpecialLineInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchSpecialLineInf::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getSearchSpecialLineInf::input);
	/* transient soap skipped */
}

int ns2__getSearchSpecialLineInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getSearchSpecialLineInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSearchSpecialLineInf(struct soap *soap, const char *tag, int id, const ns2__getSearchSpecialLineInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSearchSpecialLineInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getSearchSpecialLineInf::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "input", -1, &(a->ns2__getSearchSpecialLineInf::input), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getSearchSpecialLineInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getSearchSpecialLineInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getSearchSpecialLineInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getSearchSpecialLineInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getSearchSpecialLineInf * SOAP_FMAC4 soap_in_ns2__getSearchSpecialLineInf(struct soap *soap, const char *tag, ns2__getSearchSpecialLineInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getSearchSpecialLineInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSearchSpecialLineInf, sizeof(ns2__getSearchSpecialLineInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getSearchSpecialLineInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getSearchSpecialLineInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getSearchSpecialLineInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_input1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "input", &(a->ns2__getSearchSpecialLineInf::input), "xsd:string"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getSearchSpecialLineInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getSearchSpecialLineInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getSearchSpecialLineInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSearchSpecialLineInf, 0, sizeof(ns2__getSearchSpecialLineInf), 0, soap_copy_ns2__getSearchSpecialLineInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getSearchSpecialLineInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getSearchSpecialLineInf);
	if (this->soap_out(soap, tag?tag:"ns2:getSearchSpecialLineInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getSearchSpecialLineInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getSearchSpecialLineInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getSearchSpecialLineInf * SOAP_FMAC4 soap_get_ns2__getSearchSpecialLineInf(struct soap *soap, ns2__getSearchSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSearchSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getSearchSpecialLineInf * SOAP_FMAC2 soap_instantiate_ns2__getSearchSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSearchSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSearchSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchSpecialLineInf);
		if (size)
			*size = sizeof(ns2__getSearchSpecialLineInf);
		((ns2__getSearchSpecialLineInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getSearchSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getSearchSpecialLineInf);
		for (int i = 0; i < n; i++)
			((ns2__getSearchSpecialLineInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getSearchSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSearchSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getSearchSpecialLineInf %p -> %p\n", q, p));
	*(ns2__getSearchSpecialLineInf*)p = *(ns2__getSearchSpecialLineInf*)q;
}

void ns2__setCarsStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setCarsStatusResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__setCarsStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setCarsStatusResponse::return_);
	/* transient soap skipped */
}

int ns2__setCarsStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setCarsStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setCarsStatusResponse(struct soap *soap, const char *tag, int id, const ns2__setCarsStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setCarsStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__setCarsStatusResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setCarsStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setCarsStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setCarsStatusResponse * SOAP_FMAC4 soap_in_ns2__setCarsStatusResponse(struct soap *soap, const char *tag, ns2__setCarsStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setCarsStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setCarsStatusResponse, sizeof(ns2__setCarsStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setCarsStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setCarsStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__setCarsStatusResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setCarsStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setCarsStatusResponse, 0, sizeof(ns2__setCarsStatusResponse), 0, soap_copy_ns2__setCarsStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setCarsStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setCarsStatusResponse);
	if (this->soap_out(soap, tag?tag:"ns2:setCarsStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setCarsStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setCarsStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setCarsStatusResponse * SOAP_FMAC4 soap_get_ns2__setCarsStatusResponse(struct soap *soap, ns2__setCarsStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setCarsStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setCarsStatusResponse * SOAP_FMAC2 soap_instantiate_ns2__setCarsStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setCarsStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setCarsStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setCarsStatusResponse);
		if (size)
			*size = sizeof(ns2__setCarsStatusResponse);
		((ns2__setCarsStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setCarsStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setCarsStatusResponse);
		for (int i = 0; i < n; i++)
			((ns2__setCarsStatusResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setCarsStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setCarsStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setCarsStatusResponse %p -> %p\n", q, p));
	*(ns2__setCarsStatusResponse*)p = *(ns2__setCarsStatusResponse*)q;
}

void ns2__setCarsStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setCarsStatus::uid = NULL;
	this->ns2__setCarsStatus::cid = NULL;
	this->ns2__setCarsStatus::status = NULL;
	/* transient soap skipped */
}

void ns2__setCarsStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__setCarsStatus::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__setCarsStatus::cid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__setCarsStatus::status);
	/* transient soap skipped */
}

int ns2__setCarsStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setCarsStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setCarsStatus(struct soap *soap, const char *tag, int id, const ns2__setCarsStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setCarsStatus), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__setCarsStatus::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "cid", -1, &(a->ns2__setCarsStatus::cid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "status", -1, &(a->ns2__setCarsStatus::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setCarsStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setCarsStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setCarsStatus * SOAP_FMAC4 soap_in_ns2__setCarsStatus(struct soap *soap, const char *tag, ns2__setCarsStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setCarsStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setCarsStatus, sizeof(ns2__setCarsStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setCarsStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setCarsStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_cid1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__setCarsStatus::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_cid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "cid", &(a->ns2__setCarsStatus::cid), "xsd:string"))
				{	soap_flag_cid1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "status", &(a->ns2__setCarsStatus::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setCarsStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setCarsStatus, 0, sizeof(ns2__setCarsStatus), 0, soap_copy_ns2__setCarsStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__setCarsStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setCarsStatus);
	if (this->soap_out(soap, tag?tag:"ns2:setCarsStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setCarsStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setCarsStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setCarsStatus * SOAP_FMAC4 soap_get_ns2__setCarsStatus(struct soap *soap, ns2__setCarsStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setCarsStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setCarsStatus * SOAP_FMAC2 soap_instantiate_ns2__setCarsStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setCarsStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setCarsStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setCarsStatus);
		if (size)
			*size = sizeof(ns2__setCarsStatus);
		((ns2__setCarsStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setCarsStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setCarsStatus);
		for (int i = 0; i < n; i++)
			((ns2__setCarsStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setCarsStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setCarsStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setCarsStatus %p -> %p\n", q, p));
	*(ns2__setCarsStatus*)p = *(ns2__setCarsStatus*)q;
}

void ns2__sendPhoneMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__sendPhoneMessageResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__sendPhoneMessageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__sendPhoneMessageResponse::return_);
	/* transient soap skipped */
}

int ns2__sendPhoneMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__sendPhoneMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__sendPhoneMessageResponse(struct soap *soap, const char *tag, int id, const ns2__sendPhoneMessageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__sendPhoneMessageResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__sendPhoneMessageResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__sendPhoneMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__sendPhoneMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__sendPhoneMessageResponse * SOAP_FMAC4 soap_in_ns2__sendPhoneMessageResponse(struct soap *soap, const char *tag, ns2__sendPhoneMessageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__sendPhoneMessageResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__sendPhoneMessageResponse, sizeof(ns2__sendPhoneMessageResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__sendPhoneMessageResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__sendPhoneMessageResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__sendPhoneMessageResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__sendPhoneMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__sendPhoneMessageResponse, 0, sizeof(ns2__sendPhoneMessageResponse), 0, soap_copy_ns2__sendPhoneMessageResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__sendPhoneMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__sendPhoneMessageResponse);
	if (this->soap_out(soap, tag?tag:"ns2:sendPhoneMessageResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__sendPhoneMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__sendPhoneMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__sendPhoneMessageResponse * SOAP_FMAC4 soap_get_ns2__sendPhoneMessageResponse(struct soap *soap, ns2__sendPhoneMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__sendPhoneMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__sendPhoneMessageResponse * SOAP_FMAC2 soap_instantiate_ns2__sendPhoneMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__sendPhoneMessageResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__sendPhoneMessageResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__sendPhoneMessageResponse);
		if (size)
			*size = sizeof(ns2__sendPhoneMessageResponse);
		((ns2__sendPhoneMessageResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__sendPhoneMessageResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__sendPhoneMessageResponse);
		for (int i = 0; i < n; i++)
			((ns2__sendPhoneMessageResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__sendPhoneMessageResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__sendPhoneMessageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__sendPhoneMessageResponse %p -> %p\n", q, p));
	*(ns2__sendPhoneMessageResponse*)p = *(ns2__sendPhoneMessageResponse*)q;
}

void ns2__sendPhoneMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__sendPhoneMessage::uid = NULL;
	this->ns2__sendPhoneMessage::phone = NULL;
	this->ns2__sendPhoneMessage::msg = NULL;
	/* transient soap skipped */
}

void ns2__sendPhoneMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__sendPhoneMessage::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__sendPhoneMessage::phone);
	soap_serialize_PointerTostd__string(soap, &this->ns2__sendPhoneMessage::msg);
	/* transient soap skipped */
}

int ns2__sendPhoneMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__sendPhoneMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__sendPhoneMessage(struct soap *soap, const char *tag, int id, const ns2__sendPhoneMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__sendPhoneMessage), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__sendPhoneMessage::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "phone", -1, &(a->ns2__sendPhoneMessage::phone), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msg", -1, &(a->ns2__sendPhoneMessage::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__sendPhoneMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__sendPhoneMessage(soap, tag, this, type);
}

SOAP_FMAC3 ns2__sendPhoneMessage * SOAP_FMAC4 soap_in_ns2__sendPhoneMessage(struct soap *soap, const char *tag, ns2__sendPhoneMessage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__sendPhoneMessage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__sendPhoneMessage, sizeof(ns2__sendPhoneMessage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__sendPhoneMessage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__sendPhoneMessage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_phone1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__sendPhoneMessage::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "phone", &(a->ns2__sendPhoneMessage::phone), "xsd:string"))
				{	soap_flag_phone1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msg", &(a->ns2__sendPhoneMessage::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__sendPhoneMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__sendPhoneMessage, 0, sizeof(ns2__sendPhoneMessage), 0, soap_copy_ns2__sendPhoneMessage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__sendPhoneMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__sendPhoneMessage);
	if (this->soap_out(soap, tag?tag:"ns2:sendPhoneMessage", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__sendPhoneMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__sendPhoneMessage(soap, this, tag, type);
}

SOAP_FMAC3 ns2__sendPhoneMessage * SOAP_FMAC4 soap_get_ns2__sendPhoneMessage(struct soap *soap, ns2__sendPhoneMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__sendPhoneMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__sendPhoneMessage * SOAP_FMAC2 soap_instantiate_ns2__sendPhoneMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__sendPhoneMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__sendPhoneMessage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__sendPhoneMessage);
		if (size)
			*size = sizeof(ns2__sendPhoneMessage);
		((ns2__sendPhoneMessage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__sendPhoneMessage[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__sendPhoneMessage);
		for (int i = 0; i < n; i++)
			((ns2__sendPhoneMessage*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__sendPhoneMessage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__sendPhoneMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__sendPhoneMessage %p -> %p\n", q, p));
	*(ns2__sendPhoneMessage*)p = *(ns2__sendPhoneMessage*)q;
}

void ns2__getMyCarsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getMyCarsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getMyCarsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getMyCarsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getMyCarsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMyCarsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMyCarsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getMyCarsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMyCarsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getMyCarsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getMyCarsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getMyCarsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMyCarsInfResponse * SOAP_FMAC4 soap_in_ns2__getMyCarsInfResponse(struct soap *soap, const char *tag, ns2__getMyCarsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMyCarsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMyCarsInfResponse, sizeof(ns2__getMyCarsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getMyCarsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getMyCarsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getMyCarsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMyCarsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMyCarsInfResponse, 0, sizeof(ns2__getMyCarsInfResponse), 0, soap_copy_ns2__getMyCarsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getMyCarsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getMyCarsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getMyCarsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMyCarsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMyCarsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMyCarsInfResponse * SOAP_FMAC4 soap_get_ns2__getMyCarsInfResponse(struct soap *soap, ns2__getMyCarsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMyCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getMyCarsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getMyCarsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMyCarsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMyCarsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyCarsInfResponse);
		if (size)
			*size = sizeof(ns2__getMyCarsInfResponse);
		((ns2__getMyCarsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyCarsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getMyCarsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getMyCarsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getMyCarsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMyCarsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getMyCarsInfResponse %p -> %p\n", q, p));
	*(ns2__getMyCarsInfResponse*)p = *(ns2__getMyCarsInfResponse*)q;
}

void ns2__getMyCarsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getMyCarsInf::uid = NULL;
	soap_default_int(soap, &this->ns2__getMyCarsInf::record);
	soap_default_int(soap, &this->ns2__getMyCarsInf::curpage);
	/* transient soap skipped */
}

void ns2__getMyCarsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getMyCarsInf::uid);
	/* transient soap skipped */
}

int ns2__getMyCarsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMyCarsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMyCarsInf(struct soap *soap, const char *tag, int id, const ns2__getMyCarsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMyCarsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getMyCarsInf::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getMyCarsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getMyCarsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getMyCarsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getMyCarsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMyCarsInf * SOAP_FMAC4 soap_in_ns2__getMyCarsInf(struct soap *soap, const char *tag, ns2__getMyCarsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMyCarsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMyCarsInf, sizeof(ns2__getMyCarsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getMyCarsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getMyCarsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getMyCarsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getMyCarsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getMyCarsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMyCarsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMyCarsInf, 0, sizeof(ns2__getMyCarsInf), 0, soap_copy_ns2__getMyCarsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getMyCarsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getMyCarsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getMyCarsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMyCarsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMyCarsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMyCarsInf * SOAP_FMAC4 soap_get_ns2__getMyCarsInf(struct soap *soap, ns2__getMyCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMyCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getMyCarsInf * SOAP_FMAC2 soap_instantiate_ns2__getMyCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMyCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMyCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyCarsInf);
		if (size)
			*size = sizeof(ns2__getMyCarsInf);
		((ns2__getMyCarsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getMyCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getMyCarsInf);
		for (int i = 0; i < n; i++)
			((ns2__getMyCarsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getMyCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMyCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getMyCarsInf %p -> %p\n", q, p));
	*(ns2__getMyCarsInf*)p = *(ns2__getMyCarsInf*)q;
}

void ns2__getFavoriteSpecialLineInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getFavoriteSpecialLineInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getFavoriteSpecialLineInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getFavoriteSpecialLineInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getFavoriteSpecialLineInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getFavoriteSpecialLineInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getFavoriteSpecialLineInfResponse(struct soap *soap, const char *tag, int id, const ns2__getFavoriteSpecialLineInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getFavoriteSpecialLineInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getFavoriteSpecialLineInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getFavoriteSpecialLineInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getFavoriteSpecialLineInfResponse * SOAP_FMAC4 soap_in_ns2__getFavoriteSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__getFavoriteSpecialLineInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getFavoriteSpecialLineInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse, sizeof(ns2__getFavoriteSpecialLineInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getFavoriteSpecialLineInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getFavoriteSpecialLineInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getFavoriteSpecialLineInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse, 0, sizeof(ns2__getFavoriteSpecialLineInfResponse), 0, soap_copy_ns2__getFavoriteSpecialLineInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getFavoriteSpecialLineInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getFavoriteSpecialLineInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getFavoriteSpecialLineInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getFavoriteSpecialLineInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getFavoriteSpecialLineInfResponse * SOAP_FMAC4 soap_get_ns2__getFavoriteSpecialLineInfResponse(struct soap *soap, ns2__getFavoriteSpecialLineInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getFavoriteSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getFavoriteSpecialLineInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getFavoriteSpecialLineInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getFavoriteSpecialLineInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getFavoriteSpecialLineInfResponse);
		if (size)
			*size = sizeof(ns2__getFavoriteSpecialLineInfResponse);
		((ns2__getFavoriteSpecialLineInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getFavoriteSpecialLineInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getFavoriteSpecialLineInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getFavoriteSpecialLineInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getFavoriteSpecialLineInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getFavoriteSpecialLineInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getFavoriteSpecialLineInfResponse %p -> %p\n", q, p));
	*(ns2__getFavoriteSpecialLineInfResponse*)p = *(ns2__getFavoriteSpecialLineInfResponse*)q;
}

void ns2__getFavoriteSpecialLineInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getFavoriteSpecialLineInf::uid = NULL;
	soap_default_int(soap, &this->ns2__getFavoriteSpecialLineInf::record);
	soap_default_int(soap, &this->ns2__getFavoriteSpecialLineInf::curpage);
	/* transient soap skipped */
}

void ns2__getFavoriteSpecialLineInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getFavoriteSpecialLineInf::uid);
	/* transient soap skipped */
}

int ns2__getFavoriteSpecialLineInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getFavoriteSpecialLineInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getFavoriteSpecialLineInf(struct soap *soap, const char *tag, int id, const ns2__getFavoriteSpecialLineInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getFavoriteSpecialLineInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getFavoriteSpecialLineInf::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getFavoriteSpecialLineInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getFavoriteSpecialLineInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getFavoriteSpecialLineInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getFavoriteSpecialLineInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getFavoriteSpecialLineInf * SOAP_FMAC4 soap_in_ns2__getFavoriteSpecialLineInf(struct soap *soap, const char *tag, ns2__getFavoriteSpecialLineInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getFavoriteSpecialLineInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getFavoriteSpecialLineInf, sizeof(ns2__getFavoriteSpecialLineInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getFavoriteSpecialLineInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getFavoriteSpecialLineInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getFavoriteSpecialLineInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getFavoriteSpecialLineInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getFavoriteSpecialLineInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getFavoriteSpecialLineInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getFavoriteSpecialLineInf, 0, sizeof(ns2__getFavoriteSpecialLineInf), 0, soap_copy_ns2__getFavoriteSpecialLineInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getFavoriteSpecialLineInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getFavoriteSpecialLineInf);
	if (this->soap_out(soap, tag?tag:"ns2:getFavoriteSpecialLineInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getFavoriteSpecialLineInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getFavoriteSpecialLineInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getFavoriteSpecialLineInf * SOAP_FMAC4 soap_get_ns2__getFavoriteSpecialLineInf(struct soap *soap, ns2__getFavoriteSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getFavoriteSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getFavoriteSpecialLineInf * SOAP_FMAC2 soap_instantiate_ns2__getFavoriteSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getFavoriteSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getFavoriteSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getFavoriteSpecialLineInf);
		if (size)
			*size = sizeof(ns2__getFavoriteSpecialLineInf);
		((ns2__getFavoriteSpecialLineInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getFavoriteSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getFavoriteSpecialLineInf);
		for (int i = 0; i < n; i++)
			((ns2__getFavoriteSpecialLineInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getFavoriteSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getFavoriteSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getFavoriteSpecialLineInf %p -> %p\n", q, p));
	*(ns2__getFavoriteSpecialLineInf*)p = *(ns2__getFavoriteSpecialLineInf*)q;
}

void ns2__getUserCustomInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getUserCustomInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getUserCustomInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getUserCustomInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getUserCustomInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getUserCustomInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getUserCustomInfResponse(struct soap *soap, const char *tag, int id, const ns2__getUserCustomInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getUserCustomInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getUserCustomInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getUserCustomInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getUserCustomInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getUserCustomInfResponse * SOAP_FMAC4 soap_in_ns2__getUserCustomInfResponse(struct soap *soap, const char *tag, ns2__getUserCustomInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getUserCustomInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getUserCustomInfResponse, sizeof(ns2__getUserCustomInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getUserCustomInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getUserCustomInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getUserCustomInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getUserCustomInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getUserCustomInfResponse, 0, sizeof(ns2__getUserCustomInfResponse), 0, soap_copy_ns2__getUserCustomInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getUserCustomInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getUserCustomInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getUserCustomInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getUserCustomInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getUserCustomInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getUserCustomInfResponse * SOAP_FMAC4 soap_get_ns2__getUserCustomInfResponse(struct soap *soap, ns2__getUserCustomInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getUserCustomInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getUserCustomInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getUserCustomInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getUserCustomInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getUserCustomInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getUserCustomInfResponse);
		if (size)
			*size = sizeof(ns2__getUserCustomInfResponse);
		((ns2__getUserCustomInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getUserCustomInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getUserCustomInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getUserCustomInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getUserCustomInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getUserCustomInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getUserCustomInfResponse %p -> %p\n", q, p));
	*(ns2__getUserCustomInfResponse*)p = *(ns2__getUserCustomInfResponse*)q;
}

void ns2__getUserCustomInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getUserCustomInf::uid = NULL;
	/* transient soap skipped */
}

void ns2__getUserCustomInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getUserCustomInf::uid);
	/* transient soap skipped */
}

int ns2__getUserCustomInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getUserCustomInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getUserCustomInf(struct soap *soap, const char *tag, int id, const ns2__getUserCustomInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getUserCustomInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getUserCustomInf::uid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getUserCustomInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getUserCustomInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getUserCustomInf * SOAP_FMAC4 soap_in_ns2__getUserCustomInf(struct soap *soap, const char *tag, ns2__getUserCustomInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getUserCustomInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getUserCustomInf, sizeof(ns2__getUserCustomInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getUserCustomInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getUserCustomInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getUserCustomInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getUserCustomInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getUserCustomInf, 0, sizeof(ns2__getUserCustomInf), 0, soap_copy_ns2__getUserCustomInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getUserCustomInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getUserCustomInf);
	if (this->soap_out(soap, tag?tag:"ns2:getUserCustomInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getUserCustomInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getUserCustomInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getUserCustomInf * SOAP_FMAC4 soap_get_ns2__getUserCustomInf(struct soap *soap, ns2__getUserCustomInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getUserCustomInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getUserCustomInf * SOAP_FMAC2 soap_instantiate_ns2__getUserCustomInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getUserCustomInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getUserCustomInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getUserCustomInf);
		if (size)
			*size = sizeof(ns2__getUserCustomInf);
		((ns2__getUserCustomInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getUserCustomInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getUserCustomInf);
		for (int i = 0; i < n; i++)
			((ns2__getUserCustomInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getUserCustomInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getUserCustomInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getUserCustomInf %p -> %p\n", q, p));
	*(ns2__getUserCustomInf*)p = *(ns2__getUserCustomInf*)q;
}

void ns2__collectSpecialLineResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__collectSpecialLineResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns2__collectSpecialLineResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__collectSpecialLineResponse::return_);
	/* transient soap skipped */
}

int ns2__collectSpecialLineResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__collectSpecialLineResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__collectSpecialLineResponse(struct soap *soap, const char *tag, int id, const ns2__collectSpecialLineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__collectSpecialLineResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns2__collectSpecialLineResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__collectSpecialLineResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__collectSpecialLineResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__collectSpecialLineResponse * SOAP_FMAC4 soap_in_ns2__collectSpecialLineResponse(struct soap *soap, const char *tag, ns2__collectSpecialLineResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__collectSpecialLineResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__collectSpecialLineResponse, sizeof(ns2__collectSpecialLineResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__collectSpecialLineResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__collectSpecialLineResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns2__collectSpecialLineResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__collectSpecialLineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__collectSpecialLineResponse, 0, sizeof(ns2__collectSpecialLineResponse), 0, soap_copy_ns2__collectSpecialLineResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__collectSpecialLineResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__collectSpecialLineResponse);
	if (this->soap_out(soap, tag?tag:"ns2:collectSpecialLineResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__collectSpecialLineResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__collectSpecialLineResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__collectSpecialLineResponse * SOAP_FMAC4 soap_get_ns2__collectSpecialLineResponse(struct soap *soap, ns2__collectSpecialLineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__collectSpecialLineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__collectSpecialLineResponse * SOAP_FMAC2 soap_instantiate_ns2__collectSpecialLineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__collectSpecialLineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__collectSpecialLineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__collectSpecialLineResponse);
		if (size)
			*size = sizeof(ns2__collectSpecialLineResponse);
		((ns2__collectSpecialLineResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__collectSpecialLineResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__collectSpecialLineResponse);
		for (int i = 0; i < n; i++)
			((ns2__collectSpecialLineResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__collectSpecialLineResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__collectSpecialLineResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__collectSpecialLineResponse %p -> %p\n", q, p));
	*(ns2__collectSpecialLineResponse*)p = *(ns2__collectSpecialLineResponse*)q;
}

void ns2__collectSpecialLine::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__collectSpecialLine::uid = NULL;
	this->ns2__collectSpecialLine::recordID = NULL;
	/* transient soap skipped */
}

void ns2__collectSpecialLine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__collectSpecialLine::uid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__collectSpecialLine::recordID);
	/* transient soap skipped */
}

int ns2__collectSpecialLine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__collectSpecialLine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__collectSpecialLine(struct soap *soap, const char *tag, int id, const ns2__collectSpecialLine *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__collectSpecialLine), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__collectSpecialLine::uid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "recordID", -1, &(a->ns2__collectSpecialLine::recordID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__collectSpecialLine::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__collectSpecialLine(soap, tag, this, type);
}

SOAP_FMAC3 ns2__collectSpecialLine * SOAP_FMAC4 soap_in_ns2__collectSpecialLine(struct soap *soap, const char *tag, ns2__collectSpecialLine *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__collectSpecialLine *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__collectSpecialLine, sizeof(ns2__collectSpecialLine), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__collectSpecialLine)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__collectSpecialLine *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_recordID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__collectSpecialLine::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_recordID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "recordID", &(a->ns2__collectSpecialLine::recordID), "xsd:string"))
				{	soap_flag_recordID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__collectSpecialLine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__collectSpecialLine, 0, sizeof(ns2__collectSpecialLine), 0, soap_copy_ns2__collectSpecialLine);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__collectSpecialLine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__collectSpecialLine);
	if (this->soap_out(soap, tag?tag:"ns2:collectSpecialLine", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__collectSpecialLine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__collectSpecialLine(soap, this, tag, type);
}

SOAP_FMAC3 ns2__collectSpecialLine * SOAP_FMAC4 soap_get_ns2__collectSpecialLine(struct soap *soap, ns2__collectSpecialLine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__collectSpecialLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__collectSpecialLine * SOAP_FMAC2 soap_instantiate_ns2__collectSpecialLine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__collectSpecialLine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__collectSpecialLine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__collectSpecialLine);
		if (size)
			*size = sizeof(ns2__collectSpecialLine);
		((ns2__collectSpecialLine*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__collectSpecialLine[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__collectSpecialLine);
		for (int i = 0; i < n; i++)
			((ns2__collectSpecialLine*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__collectSpecialLine*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__collectSpecialLine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__collectSpecialLine %p -> %p\n", q, p));
	*(ns2__collectSpecialLine*)p = *(ns2__collectSpecialLine*)q;
}

void ns2__getNewBulkGoodsInfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__getNewBulkGoodsInfResponse::return_);
	/* transient soap skipped */
}

void ns2__getNewBulkGoodsInfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__getNewBulkGoodsInfResponse::return_);
	/* transient soap skipped */
}

int ns2__getNewBulkGoodsInfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getNewBulkGoodsInfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNewBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, const ns2__getNewBulkGoodsInfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNewBulkGoodsInfResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns2__getNewBulkGoodsInfResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getNewBulkGoodsInfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getNewBulkGoodsInfResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getNewBulkGoodsInfResponse * SOAP_FMAC4 soap_in_ns2__getNewBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__getNewBulkGoodsInfResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getNewBulkGoodsInfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNewBulkGoodsInfResponse, sizeof(ns2__getNewBulkGoodsInfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getNewBulkGoodsInfResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getNewBulkGoodsInfResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns2__getNewBulkGoodsInfResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getNewBulkGoodsInfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNewBulkGoodsInfResponse, 0, sizeof(ns2__getNewBulkGoodsInfResponse), 0, soap_copy_ns2__getNewBulkGoodsInfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__getNewBulkGoodsInfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getNewBulkGoodsInfResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getNewBulkGoodsInfResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getNewBulkGoodsInfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getNewBulkGoodsInfResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getNewBulkGoodsInfResponse * SOAP_FMAC4 soap_get_ns2__getNewBulkGoodsInfResponse(struct soap *soap, ns2__getNewBulkGoodsInfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getNewBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getNewBulkGoodsInfResponse * SOAP_FMAC2 soap_instantiate_ns2__getNewBulkGoodsInfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNewBulkGoodsInfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNewBulkGoodsInfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewBulkGoodsInfResponse);
		if (size)
			*size = sizeof(ns2__getNewBulkGoodsInfResponse);
		((ns2__getNewBulkGoodsInfResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewBulkGoodsInfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getNewBulkGoodsInfResponse);
		for (int i = 0; i < n; i++)
			((ns2__getNewBulkGoodsInfResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getNewBulkGoodsInfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNewBulkGoodsInfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getNewBulkGoodsInfResponse %p -> %p\n", q, p));
	*(ns2__getNewBulkGoodsInfResponse*)p = *(ns2__getNewBulkGoodsInfResponse*)q;
}

void ns2__getNewBulkGoodsInf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getNewBulkGoodsInf::uid = NULL;
	soap_default_int(soap, &this->ns2__getNewBulkGoodsInf::record);
	soap_default_int(soap, &this->ns2__getNewBulkGoodsInf::curpage);
	/* transient soap skipped */
}

void ns2__getNewBulkGoodsInf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__getNewBulkGoodsInf::uid);
	/* transient soap skipped */
}

int ns2__getNewBulkGoodsInf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getNewBulkGoodsInf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNewBulkGoodsInf(struct soap *soap, const char *tag, int id, const ns2__getNewBulkGoodsInf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNewBulkGoodsInf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uid", -1, &(a->ns2__getNewBulkGoodsInf::uid), ""))
		return soap->error;
	if (soap_out_int(soap, "record", -1, &(a->ns2__getNewBulkGoodsInf::record), ""))
		return soap->error;
	if (soap_out_int(soap, "curpage", -1, &(a->ns2__getNewBulkGoodsInf::curpage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__getNewBulkGoodsInf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__getNewBulkGoodsInf(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getNewBulkGoodsInf * SOAP_FMAC4 soap_in_ns2__getNewBulkGoodsInf(struct soap *soap, const char *tag, ns2__getNewBulkGoodsInf *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getNewBulkGoodsInf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNewBulkGoodsInf, sizeof(ns2__getNewBulkGoodsInf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__getNewBulkGoodsInf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__getNewBulkGoodsInf *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uid1 = 1;
	size_t soap_flag_record1 = 1;
	size_t soap_flag_curpage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uid", &(a->ns2__getNewBulkGoodsInf::uid), "xsd:string"))
				{	soap_flag_uid1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "record", &(a->ns2__getNewBulkGoodsInf::record), "xsd:int"))
				{	soap_flag_record1--;
					continue;
				}
			if (soap_flag_curpage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curpage", &(a->ns2__getNewBulkGoodsInf::curpage), "xsd:int"))
				{	soap_flag_curpage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getNewBulkGoodsInf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNewBulkGoodsInf, 0, sizeof(ns2__getNewBulkGoodsInf), 0, soap_copy_ns2__getNewBulkGoodsInf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_record1 > 0 || soap_flag_curpage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__getNewBulkGoodsInf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__getNewBulkGoodsInf);
	if (this->soap_out(soap, tag?tag:"ns2:getNewBulkGoodsInf", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getNewBulkGoodsInf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getNewBulkGoodsInf(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getNewBulkGoodsInf * SOAP_FMAC4 soap_get_ns2__getNewBulkGoodsInf(struct soap *soap, ns2__getNewBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getNewBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__getNewBulkGoodsInf * SOAP_FMAC2 soap_instantiate_ns2__getNewBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNewBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNewBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewBulkGoodsInf);
		if (size)
			*size = sizeof(ns2__getNewBulkGoodsInf);
		((ns2__getNewBulkGoodsInf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__getNewBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__getNewBulkGoodsInf);
		for (int i = 0; i < n; i++)
			((ns2__getNewBulkGoodsInf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__getNewBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNewBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__getNewBulkGoodsInf %p -> %p\n", q, p));
	*(ns2__getNewBulkGoodsInf*)p = *(ns2__getNewBulkGoodsInf*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSearchCarsInf(struct soap *soap, struct __ns1__getSearchCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getSearchCarsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSearchCarsInf(struct soap *soap, const struct __ns1__getSearchCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getSearchCarsInf(soap, &a->ns2__getSearchCarsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSearchCarsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getSearchCarsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getSearchCarsInf(soap, "ns2:getSearchCarsInf", -1, &a->ns2__getSearchCarsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchCarsInf * SOAP_FMAC4 soap_in___ns1__getSearchCarsInf(struct soap *soap, const char *tag, struct __ns1__getSearchCarsInf *a, const char *type)
{
	size_t soap_flag_ns2__getSearchCarsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getSearchCarsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSearchCarsInf, sizeof(struct __ns1__getSearchCarsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSearchCarsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getSearchCarsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getSearchCarsInf(soap, "ns2:getSearchCarsInf", &a->ns2__getSearchCarsInf_, "ns2:getSearchCarsInf"))
				{	soap_flag_ns2__getSearchCarsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSearchCarsInf(struct soap *soap, const struct __ns1__getSearchCarsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSearchCarsInf(soap, tag?tag:"-ns1:getSearchCarsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchCarsInf * SOAP_FMAC4 soap_get___ns1__getSearchCarsInf(struct soap *soap, struct __ns1__getSearchCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSearchCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSearchCarsInf * SOAP_FMAC2 soap_instantiate___ns1__getSearchCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSearchCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSearchCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchCarsInf);
		if (size)
			*size = sizeof(struct __ns1__getSearchCarsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSearchCarsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSearchCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSearchCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSearchCarsInf %p -> %p\n", q, p));
	*(struct __ns1__getSearchCarsInf*)p = *(struct __ns1__getSearchCarsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAgentPopAd(struct soap *soap, struct __ns1__getAgentPopAd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getAgentPopAd_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAgentPopAd(struct soap *soap, const struct __ns1__getAgentPopAd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getAgentPopAd(soap, &a->ns2__getAgentPopAd_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAgentPopAd(struct soap *soap, const char *tag, int id, const struct __ns1__getAgentPopAd *a, const char *type)
{
	if (soap_out_PointerTons2__getAgentPopAd(soap, "ns2:getAgentPopAd", -1, &a->ns2__getAgentPopAd_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAgentPopAd * SOAP_FMAC4 soap_in___ns1__getAgentPopAd(struct soap *soap, const char *tag, struct __ns1__getAgentPopAd *a, const char *type)
{
	size_t soap_flag_ns2__getAgentPopAd_ = 1;
	short soap_flag;
	a = (struct __ns1__getAgentPopAd *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAgentPopAd, sizeof(struct __ns1__getAgentPopAd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAgentPopAd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getAgentPopAd_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getAgentPopAd(soap, "ns2:getAgentPopAd", &a->ns2__getAgentPopAd_, "ns2:getAgentPopAd"))
				{	soap_flag_ns2__getAgentPopAd_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAgentPopAd(struct soap *soap, const struct __ns1__getAgentPopAd *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAgentPopAd(soap, tag?tag:"-ns1:getAgentPopAd", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAgentPopAd * SOAP_FMAC4 soap_get___ns1__getAgentPopAd(struct soap *soap, struct __ns1__getAgentPopAd *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAgentPopAd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAgentPopAd * SOAP_FMAC2 soap_instantiate___ns1__getAgentPopAd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAgentPopAd(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAgentPopAd, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAgentPopAd);
		if (size)
			*size = sizeof(struct __ns1__getAgentPopAd);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAgentPopAd[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAgentPopAd);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAgentPopAd*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAgentPopAd(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAgentPopAd %p -> %p\n", q, p));
	*(struct __ns1__getAgentPopAd*)p = *(struct __ns1__getAgentPopAd*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSearchCarsInfNew(struct soap *soap, struct __ns1__getSearchCarsInfNew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getSearchCarsInfNew_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSearchCarsInfNew(struct soap *soap, const struct __ns1__getSearchCarsInfNew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getSearchCarsInfNew(soap, &a->ns2__getSearchCarsInfNew_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSearchCarsInfNew(struct soap *soap, const char *tag, int id, const struct __ns1__getSearchCarsInfNew *a, const char *type)
{
	if (soap_out_PointerTons2__getSearchCarsInfNew(soap, "ns2:getSearchCarsInfNew", -1, &a->ns2__getSearchCarsInfNew_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchCarsInfNew * SOAP_FMAC4 soap_in___ns1__getSearchCarsInfNew(struct soap *soap, const char *tag, struct __ns1__getSearchCarsInfNew *a, const char *type)
{
	size_t soap_flag_ns2__getSearchCarsInfNew_ = 1;
	short soap_flag;
	a = (struct __ns1__getSearchCarsInfNew *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSearchCarsInfNew, sizeof(struct __ns1__getSearchCarsInfNew), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSearchCarsInfNew(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getSearchCarsInfNew_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getSearchCarsInfNew(soap, "ns2:getSearchCarsInfNew", &a->ns2__getSearchCarsInfNew_, "ns2:getSearchCarsInfNew"))
				{	soap_flag_ns2__getSearchCarsInfNew_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSearchCarsInfNew(struct soap *soap, const struct __ns1__getSearchCarsInfNew *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSearchCarsInfNew(soap, tag?tag:"-ns1:getSearchCarsInfNew", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchCarsInfNew * SOAP_FMAC4 soap_get___ns1__getSearchCarsInfNew(struct soap *soap, struct __ns1__getSearchCarsInfNew *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSearchCarsInfNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSearchCarsInfNew * SOAP_FMAC2 soap_instantiate___ns1__getSearchCarsInfNew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSearchCarsInfNew(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSearchCarsInfNew, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchCarsInfNew);
		if (size)
			*size = sizeof(struct __ns1__getSearchCarsInfNew);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchCarsInfNew[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSearchCarsInfNew);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSearchCarsInfNew*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSearchCarsInfNew(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSearchCarsInfNew %p -> %p\n", q, p));
	*(struct __ns1__getSearchCarsInfNew*)p = *(struct __ns1__getSearchCarsInfNew*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__delFavoriteSpecialLine(struct soap *soap, struct __ns1__delFavoriteSpecialLine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__delFavoriteSpecialLine_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__delFavoriteSpecialLine(struct soap *soap, const struct __ns1__delFavoriteSpecialLine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__delFavoriteSpecialLine(soap, &a->ns2__delFavoriteSpecialLine_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__delFavoriteSpecialLine(struct soap *soap, const char *tag, int id, const struct __ns1__delFavoriteSpecialLine *a, const char *type)
{
	if (soap_out_PointerTons2__delFavoriteSpecialLine(soap, "ns2:delFavoriteSpecialLine", -1, &a->ns2__delFavoriteSpecialLine_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delFavoriteSpecialLine * SOAP_FMAC4 soap_in___ns1__delFavoriteSpecialLine(struct soap *soap, const char *tag, struct __ns1__delFavoriteSpecialLine *a, const char *type)
{
	size_t soap_flag_ns2__delFavoriteSpecialLine_ = 1;
	short soap_flag;
	a = (struct __ns1__delFavoriteSpecialLine *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__delFavoriteSpecialLine, sizeof(struct __ns1__delFavoriteSpecialLine), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__delFavoriteSpecialLine(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__delFavoriteSpecialLine_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__delFavoriteSpecialLine(soap, "ns2:delFavoriteSpecialLine", &a->ns2__delFavoriteSpecialLine_, "ns2:delFavoriteSpecialLine"))
				{	soap_flag_ns2__delFavoriteSpecialLine_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__delFavoriteSpecialLine(struct soap *soap, const struct __ns1__delFavoriteSpecialLine *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__delFavoriteSpecialLine(soap, tag?tag:"-ns1:delFavoriteSpecialLine", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delFavoriteSpecialLine * SOAP_FMAC4 soap_get___ns1__delFavoriteSpecialLine(struct soap *soap, struct __ns1__delFavoriteSpecialLine *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__delFavoriteSpecialLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__delFavoriteSpecialLine * SOAP_FMAC2 soap_instantiate___ns1__delFavoriteSpecialLine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__delFavoriteSpecialLine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__delFavoriteSpecialLine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__delFavoriteSpecialLine);
		if (size)
			*size = sizeof(struct __ns1__delFavoriteSpecialLine);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__delFavoriteSpecialLine[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__delFavoriteSpecialLine);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__delFavoriteSpecialLine*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__delFavoriteSpecialLine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__delFavoriteSpecialLine %p -> %p\n", q, p));
	*(struct __ns1__delFavoriteSpecialLine*)p = *(struct __ns1__delFavoriteSpecialLine*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getNewGoodsInf(struct soap *soap, struct __ns1__getNewGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getNewGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getNewGoodsInf(struct soap *soap, const struct __ns1__getNewGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getNewGoodsInf(soap, &a->ns2__getNewGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getNewGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getNewGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getNewGoodsInf(soap, "ns2:getNewGoodsInf", -1, &a->ns2__getNewGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNewGoodsInf * SOAP_FMAC4 soap_in___ns1__getNewGoodsInf(struct soap *soap, const char *tag, struct __ns1__getNewGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__getNewGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getNewGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getNewGoodsInf, sizeof(struct __ns1__getNewGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getNewGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getNewGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getNewGoodsInf(soap, "ns2:getNewGoodsInf", &a->ns2__getNewGoodsInf_, "ns2:getNewGoodsInf"))
				{	soap_flag_ns2__getNewGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getNewGoodsInf(struct soap *soap, const struct __ns1__getNewGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getNewGoodsInf(soap, tag?tag:"-ns1:getNewGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNewGoodsInf * SOAP_FMAC4 soap_get___ns1__getNewGoodsInf(struct soap *soap, struct __ns1__getNewGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getNewGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getNewGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__getNewGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getNewGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getNewGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getNewGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__getNewGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getNewGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getNewGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getNewGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getNewGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getNewGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__getNewGoodsInf*)p = *(struct __ns1__getNewGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setPubSpecialLineInf(struct soap *soap, struct __ns1__setPubSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__setPubSpecialLineInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setPubSpecialLineInf(struct soap *soap, const struct __ns1__setPubSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__setPubSpecialLineInf(soap, &a->ns2__setPubSpecialLineInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setPubSpecialLineInf(struct soap *soap, const char *tag, int id, const struct __ns1__setPubSpecialLineInf *a, const char *type)
{
	if (soap_out_PointerTons2__setPubSpecialLineInf(soap, "ns2:setPubSpecialLineInf", -1, &a->ns2__setPubSpecialLineInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPubSpecialLineInf * SOAP_FMAC4 soap_in___ns1__setPubSpecialLineInf(struct soap *soap, const char *tag, struct __ns1__setPubSpecialLineInf *a, const char *type)
{
	size_t soap_flag_ns2__setPubSpecialLineInf_ = 1;
	short soap_flag;
	a = (struct __ns1__setPubSpecialLineInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setPubSpecialLineInf, sizeof(struct __ns1__setPubSpecialLineInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setPubSpecialLineInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__setPubSpecialLineInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__setPubSpecialLineInf(soap, "ns2:setPubSpecialLineInf", &a->ns2__setPubSpecialLineInf_, "ns2:setPubSpecialLineInf"))
				{	soap_flag_ns2__setPubSpecialLineInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setPubSpecialLineInf(struct soap *soap, const struct __ns1__setPubSpecialLineInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setPubSpecialLineInf(soap, tag?tag:"-ns1:setPubSpecialLineInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPubSpecialLineInf * SOAP_FMAC4 soap_get___ns1__setPubSpecialLineInf(struct soap *soap, struct __ns1__setPubSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setPubSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setPubSpecialLineInf * SOAP_FMAC2 soap_instantiate___ns1__setPubSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setPubSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setPubSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setPubSpecialLineInf);
		if (size)
			*size = sizeof(struct __ns1__setPubSpecialLineInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setPubSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setPubSpecialLineInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setPubSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setPubSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setPubSpecialLineInf %p -> %p\n", q, p));
	*(struct __ns1__setPubSpecialLineInf*)p = *(struct __ns1__setPubSpecialLineInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMySpecialLineInf(struct soap *soap, struct __ns1__getMySpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getMySpecialLineInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMySpecialLineInf(struct soap *soap, const struct __ns1__getMySpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getMySpecialLineInf(soap, &a->ns2__getMySpecialLineInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMySpecialLineInf(struct soap *soap, const char *tag, int id, const struct __ns1__getMySpecialLineInf *a, const char *type)
{
	if (soap_out_PointerTons2__getMySpecialLineInf(soap, "ns2:getMySpecialLineInf", -1, &a->ns2__getMySpecialLineInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMySpecialLineInf * SOAP_FMAC4 soap_in___ns1__getMySpecialLineInf(struct soap *soap, const char *tag, struct __ns1__getMySpecialLineInf *a, const char *type)
{
	size_t soap_flag_ns2__getMySpecialLineInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getMySpecialLineInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMySpecialLineInf, sizeof(struct __ns1__getMySpecialLineInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMySpecialLineInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getMySpecialLineInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getMySpecialLineInf(soap, "ns2:getMySpecialLineInf", &a->ns2__getMySpecialLineInf_, "ns2:getMySpecialLineInf"))
				{	soap_flag_ns2__getMySpecialLineInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMySpecialLineInf(struct soap *soap, const struct __ns1__getMySpecialLineInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMySpecialLineInf(soap, tag?tag:"-ns1:getMySpecialLineInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMySpecialLineInf * SOAP_FMAC4 soap_get___ns1__getMySpecialLineInf(struct soap *soap, struct __ns1__getMySpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMySpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMySpecialLineInf * SOAP_FMAC2 soap_instantiate___ns1__getMySpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMySpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMySpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMySpecialLineInf);
		if (size)
			*size = sizeof(struct __ns1__getMySpecialLineInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMySpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getMySpecialLineInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getMySpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMySpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMySpecialLineInf %p -> %p\n", q, p));
	*(struct __ns1__getMySpecialLineInf*)p = *(struct __ns1__getMySpecialLineInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__delCarsInf(struct soap *soap, struct __ns1__delCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__delCarsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__delCarsInf(struct soap *soap, const struct __ns1__delCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__delCarsInf(soap, &a->ns2__delCarsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__delCarsInf(struct soap *soap, const char *tag, int id, const struct __ns1__delCarsInf *a, const char *type)
{
	if (soap_out_PointerTons2__delCarsInf(soap, "ns2:delCarsInf", -1, &a->ns2__delCarsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delCarsInf * SOAP_FMAC4 soap_in___ns1__delCarsInf(struct soap *soap, const char *tag, struct __ns1__delCarsInf *a, const char *type)
{
	size_t soap_flag_ns2__delCarsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__delCarsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__delCarsInf, sizeof(struct __ns1__delCarsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__delCarsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__delCarsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__delCarsInf(soap, "ns2:delCarsInf", &a->ns2__delCarsInf_, "ns2:delCarsInf"))
				{	soap_flag_ns2__delCarsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__delCarsInf(struct soap *soap, const struct __ns1__delCarsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__delCarsInf(soap, tag?tag:"-ns1:delCarsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delCarsInf * SOAP_FMAC4 soap_get___ns1__delCarsInf(struct soap *soap, struct __ns1__delCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__delCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__delCarsInf * SOAP_FMAC2 soap_instantiate___ns1__delCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__delCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__delCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__delCarsInf);
		if (size)
			*size = sizeof(struct __ns1__delCarsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__delCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__delCarsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__delCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__delCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__delCarsInf %p -> %p\n", q, p));
	*(struct __ns1__delCarsInf*)p = *(struct __ns1__delCarsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPersisCarsInfo(struct soap *soap, struct __ns1__getPersisCarsInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getPersisCarsInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPersisCarsInfo(struct soap *soap, const struct __ns1__getPersisCarsInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getPersisCarsInfo(soap, &a->ns2__getPersisCarsInfo_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPersisCarsInfo(struct soap *soap, const char *tag, int id, const struct __ns1__getPersisCarsInfo *a, const char *type)
{
	if (soap_out_PointerTons2__getPersisCarsInfo(soap, "ns2:getPersisCarsInfo", -1, &a->ns2__getPersisCarsInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPersisCarsInfo * SOAP_FMAC4 soap_in___ns1__getPersisCarsInfo(struct soap *soap, const char *tag, struct __ns1__getPersisCarsInfo *a, const char *type)
{
	size_t soap_flag_ns2__getPersisCarsInfo_ = 1;
	short soap_flag;
	a = (struct __ns1__getPersisCarsInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPersisCarsInfo, sizeof(struct __ns1__getPersisCarsInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPersisCarsInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getPersisCarsInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getPersisCarsInfo(soap, "ns2:getPersisCarsInfo", &a->ns2__getPersisCarsInfo_, "ns2:getPersisCarsInfo"))
				{	soap_flag_ns2__getPersisCarsInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPersisCarsInfo(struct soap *soap, const struct __ns1__getPersisCarsInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPersisCarsInfo(soap, tag?tag:"-ns1:getPersisCarsInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPersisCarsInfo * SOAP_FMAC4 soap_get___ns1__getPersisCarsInfo(struct soap *soap, struct __ns1__getPersisCarsInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPersisCarsInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getPersisCarsInfo * SOAP_FMAC2 soap_instantiate___ns1__getPersisCarsInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPersisCarsInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPersisCarsInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPersisCarsInfo);
		if (size)
			*size = sizeof(struct __ns1__getPersisCarsInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPersisCarsInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getPersisCarsInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getPersisCarsInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPersisCarsInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPersisCarsInfo %p -> %p\n", q, p));
	*(struct __ns1__getPersisCarsInfo*)p = *(struct __ns1__getPersisCarsInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__placeOrder(struct soap *soap, struct __ns1__placeOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__placeOrder_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__placeOrder(struct soap *soap, const struct __ns1__placeOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__placeOrder(soap, &a->ns2__placeOrder_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__placeOrder(struct soap *soap, const char *tag, int id, const struct __ns1__placeOrder *a, const char *type)
{
	if (soap_out_PointerTons2__placeOrder(soap, "ns2:placeOrder", -1, &a->ns2__placeOrder_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__placeOrder * SOAP_FMAC4 soap_in___ns1__placeOrder(struct soap *soap, const char *tag, struct __ns1__placeOrder *a, const char *type)
{
	size_t soap_flag_ns2__placeOrder_ = 1;
	short soap_flag;
	a = (struct __ns1__placeOrder *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__placeOrder, sizeof(struct __ns1__placeOrder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__placeOrder(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__placeOrder_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__placeOrder(soap, "ns2:placeOrder", &a->ns2__placeOrder_, "ns2:placeOrder"))
				{	soap_flag_ns2__placeOrder_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__placeOrder(struct soap *soap, const struct __ns1__placeOrder *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__placeOrder(soap, tag?tag:"-ns1:placeOrder", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__placeOrder * SOAP_FMAC4 soap_get___ns1__placeOrder(struct soap *soap, struct __ns1__placeOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__placeOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__placeOrder * SOAP_FMAC2 soap_instantiate___ns1__placeOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__placeOrder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__placeOrder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__placeOrder);
		if (size)
			*size = sizeof(struct __ns1__placeOrder);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__placeOrder[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__placeOrder);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__placeOrder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__placeOrder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__placeOrder %p -> %p\n", q, p));
	*(struct __ns1__placeOrder*)p = *(struct __ns1__placeOrder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__browseZoneCars(struct soap *soap, struct __ns1__browseZoneCars *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__browseZoneCars_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__browseZoneCars(struct soap *soap, const struct __ns1__browseZoneCars *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__browseZoneCars(soap, &a->ns2__browseZoneCars_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__browseZoneCars(struct soap *soap, const char *tag, int id, const struct __ns1__browseZoneCars *a, const char *type)
{
	if (soap_out_PointerTons2__browseZoneCars(soap, "ns2:browseZoneCars", -1, &a->ns2__browseZoneCars_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__browseZoneCars * SOAP_FMAC4 soap_in___ns1__browseZoneCars(struct soap *soap, const char *tag, struct __ns1__browseZoneCars *a, const char *type)
{
	size_t soap_flag_ns2__browseZoneCars_ = 1;
	short soap_flag;
	a = (struct __ns1__browseZoneCars *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__browseZoneCars, sizeof(struct __ns1__browseZoneCars), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__browseZoneCars(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__browseZoneCars_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__browseZoneCars(soap, "ns2:browseZoneCars", &a->ns2__browseZoneCars_, "ns2:browseZoneCars"))
				{	soap_flag_ns2__browseZoneCars_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__browseZoneCars(struct soap *soap, const struct __ns1__browseZoneCars *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__browseZoneCars(soap, tag?tag:"-ns1:browseZoneCars", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__browseZoneCars * SOAP_FMAC4 soap_get___ns1__browseZoneCars(struct soap *soap, struct __ns1__browseZoneCars *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__browseZoneCars(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__browseZoneCars * SOAP_FMAC2 soap_instantiate___ns1__browseZoneCars(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__browseZoneCars(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__browseZoneCars, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__browseZoneCars);
		if (size)
			*size = sizeof(struct __ns1__browseZoneCars);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__browseZoneCars[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__browseZoneCars);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__browseZoneCars*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__browseZoneCars(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__browseZoneCars %p -> %p\n", q, p));
	*(struct __ns1__browseZoneCars*)p = *(struct __ns1__browseZoneCars*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPersisGoodsInfo(struct soap *soap, struct __ns1__getPersisGoodsInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getPersisGoodsInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPersisGoodsInfo(struct soap *soap, const struct __ns1__getPersisGoodsInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getPersisGoodsInfo(soap, &a->ns2__getPersisGoodsInfo_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPersisGoodsInfo(struct soap *soap, const char *tag, int id, const struct __ns1__getPersisGoodsInfo *a, const char *type)
{
	if (soap_out_PointerTons2__getPersisGoodsInfo(soap, "ns2:getPersisGoodsInfo", -1, &a->ns2__getPersisGoodsInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPersisGoodsInfo * SOAP_FMAC4 soap_in___ns1__getPersisGoodsInfo(struct soap *soap, const char *tag, struct __ns1__getPersisGoodsInfo *a, const char *type)
{
	size_t soap_flag_ns2__getPersisGoodsInfo_ = 1;
	short soap_flag;
	a = (struct __ns1__getPersisGoodsInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPersisGoodsInfo, sizeof(struct __ns1__getPersisGoodsInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPersisGoodsInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getPersisGoodsInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getPersisGoodsInfo(soap, "ns2:getPersisGoodsInfo", &a->ns2__getPersisGoodsInfo_, "ns2:getPersisGoodsInfo"))
				{	soap_flag_ns2__getPersisGoodsInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPersisGoodsInfo(struct soap *soap, const struct __ns1__getPersisGoodsInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPersisGoodsInfo(soap, tag?tag:"-ns1:getPersisGoodsInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPersisGoodsInfo * SOAP_FMAC4 soap_get___ns1__getPersisGoodsInfo(struct soap *soap, struct __ns1__getPersisGoodsInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPersisGoodsInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getPersisGoodsInfo * SOAP_FMAC2 soap_instantiate___ns1__getPersisGoodsInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPersisGoodsInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPersisGoodsInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPersisGoodsInfo);
		if (size)
			*size = sizeof(struct __ns1__getPersisGoodsInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPersisGoodsInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getPersisGoodsInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getPersisGoodsInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPersisGoodsInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPersisGoodsInfo %p -> %p\n", q, p));
	*(struct __ns1__getPersisGoodsInfo*)p = *(struct __ns1__getPersisGoodsInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__usrLogin(struct soap *soap, struct __ns1__usrLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__usrLogin_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__usrLogin(struct soap *soap, const struct __ns1__usrLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__usrLogin(soap, &a->ns2__usrLogin_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__usrLogin(struct soap *soap, const char *tag, int id, const struct __ns1__usrLogin *a, const char *type)
{
	if (soap_out_PointerTons2__usrLogin(soap, "ns2:usrLogin", -1, &a->ns2__usrLogin_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__usrLogin * SOAP_FMAC4 soap_in___ns1__usrLogin(struct soap *soap, const char *tag, struct __ns1__usrLogin *a, const char *type)
{
	size_t soap_flag_ns2__usrLogin_ = 1;
	short soap_flag;
	a = (struct __ns1__usrLogin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__usrLogin, sizeof(struct __ns1__usrLogin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__usrLogin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__usrLogin_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__usrLogin(soap, "ns2:usrLogin", &a->ns2__usrLogin_, "ns2:usrLogin"))
				{	soap_flag_ns2__usrLogin_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__usrLogin(struct soap *soap, const struct __ns1__usrLogin *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__usrLogin(soap, tag?tag:"-ns1:usrLogin", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__usrLogin * SOAP_FMAC4 soap_get___ns1__usrLogin(struct soap *soap, struct __ns1__usrLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__usrLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__usrLogin * SOAP_FMAC2 soap_instantiate___ns1__usrLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__usrLogin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__usrLogin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__usrLogin);
		if (size)
			*size = sizeof(struct __ns1__usrLogin);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__usrLogin[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__usrLogin);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__usrLogin*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__usrLogin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__usrLogin %p -> %p\n", q, p));
	*(struct __ns1__usrLogin*)p = *(struct __ns1__usrLogin*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__delBulkGoodsInf(struct soap *soap, struct __ns1__delBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__delBulkGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__delBulkGoodsInf(struct soap *soap, const struct __ns1__delBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__delBulkGoodsInf(soap, &a->ns2__delBulkGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__delBulkGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__delBulkGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__delBulkGoodsInf(soap, "ns2:delBulkGoodsInf", -1, &a->ns2__delBulkGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delBulkGoodsInf * SOAP_FMAC4 soap_in___ns1__delBulkGoodsInf(struct soap *soap, const char *tag, struct __ns1__delBulkGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__delBulkGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__delBulkGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__delBulkGoodsInf, sizeof(struct __ns1__delBulkGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__delBulkGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__delBulkGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__delBulkGoodsInf(soap, "ns2:delBulkGoodsInf", &a->ns2__delBulkGoodsInf_, "ns2:delBulkGoodsInf"))
				{	soap_flag_ns2__delBulkGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__delBulkGoodsInf(struct soap *soap, const struct __ns1__delBulkGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__delBulkGoodsInf(soap, tag?tag:"-ns1:delBulkGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delBulkGoodsInf * SOAP_FMAC4 soap_get___ns1__delBulkGoodsInf(struct soap *soap, struct __ns1__delBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__delBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__delBulkGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__delBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__delBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__delBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__delBulkGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__delBulkGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__delBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__delBulkGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__delBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__delBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__delBulkGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__delBulkGoodsInf*)p = *(struct __ns1__delBulkGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getClickSearchCarsInf(struct soap *soap, struct __ns1__getClickSearchCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getClickSearchCarsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getClickSearchCarsInf(struct soap *soap, const struct __ns1__getClickSearchCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getClickSearchCarsInf(soap, &a->ns2__getClickSearchCarsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getClickSearchCarsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getClickSearchCarsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getClickSearchCarsInf(soap, "ns2:getClickSearchCarsInf", -1, &a->ns2__getClickSearchCarsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClickSearchCarsInf * SOAP_FMAC4 soap_in___ns1__getClickSearchCarsInf(struct soap *soap, const char *tag, struct __ns1__getClickSearchCarsInf *a, const char *type)
{
	size_t soap_flag_ns2__getClickSearchCarsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getClickSearchCarsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getClickSearchCarsInf, sizeof(struct __ns1__getClickSearchCarsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getClickSearchCarsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getClickSearchCarsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getClickSearchCarsInf(soap, "ns2:getClickSearchCarsInf", &a->ns2__getClickSearchCarsInf_, "ns2:getClickSearchCarsInf"))
				{	soap_flag_ns2__getClickSearchCarsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getClickSearchCarsInf(struct soap *soap, const struct __ns1__getClickSearchCarsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getClickSearchCarsInf(soap, tag?tag:"-ns1:getClickSearchCarsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClickSearchCarsInf * SOAP_FMAC4 soap_get___ns1__getClickSearchCarsInf(struct soap *soap, struct __ns1__getClickSearchCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getClickSearchCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getClickSearchCarsInf * SOAP_FMAC2 soap_instantiate___ns1__getClickSearchCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getClickSearchCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getClickSearchCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getClickSearchCarsInf);
		if (size)
			*size = sizeof(struct __ns1__getClickSearchCarsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getClickSearchCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getClickSearchCarsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getClickSearchCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getClickSearchCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getClickSearchCarsInf %p -> %p\n", q, p));
	*(struct __ns1__getClickSearchCarsInf*)p = *(struct __ns1__getClickSearchCarsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setPubCarsInf(struct soap *soap, struct __ns1__setPubCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__setPubCarsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setPubCarsInf(struct soap *soap, const struct __ns1__setPubCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__setPubCarsInf(soap, &a->ns2__setPubCarsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setPubCarsInf(struct soap *soap, const char *tag, int id, const struct __ns1__setPubCarsInf *a, const char *type)
{
	if (soap_out_PointerTons2__setPubCarsInf(soap, "ns2:setPubCarsInf", -1, &a->ns2__setPubCarsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPubCarsInf * SOAP_FMAC4 soap_in___ns1__setPubCarsInf(struct soap *soap, const char *tag, struct __ns1__setPubCarsInf *a, const char *type)
{
	size_t soap_flag_ns2__setPubCarsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__setPubCarsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setPubCarsInf, sizeof(struct __ns1__setPubCarsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setPubCarsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__setPubCarsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__setPubCarsInf(soap, "ns2:setPubCarsInf", &a->ns2__setPubCarsInf_, "ns2:setPubCarsInf"))
				{	soap_flag_ns2__setPubCarsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setPubCarsInf(struct soap *soap, const struct __ns1__setPubCarsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setPubCarsInf(soap, tag?tag:"-ns1:setPubCarsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPubCarsInf * SOAP_FMAC4 soap_get___ns1__setPubCarsInf(struct soap *soap, struct __ns1__setPubCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setPubCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setPubCarsInf * SOAP_FMAC2 soap_instantiate___ns1__setPubCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setPubCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setPubCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setPubCarsInf);
		if (size)
			*size = sizeof(struct __ns1__setPubCarsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setPubCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setPubCarsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setPubCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setPubCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setPubCarsInf %p -> %p\n", q, p));
	*(struct __ns1__setPubCarsInf*)p = *(struct __ns1__setPubCarsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setPubBulkGoodsInf(struct soap *soap, struct __ns1__setPubBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__setPubBulkGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setPubBulkGoodsInf(struct soap *soap, const struct __ns1__setPubBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__setPubBulkGoodsInf(soap, &a->ns2__setPubBulkGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setPubBulkGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__setPubBulkGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__setPubBulkGoodsInf(soap, "ns2:setPubBulkGoodsInf", -1, &a->ns2__setPubBulkGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPubBulkGoodsInf * SOAP_FMAC4 soap_in___ns1__setPubBulkGoodsInf(struct soap *soap, const char *tag, struct __ns1__setPubBulkGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__setPubBulkGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__setPubBulkGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setPubBulkGoodsInf, sizeof(struct __ns1__setPubBulkGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setPubBulkGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__setPubBulkGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__setPubBulkGoodsInf(soap, "ns2:setPubBulkGoodsInf", &a->ns2__setPubBulkGoodsInf_, "ns2:setPubBulkGoodsInf"))
				{	soap_flag_ns2__setPubBulkGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setPubBulkGoodsInf(struct soap *soap, const struct __ns1__setPubBulkGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setPubBulkGoodsInf(soap, tag?tag:"-ns1:setPubBulkGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPubBulkGoodsInf * SOAP_FMAC4 soap_get___ns1__setPubBulkGoodsInf(struct soap *soap, struct __ns1__setPubBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setPubBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setPubBulkGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__setPubBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setPubBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setPubBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setPubBulkGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__setPubBulkGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setPubBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setPubBulkGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setPubBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setPubBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setPubBulkGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__setPubBulkGoodsInf*)p = *(struct __ns1__setPubBulkGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSearchBulkGoodsInf(struct soap *soap, struct __ns1__getSearchBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getSearchBulkGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSearchBulkGoodsInf(struct soap *soap, const struct __ns1__getSearchBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getSearchBulkGoodsInf(soap, &a->ns2__getSearchBulkGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSearchBulkGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getSearchBulkGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getSearchBulkGoodsInf(soap, "ns2:getSearchBulkGoodsInf", -1, &a->ns2__getSearchBulkGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchBulkGoodsInf * SOAP_FMAC4 soap_in___ns1__getSearchBulkGoodsInf(struct soap *soap, const char *tag, struct __ns1__getSearchBulkGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__getSearchBulkGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getSearchBulkGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSearchBulkGoodsInf, sizeof(struct __ns1__getSearchBulkGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSearchBulkGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getSearchBulkGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getSearchBulkGoodsInf(soap, "ns2:getSearchBulkGoodsInf", &a->ns2__getSearchBulkGoodsInf_, "ns2:getSearchBulkGoodsInf"))
				{	soap_flag_ns2__getSearchBulkGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSearchBulkGoodsInf(struct soap *soap, const struct __ns1__getSearchBulkGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSearchBulkGoodsInf(soap, tag?tag:"-ns1:getSearchBulkGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchBulkGoodsInf * SOAP_FMAC4 soap_get___ns1__getSearchBulkGoodsInf(struct soap *soap, struct __ns1__getSearchBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSearchBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSearchBulkGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__getSearchBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSearchBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSearchBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchBulkGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__getSearchBulkGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSearchBulkGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSearchBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSearchBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSearchBulkGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__getSearchBulkGoodsInf*)p = *(struct __ns1__getSearchBulkGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getNewCarsInf(struct soap *soap, struct __ns1__getNewCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getNewCarsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getNewCarsInf(struct soap *soap, const struct __ns1__getNewCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getNewCarsInf(soap, &a->ns2__getNewCarsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getNewCarsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getNewCarsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getNewCarsInf(soap, "ns2:getNewCarsInf", -1, &a->ns2__getNewCarsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNewCarsInf * SOAP_FMAC4 soap_in___ns1__getNewCarsInf(struct soap *soap, const char *tag, struct __ns1__getNewCarsInf *a, const char *type)
{
	size_t soap_flag_ns2__getNewCarsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getNewCarsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getNewCarsInf, sizeof(struct __ns1__getNewCarsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getNewCarsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getNewCarsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getNewCarsInf(soap, "ns2:getNewCarsInf", &a->ns2__getNewCarsInf_, "ns2:getNewCarsInf"))
				{	soap_flag_ns2__getNewCarsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getNewCarsInf(struct soap *soap, const struct __ns1__getNewCarsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getNewCarsInf(soap, tag?tag:"-ns1:getNewCarsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNewCarsInf * SOAP_FMAC4 soap_get___ns1__getNewCarsInf(struct soap *soap, struct __ns1__getNewCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getNewCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getNewCarsInf * SOAP_FMAC2 soap_instantiate___ns1__getNewCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getNewCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getNewCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getNewCarsInf);
		if (size)
			*size = sizeof(struct __ns1__getNewCarsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getNewCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getNewCarsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getNewCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getNewCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getNewCarsInf %p -> %p\n", q, p));
	*(struct __ns1__getNewCarsInf*)p = *(struct __ns1__getNewCarsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setPubGoodsInf(struct soap *soap, struct __ns1__setPubGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__setPubGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setPubGoodsInf(struct soap *soap, const struct __ns1__setPubGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__setPubGoodsInf(soap, &a->ns2__setPubGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setPubGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__setPubGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__setPubGoodsInf(soap, "ns2:setPubGoodsInf", -1, &a->ns2__setPubGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPubGoodsInf * SOAP_FMAC4 soap_in___ns1__setPubGoodsInf(struct soap *soap, const char *tag, struct __ns1__setPubGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__setPubGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__setPubGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setPubGoodsInf, sizeof(struct __ns1__setPubGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setPubGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__setPubGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__setPubGoodsInf(soap, "ns2:setPubGoodsInf", &a->ns2__setPubGoodsInf_, "ns2:setPubGoodsInf"))
				{	soap_flag_ns2__setPubGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setPubGoodsInf(struct soap *soap, const struct __ns1__setPubGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setPubGoodsInf(soap, tag?tag:"-ns1:setPubGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPubGoodsInf * SOAP_FMAC4 soap_get___ns1__setPubGoodsInf(struct soap *soap, struct __ns1__setPubGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setPubGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setPubGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__setPubGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setPubGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setPubGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setPubGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__setPubGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setPubGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setPubGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setPubGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setPubGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setPubGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__setPubGoodsInf*)p = *(struct __ns1__setPubGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getClickSearchGoodsInf(struct soap *soap, struct __ns1__getClickSearchGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getClickSearchGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getClickSearchGoodsInf(struct soap *soap, const struct __ns1__getClickSearchGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getClickSearchGoodsInf(soap, &a->ns2__getClickSearchGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getClickSearchGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getClickSearchGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getClickSearchGoodsInf(soap, "ns2:getClickSearchGoodsInf", -1, &a->ns2__getClickSearchGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClickSearchGoodsInf * SOAP_FMAC4 soap_in___ns1__getClickSearchGoodsInf(struct soap *soap, const char *tag, struct __ns1__getClickSearchGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__getClickSearchGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getClickSearchGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getClickSearchGoodsInf, sizeof(struct __ns1__getClickSearchGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getClickSearchGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getClickSearchGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getClickSearchGoodsInf(soap, "ns2:getClickSearchGoodsInf", &a->ns2__getClickSearchGoodsInf_, "ns2:getClickSearchGoodsInf"))
				{	soap_flag_ns2__getClickSearchGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getClickSearchGoodsInf(struct soap *soap, const struct __ns1__getClickSearchGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getClickSearchGoodsInf(soap, tag?tag:"-ns1:getClickSearchGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClickSearchGoodsInf * SOAP_FMAC4 soap_get___ns1__getClickSearchGoodsInf(struct soap *soap, struct __ns1__getClickSearchGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getClickSearchGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getClickSearchGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__getClickSearchGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getClickSearchGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getClickSearchGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getClickSearchGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__getClickSearchGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getClickSearchGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getClickSearchGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getClickSearchGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getClickSearchGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getClickSearchGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__getClickSearchGoodsInf*)p = *(struct __ns1__getClickSearchGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addUserCustomInf(struct soap *soap, struct __ns1__addUserCustomInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__addUserCustomInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addUserCustomInf(struct soap *soap, const struct __ns1__addUserCustomInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__addUserCustomInf(soap, &a->ns2__addUserCustomInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addUserCustomInf(struct soap *soap, const char *tag, int id, const struct __ns1__addUserCustomInf *a, const char *type)
{
	if (soap_out_PointerTons2__addUserCustomInf(soap, "ns2:addUserCustomInf", -1, &a->ns2__addUserCustomInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addUserCustomInf * SOAP_FMAC4 soap_in___ns1__addUserCustomInf(struct soap *soap, const char *tag, struct __ns1__addUserCustomInf *a, const char *type)
{
	size_t soap_flag_ns2__addUserCustomInf_ = 1;
	short soap_flag;
	a = (struct __ns1__addUserCustomInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addUserCustomInf, sizeof(struct __ns1__addUserCustomInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addUserCustomInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__addUserCustomInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__addUserCustomInf(soap, "ns2:addUserCustomInf", &a->ns2__addUserCustomInf_, "ns2:addUserCustomInf"))
				{	soap_flag_ns2__addUserCustomInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addUserCustomInf(struct soap *soap, const struct __ns1__addUserCustomInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addUserCustomInf(soap, tag?tag:"-ns1:addUserCustomInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addUserCustomInf * SOAP_FMAC4 soap_get___ns1__addUserCustomInf(struct soap *soap, struct __ns1__addUserCustomInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addUserCustomInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addUserCustomInf * SOAP_FMAC2 soap_instantiate___ns1__addUserCustomInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addUserCustomInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addUserCustomInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addUserCustomInf);
		if (size)
			*size = sizeof(struct __ns1__addUserCustomInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addUserCustomInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addUserCustomInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addUserCustomInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addUserCustomInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addUserCustomInf %p -> %p\n", q, p));
	*(struct __ns1__addUserCustomInf*)p = *(struct __ns1__addUserCustomInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMyBulkGoodsInf(struct soap *soap, struct __ns1__getMyBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getMyBulkGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMyBulkGoodsInf(struct soap *soap, const struct __ns1__getMyBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getMyBulkGoodsInf(soap, &a->ns2__getMyBulkGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMyBulkGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getMyBulkGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getMyBulkGoodsInf(soap, "ns2:getMyBulkGoodsInf", -1, &a->ns2__getMyBulkGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyBulkGoodsInf * SOAP_FMAC4 soap_in___ns1__getMyBulkGoodsInf(struct soap *soap, const char *tag, struct __ns1__getMyBulkGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__getMyBulkGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getMyBulkGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMyBulkGoodsInf, sizeof(struct __ns1__getMyBulkGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMyBulkGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getMyBulkGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getMyBulkGoodsInf(soap, "ns2:getMyBulkGoodsInf", &a->ns2__getMyBulkGoodsInf_, "ns2:getMyBulkGoodsInf"))
				{	soap_flag_ns2__getMyBulkGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMyBulkGoodsInf(struct soap *soap, const struct __ns1__getMyBulkGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMyBulkGoodsInf(soap, tag?tag:"-ns1:getMyBulkGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyBulkGoodsInf * SOAP_FMAC4 soap_get___ns1__getMyBulkGoodsInf(struct soap *soap, struct __ns1__getMyBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMyBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMyBulkGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__getMyBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMyBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMyBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyBulkGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__getMyBulkGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getMyBulkGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getMyBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMyBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMyBulkGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__getMyBulkGoodsInf*)p = *(struct __ns1__getMyBulkGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__delSpecialLineInf(struct soap *soap, struct __ns1__delSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__delSpecialLineInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__delSpecialLineInf(struct soap *soap, const struct __ns1__delSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__delSpecialLineInf(soap, &a->ns2__delSpecialLineInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__delSpecialLineInf(struct soap *soap, const char *tag, int id, const struct __ns1__delSpecialLineInf *a, const char *type)
{
	if (soap_out_PointerTons2__delSpecialLineInf(soap, "ns2:delSpecialLineInf", -1, &a->ns2__delSpecialLineInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delSpecialLineInf * SOAP_FMAC4 soap_in___ns1__delSpecialLineInf(struct soap *soap, const char *tag, struct __ns1__delSpecialLineInf *a, const char *type)
{
	size_t soap_flag_ns2__delSpecialLineInf_ = 1;
	short soap_flag;
	a = (struct __ns1__delSpecialLineInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__delSpecialLineInf, sizeof(struct __ns1__delSpecialLineInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__delSpecialLineInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__delSpecialLineInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__delSpecialLineInf(soap, "ns2:delSpecialLineInf", &a->ns2__delSpecialLineInf_, "ns2:delSpecialLineInf"))
				{	soap_flag_ns2__delSpecialLineInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__delSpecialLineInf(struct soap *soap, const struct __ns1__delSpecialLineInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__delSpecialLineInf(soap, tag?tag:"-ns1:delSpecialLineInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delSpecialLineInf * SOAP_FMAC4 soap_get___ns1__delSpecialLineInf(struct soap *soap, struct __ns1__delSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__delSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__delSpecialLineInf * SOAP_FMAC2 soap_instantiate___ns1__delSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__delSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__delSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__delSpecialLineInf);
		if (size)
			*size = sizeof(struct __ns1__delSpecialLineInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__delSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__delSpecialLineInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__delSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__delSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__delSpecialLineInf %p -> %p\n", q, p));
	*(struct __ns1__delSpecialLineInf*)p = *(struct __ns1__delSpecialLineInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getClickSearchSpecialLineInf(struct soap *soap, struct __ns1__getClickSearchSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getClickSearchSpecialLineInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getClickSearchSpecialLineInf(struct soap *soap, const struct __ns1__getClickSearchSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getClickSearchSpecialLineInf(soap, &a->ns2__getClickSearchSpecialLineInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getClickSearchSpecialLineInf(struct soap *soap, const char *tag, int id, const struct __ns1__getClickSearchSpecialLineInf *a, const char *type)
{
	if (soap_out_PointerTons2__getClickSearchSpecialLineInf(soap, "ns2:getClickSearchSpecialLineInf", -1, &a->ns2__getClickSearchSpecialLineInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClickSearchSpecialLineInf * SOAP_FMAC4 soap_in___ns1__getClickSearchSpecialLineInf(struct soap *soap, const char *tag, struct __ns1__getClickSearchSpecialLineInf *a, const char *type)
{
	size_t soap_flag_ns2__getClickSearchSpecialLineInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getClickSearchSpecialLineInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getClickSearchSpecialLineInf, sizeof(struct __ns1__getClickSearchSpecialLineInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getClickSearchSpecialLineInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getClickSearchSpecialLineInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getClickSearchSpecialLineInf(soap, "ns2:getClickSearchSpecialLineInf", &a->ns2__getClickSearchSpecialLineInf_, "ns2:getClickSearchSpecialLineInf"))
				{	soap_flag_ns2__getClickSearchSpecialLineInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getClickSearchSpecialLineInf(struct soap *soap, const struct __ns1__getClickSearchSpecialLineInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getClickSearchSpecialLineInf(soap, tag?tag:"-ns1:getClickSearchSpecialLineInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClickSearchSpecialLineInf * SOAP_FMAC4 soap_get___ns1__getClickSearchSpecialLineInf(struct soap *soap, struct __ns1__getClickSearchSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getClickSearchSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getClickSearchSpecialLineInf * SOAP_FMAC2 soap_instantiate___ns1__getClickSearchSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getClickSearchSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getClickSearchSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getClickSearchSpecialLineInf);
		if (size)
			*size = sizeof(struct __ns1__getClickSearchSpecialLineInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getClickSearchSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getClickSearchSpecialLineInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getClickSearchSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getClickSearchSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getClickSearchSpecialLineInf %p -> %p\n", q, p));
	*(struct __ns1__getClickSearchSpecialLineInf*)p = *(struct __ns1__getClickSearchSpecialLineInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAllSpecialLineInf(struct soap *soap, struct __ns1__getAllSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getAllSpecialLineInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAllSpecialLineInf(struct soap *soap, const struct __ns1__getAllSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getAllSpecialLineInf(soap, &a->ns2__getAllSpecialLineInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAllSpecialLineInf(struct soap *soap, const char *tag, int id, const struct __ns1__getAllSpecialLineInf *a, const char *type)
{
	if (soap_out_PointerTons2__getAllSpecialLineInf(soap, "ns2:getAllSpecialLineInf", -1, &a->ns2__getAllSpecialLineInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllSpecialLineInf * SOAP_FMAC4 soap_in___ns1__getAllSpecialLineInf(struct soap *soap, const char *tag, struct __ns1__getAllSpecialLineInf *a, const char *type)
{
	size_t soap_flag_ns2__getAllSpecialLineInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getAllSpecialLineInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAllSpecialLineInf, sizeof(struct __ns1__getAllSpecialLineInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAllSpecialLineInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getAllSpecialLineInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getAllSpecialLineInf(soap, "ns2:getAllSpecialLineInf", &a->ns2__getAllSpecialLineInf_, "ns2:getAllSpecialLineInf"))
				{	soap_flag_ns2__getAllSpecialLineInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAllSpecialLineInf(struct soap *soap, const struct __ns1__getAllSpecialLineInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAllSpecialLineInf(soap, tag?tag:"-ns1:getAllSpecialLineInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllSpecialLineInf * SOAP_FMAC4 soap_get___ns1__getAllSpecialLineInf(struct soap *soap, struct __ns1__getAllSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAllSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAllSpecialLineInf * SOAP_FMAC2 soap_instantiate___ns1__getAllSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAllSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAllSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllSpecialLineInf);
		if (size)
			*size = sizeof(struct __ns1__getAllSpecialLineInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAllSpecialLineInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAllSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAllSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAllSpecialLineInf %p -> %p\n", q, p));
	*(struct __ns1__getAllSpecialLineInf*)p = *(struct __ns1__getAllSpecialLineInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setServiceStationInf(struct soap *soap, struct __ns1__setServiceStationInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__setServiceStationInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setServiceStationInf(struct soap *soap, const struct __ns1__setServiceStationInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__setServiceStationInf(soap, &a->ns2__setServiceStationInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setServiceStationInf(struct soap *soap, const char *tag, int id, const struct __ns1__setServiceStationInf *a, const char *type)
{
	if (soap_out_PointerTons2__setServiceStationInf(soap, "ns2:setServiceStationInf", -1, &a->ns2__setServiceStationInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setServiceStationInf * SOAP_FMAC4 soap_in___ns1__setServiceStationInf(struct soap *soap, const char *tag, struct __ns1__setServiceStationInf *a, const char *type)
{
	size_t soap_flag_ns2__setServiceStationInf_ = 1;
	short soap_flag;
	a = (struct __ns1__setServiceStationInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setServiceStationInf, sizeof(struct __ns1__setServiceStationInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setServiceStationInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__setServiceStationInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__setServiceStationInf(soap, "ns2:setServiceStationInf", &a->ns2__setServiceStationInf_, "ns2:setServiceStationInf"))
				{	soap_flag_ns2__setServiceStationInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setServiceStationInf(struct soap *soap, const struct __ns1__setServiceStationInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setServiceStationInf(soap, tag?tag:"-ns1:setServiceStationInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setServiceStationInf * SOAP_FMAC4 soap_get___ns1__setServiceStationInf(struct soap *soap, struct __ns1__setServiceStationInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setServiceStationInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setServiceStationInf * SOAP_FMAC2 soap_instantiate___ns1__setServiceStationInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setServiceStationInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setServiceStationInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setServiceStationInf);
		if (size)
			*size = sizeof(struct __ns1__setServiceStationInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setServiceStationInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setServiceStationInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setServiceStationInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setServiceStationInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setServiceStationInf %p -> %p\n", q, p));
	*(struct __ns1__setServiceStationInf*)p = *(struct __ns1__setServiceStationInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteUserCustomInf(struct soap *soap, struct __ns1__deleteUserCustomInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__deleteUserCustomInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteUserCustomInf(struct soap *soap, const struct __ns1__deleteUserCustomInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__deleteUserCustomInf(soap, &a->ns2__deleteUserCustomInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteUserCustomInf(struct soap *soap, const char *tag, int id, const struct __ns1__deleteUserCustomInf *a, const char *type)
{
	if (soap_out_PointerTons2__deleteUserCustomInf(soap, "ns2:deleteUserCustomInf", -1, &a->ns2__deleteUserCustomInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteUserCustomInf * SOAP_FMAC4 soap_in___ns1__deleteUserCustomInf(struct soap *soap, const char *tag, struct __ns1__deleteUserCustomInf *a, const char *type)
{
	size_t soap_flag_ns2__deleteUserCustomInf_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteUserCustomInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteUserCustomInf, sizeof(struct __ns1__deleteUserCustomInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteUserCustomInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__deleteUserCustomInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__deleteUserCustomInf(soap, "ns2:deleteUserCustomInf", &a->ns2__deleteUserCustomInf_, "ns2:deleteUserCustomInf"))
				{	soap_flag_ns2__deleteUserCustomInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteUserCustomInf(struct soap *soap, const struct __ns1__deleteUserCustomInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteUserCustomInf(soap, tag?tag:"-ns1:deleteUserCustomInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteUserCustomInf * SOAP_FMAC4 soap_get___ns1__deleteUserCustomInf(struct soap *soap, struct __ns1__deleteUserCustomInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteUserCustomInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteUserCustomInf * SOAP_FMAC2 soap_instantiate___ns1__deleteUserCustomInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteUserCustomInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteUserCustomInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteUserCustomInf);
		if (size)
			*size = sizeof(struct __ns1__deleteUserCustomInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteUserCustomInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteUserCustomInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteUserCustomInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteUserCustomInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteUserCustomInf %p -> %p\n", q, p));
	*(struct __ns1__deleteUserCustomInf*)p = *(struct __ns1__deleteUserCustomInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkChargeUser(struct soap *soap, struct __ns1__checkChargeUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__checkChargeUser_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkChargeUser(struct soap *soap, const struct __ns1__checkChargeUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__checkChargeUser(soap, &a->ns2__checkChargeUser_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkChargeUser(struct soap *soap, const char *tag, int id, const struct __ns1__checkChargeUser *a, const char *type)
{
	if (soap_out_PointerTons2__checkChargeUser(soap, "ns2:checkChargeUser", -1, &a->ns2__checkChargeUser_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkChargeUser * SOAP_FMAC4 soap_in___ns1__checkChargeUser(struct soap *soap, const char *tag, struct __ns1__checkChargeUser *a, const char *type)
{
	size_t soap_flag_ns2__checkChargeUser_ = 1;
	short soap_flag;
	a = (struct __ns1__checkChargeUser *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkChargeUser, sizeof(struct __ns1__checkChargeUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkChargeUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__checkChargeUser_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__checkChargeUser(soap, "ns2:checkChargeUser", &a->ns2__checkChargeUser_, "ns2:checkChargeUser"))
				{	soap_flag_ns2__checkChargeUser_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkChargeUser(struct soap *soap, const struct __ns1__checkChargeUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__checkChargeUser(soap, tag?tag:"-ns1:checkChargeUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkChargeUser * SOAP_FMAC4 soap_get___ns1__checkChargeUser(struct soap *soap, struct __ns1__checkChargeUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkChargeUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__checkChargeUser * SOAP_FMAC2 soap_instantiate___ns1__checkChargeUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkChargeUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__checkChargeUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__checkChargeUser);
		if (size)
			*size = sizeof(struct __ns1__checkChargeUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__checkChargeUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__checkChargeUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__checkChargeUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__checkChargeUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__checkChargeUser %p -> %p\n", q, p));
	*(struct __ns1__checkChargeUser*)p = *(struct __ns1__checkChargeUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getClickSearchBulkGoodsInf(struct soap *soap, struct __ns1__getClickSearchBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getClickSearchBulkGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getClickSearchBulkGoodsInf(struct soap *soap, const struct __ns1__getClickSearchBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getClickSearchBulkGoodsInf(soap, &a->ns2__getClickSearchBulkGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getClickSearchBulkGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getClickSearchBulkGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getClickSearchBulkGoodsInf(soap, "ns2:getClickSearchBulkGoodsInf", -1, &a->ns2__getClickSearchBulkGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClickSearchBulkGoodsInf * SOAP_FMAC4 soap_in___ns1__getClickSearchBulkGoodsInf(struct soap *soap, const char *tag, struct __ns1__getClickSearchBulkGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__getClickSearchBulkGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getClickSearchBulkGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getClickSearchBulkGoodsInf, sizeof(struct __ns1__getClickSearchBulkGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getClickSearchBulkGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getClickSearchBulkGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getClickSearchBulkGoodsInf(soap, "ns2:getClickSearchBulkGoodsInf", &a->ns2__getClickSearchBulkGoodsInf_, "ns2:getClickSearchBulkGoodsInf"))
				{	soap_flag_ns2__getClickSearchBulkGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getClickSearchBulkGoodsInf(struct soap *soap, const struct __ns1__getClickSearchBulkGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getClickSearchBulkGoodsInf(soap, tag?tag:"-ns1:getClickSearchBulkGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClickSearchBulkGoodsInf * SOAP_FMAC4 soap_get___ns1__getClickSearchBulkGoodsInf(struct soap *soap, struct __ns1__getClickSearchBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getClickSearchBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getClickSearchBulkGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__getClickSearchBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getClickSearchBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getClickSearchBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getClickSearchBulkGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__getClickSearchBulkGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getClickSearchBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getClickSearchBulkGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getClickSearchBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getClickSearchBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getClickSearchBulkGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__getClickSearchBulkGoodsInf*)p = *(struct __ns1__getClickSearchBulkGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCustomGoodsInf(struct soap *soap, struct __ns1__getCustomGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getCustomGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCustomGoodsInf(struct soap *soap, const struct __ns1__getCustomGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getCustomGoodsInf(soap, &a->ns2__getCustomGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCustomGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getCustomGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getCustomGoodsInf(soap, "ns2:getCustomGoodsInf", -1, &a->ns2__getCustomGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCustomGoodsInf * SOAP_FMAC4 soap_in___ns1__getCustomGoodsInf(struct soap *soap, const char *tag, struct __ns1__getCustomGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__getCustomGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getCustomGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCustomGoodsInf, sizeof(struct __ns1__getCustomGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCustomGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getCustomGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getCustomGoodsInf(soap, "ns2:getCustomGoodsInf", &a->ns2__getCustomGoodsInf_, "ns2:getCustomGoodsInf"))
				{	soap_flag_ns2__getCustomGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCustomGoodsInf(struct soap *soap, const struct __ns1__getCustomGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCustomGoodsInf(soap, tag?tag:"-ns1:getCustomGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCustomGoodsInf * SOAP_FMAC4 soap_get___ns1__getCustomGoodsInf(struct soap *soap, struct __ns1__getCustomGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCustomGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getCustomGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__getCustomGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCustomGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCustomGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCustomGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__getCustomGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCustomGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getCustomGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getCustomGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCustomGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCustomGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__getCustomGoodsInf*)p = *(struct __ns1__getCustomGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAgentScrollAd(struct soap *soap, struct __ns1__getAgentScrollAd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getAgentScrollAd_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAgentScrollAd(struct soap *soap, const struct __ns1__getAgentScrollAd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getAgentScrollAd(soap, &a->ns2__getAgentScrollAd_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAgentScrollAd(struct soap *soap, const char *tag, int id, const struct __ns1__getAgentScrollAd *a, const char *type)
{
	if (soap_out_PointerTons2__getAgentScrollAd(soap, "ns2:getAgentScrollAd", -1, &a->ns2__getAgentScrollAd_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAgentScrollAd * SOAP_FMAC4 soap_in___ns1__getAgentScrollAd(struct soap *soap, const char *tag, struct __ns1__getAgentScrollAd *a, const char *type)
{
	size_t soap_flag_ns2__getAgentScrollAd_ = 1;
	short soap_flag;
	a = (struct __ns1__getAgentScrollAd *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAgentScrollAd, sizeof(struct __ns1__getAgentScrollAd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAgentScrollAd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getAgentScrollAd_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getAgentScrollAd(soap, "ns2:getAgentScrollAd", &a->ns2__getAgentScrollAd_, "ns2:getAgentScrollAd"))
				{	soap_flag_ns2__getAgentScrollAd_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAgentScrollAd(struct soap *soap, const struct __ns1__getAgentScrollAd *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAgentScrollAd(soap, tag?tag:"-ns1:getAgentScrollAd", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAgentScrollAd * SOAP_FMAC4 soap_get___ns1__getAgentScrollAd(struct soap *soap, struct __ns1__getAgentScrollAd *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAgentScrollAd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAgentScrollAd * SOAP_FMAC2 soap_instantiate___ns1__getAgentScrollAd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAgentScrollAd(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAgentScrollAd, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAgentScrollAd);
		if (size)
			*size = sizeof(struct __ns1__getAgentScrollAd);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAgentScrollAd[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAgentScrollAd);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAgentScrollAd*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAgentScrollAd(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAgentScrollAd %p -> %p\n", q, p));
	*(struct __ns1__getAgentScrollAd*)p = *(struct __ns1__getAgentScrollAd*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSystemScrollAd(struct soap *soap, struct __ns1__getSystemScrollAd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getSystemScrollAd_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSystemScrollAd(struct soap *soap, const struct __ns1__getSystemScrollAd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getSystemScrollAd(soap, &a->ns2__getSystemScrollAd_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSystemScrollAd(struct soap *soap, const char *tag, int id, const struct __ns1__getSystemScrollAd *a, const char *type)
{
	if (soap_out_PointerTons2__getSystemScrollAd(soap, "ns2:getSystemScrollAd", -1, &a->ns2__getSystemScrollAd_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSystemScrollAd * SOAP_FMAC4 soap_in___ns1__getSystemScrollAd(struct soap *soap, const char *tag, struct __ns1__getSystemScrollAd *a, const char *type)
{
	size_t soap_flag_ns2__getSystemScrollAd_ = 1;
	short soap_flag;
	a = (struct __ns1__getSystemScrollAd *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSystemScrollAd, sizeof(struct __ns1__getSystemScrollAd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSystemScrollAd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getSystemScrollAd_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getSystemScrollAd(soap, "ns2:getSystemScrollAd", &a->ns2__getSystemScrollAd_, "ns2:getSystemScrollAd"))
				{	soap_flag_ns2__getSystemScrollAd_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSystemScrollAd(struct soap *soap, const struct __ns1__getSystemScrollAd *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSystemScrollAd(soap, tag?tag:"-ns1:getSystemScrollAd", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSystemScrollAd * SOAP_FMAC4 soap_get___ns1__getSystemScrollAd(struct soap *soap, struct __ns1__getSystemScrollAd *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSystemScrollAd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSystemScrollAd * SOAP_FMAC2 soap_instantiate___ns1__getSystemScrollAd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSystemScrollAd(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSystemScrollAd, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSystemScrollAd);
		if (size)
			*size = sizeof(struct __ns1__getSystemScrollAd);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSystemScrollAd[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSystemScrollAd);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSystemScrollAd*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSystemScrollAd(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSystemScrollAd %p -> %p\n", q, p));
	*(struct __ns1__getSystemScrollAd*)p = *(struct __ns1__getSystemScrollAd*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMyGoodsInf(struct soap *soap, struct __ns1__getMyGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getMyGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMyGoodsInf(struct soap *soap, const struct __ns1__getMyGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getMyGoodsInf(soap, &a->ns2__getMyGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMyGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getMyGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getMyGoodsInf(soap, "ns2:getMyGoodsInf", -1, &a->ns2__getMyGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyGoodsInf * SOAP_FMAC4 soap_in___ns1__getMyGoodsInf(struct soap *soap, const char *tag, struct __ns1__getMyGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__getMyGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getMyGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMyGoodsInf, sizeof(struct __ns1__getMyGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMyGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getMyGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getMyGoodsInf(soap, "ns2:getMyGoodsInf", &a->ns2__getMyGoodsInf_, "ns2:getMyGoodsInf"))
				{	soap_flag_ns2__getMyGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMyGoodsInf(struct soap *soap, const struct __ns1__getMyGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMyGoodsInf(soap, tag?tag:"-ns1:getMyGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyGoodsInf * SOAP_FMAC4 soap_get___ns1__getMyGoodsInf(struct soap *soap, struct __ns1__getMyGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMyGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMyGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__getMyGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMyGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMyGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__getMyGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getMyGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getMyGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMyGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMyGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__getMyGoodsInf*)p = *(struct __ns1__getMyGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSearchGoodsInfNew(struct soap *soap, struct __ns1__getSearchGoodsInfNew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getSearchGoodsInfNew_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSearchGoodsInfNew(struct soap *soap, const struct __ns1__getSearchGoodsInfNew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getSearchGoodsInfNew(soap, &a->ns2__getSearchGoodsInfNew_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSearchGoodsInfNew(struct soap *soap, const char *tag, int id, const struct __ns1__getSearchGoodsInfNew *a, const char *type)
{
	if (soap_out_PointerTons2__getSearchGoodsInfNew(soap, "ns2:getSearchGoodsInfNew", -1, &a->ns2__getSearchGoodsInfNew_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchGoodsInfNew * SOAP_FMAC4 soap_in___ns1__getSearchGoodsInfNew(struct soap *soap, const char *tag, struct __ns1__getSearchGoodsInfNew *a, const char *type)
{
	size_t soap_flag_ns2__getSearchGoodsInfNew_ = 1;
	short soap_flag;
	a = (struct __ns1__getSearchGoodsInfNew *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSearchGoodsInfNew, sizeof(struct __ns1__getSearchGoodsInfNew), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSearchGoodsInfNew(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getSearchGoodsInfNew_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getSearchGoodsInfNew(soap, "ns2:getSearchGoodsInfNew", &a->ns2__getSearchGoodsInfNew_, "ns2:getSearchGoodsInfNew"))
				{	soap_flag_ns2__getSearchGoodsInfNew_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSearchGoodsInfNew(struct soap *soap, const struct __ns1__getSearchGoodsInfNew *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSearchGoodsInfNew(soap, tag?tag:"-ns1:getSearchGoodsInfNew", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchGoodsInfNew * SOAP_FMAC4 soap_get___ns1__getSearchGoodsInfNew(struct soap *soap, struct __ns1__getSearchGoodsInfNew *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSearchGoodsInfNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSearchGoodsInfNew * SOAP_FMAC2 soap_instantiate___ns1__getSearchGoodsInfNew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSearchGoodsInfNew(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSearchGoodsInfNew, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchGoodsInfNew);
		if (size)
			*size = sizeof(struct __ns1__getSearchGoodsInfNew);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchGoodsInfNew[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSearchGoodsInfNew);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSearchGoodsInfNew*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSearchGoodsInfNew(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSearchGoodsInfNew %p -> %p\n", q, p));
	*(struct __ns1__getSearchGoodsInfNew*)p = *(struct __ns1__getSearchGoodsInfNew*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSearchGoodsInf(struct soap *soap, struct __ns1__getSearchGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getSearchGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSearchGoodsInf(struct soap *soap, const struct __ns1__getSearchGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getSearchGoodsInf(soap, &a->ns2__getSearchGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSearchGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getSearchGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getSearchGoodsInf(soap, "ns2:getSearchGoodsInf", -1, &a->ns2__getSearchGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchGoodsInf * SOAP_FMAC4 soap_in___ns1__getSearchGoodsInf(struct soap *soap, const char *tag, struct __ns1__getSearchGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__getSearchGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getSearchGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSearchGoodsInf, sizeof(struct __ns1__getSearchGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSearchGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getSearchGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getSearchGoodsInf(soap, "ns2:getSearchGoodsInf", &a->ns2__getSearchGoodsInf_, "ns2:getSearchGoodsInf"))
				{	soap_flag_ns2__getSearchGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSearchGoodsInf(struct soap *soap, const struct __ns1__getSearchGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSearchGoodsInf(soap, tag?tag:"-ns1:getSearchGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchGoodsInf * SOAP_FMAC4 soap_get___ns1__getSearchGoodsInf(struct soap *soap, struct __ns1__getSearchGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSearchGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSearchGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__getSearchGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSearchGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSearchGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__getSearchGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSearchGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSearchGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSearchGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSearchGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__getSearchGoodsInf*)p = *(struct __ns1__getSearchGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__delGoodsInf(struct soap *soap, struct __ns1__delGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__delGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__delGoodsInf(struct soap *soap, const struct __ns1__delGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__delGoodsInf(soap, &a->ns2__delGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__delGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__delGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__delGoodsInf(soap, "ns2:delGoodsInf", -1, &a->ns2__delGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delGoodsInf * SOAP_FMAC4 soap_in___ns1__delGoodsInf(struct soap *soap, const char *tag, struct __ns1__delGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__delGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__delGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__delGoodsInf, sizeof(struct __ns1__delGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__delGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__delGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__delGoodsInf(soap, "ns2:delGoodsInf", &a->ns2__delGoodsInf_, "ns2:delGoodsInf"))
				{	soap_flag_ns2__delGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__delGoodsInf(struct soap *soap, const struct __ns1__delGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__delGoodsInf(soap, tag?tag:"-ns1:delGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delGoodsInf * SOAP_FMAC4 soap_get___ns1__delGoodsInf(struct soap *soap, struct __ns1__delGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__delGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__delGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__delGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__delGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__delGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__delGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__delGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__delGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__delGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__delGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__delGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__delGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__delGoodsInf*)p = *(struct __ns1__delGoodsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setGoodsStatus(struct soap *soap, struct __ns1__setGoodsStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__setGoodsStatus_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setGoodsStatus(struct soap *soap, const struct __ns1__setGoodsStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__setGoodsStatus(soap, &a->ns2__setGoodsStatus_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setGoodsStatus(struct soap *soap, const char *tag, int id, const struct __ns1__setGoodsStatus *a, const char *type)
{
	if (soap_out_PointerTons2__setGoodsStatus(soap, "ns2:setGoodsStatus", -1, &a->ns2__setGoodsStatus_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setGoodsStatus * SOAP_FMAC4 soap_in___ns1__setGoodsStatus(struct soap *soap, const char *tag, struct __ns1__setGoodsStatus *a, const char *type)
{
	size_t soap_flag_ns2__setGoodsStatus_ = 1;
	short soap_flag;
	a = (struct __ns1__setGoodsStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setGoodsStatus, sizeof(struct __ns1__setGoodsStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setGoodsStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__setGoodsStatus_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__setGoodsStatus(soap, "ns2:setGoodsStatus", &a->ns2__setGoodsStatus_, "ns2:setGoodsStatus"))
				{	soap_flag_ns2__setGoodsStatus_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setGoodsStatus(struct soap *soap, const struct __ns1__setGoodsStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setGoodsStatus(soap, tag?tag:"-ns1:setGoodsStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setGoodsStatus * SOAP_FMAC4 soap_get___ns1__setGoodsStatus(struct soap *soap, struct __ns1__setGoodsStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setGoodsStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setGoodsStatus * SOAP_FMAC2 soap_instantiate___ns1__setGoodsStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setGoodsStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setGoodsStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setGoodsStatus);
		if (size)
			*size = sizeof(struct __ns1__setGoodsStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setGoodsStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setGoodsStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setGoodsStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setGoodsStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setGoodsStatus %p -> %p\n", q, p));
	*(struct __ns1__setGoodsStatus*)p = *(struct __ns1__setGoodsStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCustomCarsInf(struct soap *soap, struct __ns1__getCustomCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getCustomCarsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCustomCarsInf(struct soap *soap, const struct __ns1__getCustomCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getCustomCarsInf(soap, &a->ns2__getCustomCarsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCustomCarsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getCustomCarsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getCustomCarsInf(soap, "ns2:getCustomCarsInf", -1, &a->ns2__getCustomCarsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCustomCarsInf * SOAP_FMAC4 soap_in___ns1__getCustomCarsInf(struct soap *soap, const char *tag, struct __ns1__getCustomCarsInf *a, const char *type)
{
	size_t soap_flag_ns2__getCustomCarsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getCustomCarsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCustomCarsInf, sizeof(struct __ns1__getCustomCarsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCustomCarsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getCustomCarsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getCustomCarsInf(soap, "ns2:getCustomCarsInf", &a->ns2__getCustomCarsInf_, "ns2:getCustomCarsInf"))
				{	soap_flag_ns2__getCustomCarsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCustomCarsInf(struct soap *soap, const struct __ns1__getCustomCarsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCustomCarsInf(soap, tag?tag:"-ns1:getCustomCarsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCustomCarsInf * SOAP_FMAC4 soap_get___ns1__getCustomCarsInf(struct soap *soap, struct __ns1__getCustomCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCustomCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getCustomCarsInf * SOAP_FMAC2 soap_instantiate___ns1__getCustomCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCustomCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCustomCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCustomCarsInf);
		if (size)
			*size = sizeof(struct __ns1__getCustomCarsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCustomCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getCustomCarsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getCustomCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCustomCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCustomCarsInf %p -> %p\n", q, p));
	*(struct __ns1__getCustomCarsInf*)p = *(struct __ns1__getCustomCarsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSearchSpecialLineInf(struct soap *soap, struct __ns1__getSearchSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getSearchSpecialLineInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSearchSpecialLineInf(struct soap *soap, const struct __ns1__getSearchSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getSearchSpecialLineInf(soap, &a->ns2__getSearchSpecialLineInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSearchSpecialLineInf(struct soap *soap, const char *tag, int id, const struct __ns1__getSearchSpecialLineInf *a, const char *type)
{
	if (soap_out_PointerTons2__getSearchSpecialLineInf(soap, "ns2:getSearchSpecialLineInf", -1, &a->ns2__getSearchSpecialLineInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchSpecialLineInf * SOAP_FMAC4 soap_in___ns1__getSearchSpecialLineInf(struct soap *soap, const char *tag, struct __ns1__getSearchSpecialLineInf *a, const char *type)
{
	size_t soap_flag_ns2__getSearchSpecialLineInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getSearchSpecialLineInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSearchSpecialLineInf, sizeof(struct __ns1__getSearchSpecialLineInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSearchSpecialLineInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getSearchSpecialLineInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getSearchSpecialLineInf(soap, "ns2:getSearchSpecialLineInf", &a->ns2__getSearchSpecialLineInf_, "ns2:getSearchSpecialLineInf"))
				{	soap_flag_ns2__getSearchSpecialLineInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSearchSpecialLineInf(struct soap *soap, const struct __ns1__getSearchSpecialLineInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSearchSpecialLineInf(soap, tag?tag:"-ns1:getSearchSpecialLineInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSearchSpecialLineInf * SOAP_FMAC4 soap_get___ns1__getSearchSpecialLineInf(struct soap *soap, struct __ns1__getSearchSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSearchSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSearchSpecialLineInf * SOAP_FMAC2 soap_instantiate___ns1__getSearchSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSearchSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSearchSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchSpecialLineInf);
		if (size)
			*size = sizeof(struct __ns1__getSearchSpecialLineInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSearchSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSearchSpecialLineInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSearchSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSearchSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSearchSpecialLineInf %p -> %p\n", q, p));
	*(struct __ns1__getSearchSpecialLineInf*)p = *(struct __ns1__getSearchSpecialLineInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getClickServiceStationInf(struct soap *soap, struct __ns1__getClickServiceStationInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getClickServiceStationInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getClickServiceStationInf(struct soap *soap, const struct __ns1__getClickServiceStationInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getClickServiceStationInf(soap, &a->ns2__getClickServiceStationInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getClickServiceStationInf(struct soap *soap, const char *tag, int id, const struct __ns1__getClickServiceStationInf *a, const char *type)
{
	if (soap_out_PointerTons2__getClickServiceStationInf(soap, "ns2:getClickServiceStationInf", -1, &a->ns2__getClickServiceStationInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClickServiceStationInf * SOAP_FMAC4 soap_in___ns1__getClickServiceStationInf(struct soap *soap, const char *tag, struct __ns1__getClickServiceStationInf *a, const char *type)
{
	size_t soap_flag_ns2__getClickServiceStationInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getClickServiceStationInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getClickServiceStationInf, sizeof(struct __ns1__getClickServiceStationInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getClickServiceStationInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getClickServiceStationInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getClickServiceStationInf(soap, "ns2:getClickServiceStationInf", &a->ns2__getClickServiceStationInf_, "ns2:getClickServiceStationInf"))
				{	soap_flag_ns2__getClickServiceStationInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getClickServiceStationInf(struct soap *soap, const struct __ns1__getClickServiceStationInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getClickServiceStationInf(soap, tag?tag:"-ns1:getClickServiceStationInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClickServiceStationInf * SOAP_FMAC4 soap_get___ns1__getClickServiceStationInf(struct soap *soap, struct __ns1__getClickServiceStationInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getClickServiceStationInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getClickServiceStationInf * SOAP_FMAC2 soap_instantiate___ns1__getClickServiceStationInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getClickServiceStationInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getClickServiceStationInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getClickServiceStationInf);
		if (size)
			*size = sizeof(struct __ns1__getClickServiceStationInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getClickServiceStationInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getClickServiceStationInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getClickServiceStationInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getClickServiceStationInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getClickServiceStationInf %p -> %p\n", q, p));
	*(struct __ns1__getClickServiceStationInf*)p = *(struct __ns1__getClickServiceStationInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setCarsStatus(struct soap *soap, struct __ns1__setCarsStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__setCarsStatus_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setCarsStatus(struct soap *soap, const struct __ns1__setCarsStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__setCarsStatus(soap, &a->ns2__setCarsStatus_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setCarsStatus(struct soap *soap, const char *tag, int id, const struct __ns1__setCarsStatus *a, const char *type)
{
	if (soap_out_PointerTons2__setCarsStatus(soap, "ns2:setCarsStatus", -1, &a->ns2__setCarsStatus_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setCarsStatus * SOAP_FMAC4 soap_in___ns1__setCarsStatus(struct soap *soap, const char *tag, struct __ns1__setCarsStatus *a, const char *type)
{
	size_t soap_flag_ns2__setCarsStatus_ = 1;
	short soap_flag;
	a = (struct __ns1__setCarsStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setCarsStatus, sizeof(struct __ns1__setCarsStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setCarsStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__setCarsStatus_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__setCarsStatus(soap, "ns2:setCarsStatus", &a->ns2__setCarsStatus_, "ns2:setCarsStatus"))
				{	soap_flag_ns2__setCarsStatus_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setCarsStatus(struct soap *soap, const struct __ns1__setCarsStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setCarsStatus(soap, tag?tag:"-ns1:setCarsStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setCarsStatus * SOAP_FMAC4 soap_get___ns1__setCarsStatus(struct soap *soap, struct __ns1__setCarsStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setCarsStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setCarsStatus * SOAP_FMAC2 soap_instantiate___ns1__setCarsStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setCarsStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setCarsStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setCarsStatus);
		if (size)
			*size = sizeof(struct __ns1__setCarsStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setCarsStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setCarsStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setCarsStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setCarsStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setCarsStatus %p -> %p\n", q, p));
	*(struct __ns1__setCarsStatus*)p = *(struct __ns1__setCarsStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendPhoneMessage(struct soap *soap, struct __ns1__sendPhoneMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__sendPhoneMessage_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendPhoneMessage(struct soap *soap, const struct __ns1__sendPhoneMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__sendPhoneMessage(soap, &a->ns2__sendPhoneMessage_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendPhoneMessage(struct soap *soap, const char *tag, int id, const struct __ns1__sendPhoneMessage *a, const char *type)
{
	if (soap_out_PointerTons2__sendPhoneMessage(soap, "ns2:sendPhoneMessage", -1, &a->ns2__sendPhoneMessage_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendPhoneMessage * SOAP_FMAC4 soap_in___ns1__sendPhoneMessage(struct soap *soap, const char *tag, struct __ns1__sendPhoneMessage *a, const char *type)
{
	size_t soap_flag_ns2__sendPhoneMessage_ = 1;
	short soap_flag;
	a = (struct __ns1__sendPhoneMessage *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendPhoneMessage, sizeof(struct __ns1__sendPhoneMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendPhoneMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__sendPhoneMessage_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__sendPhoneMessage(soap, "ns2:sendPhoneMessage", &a->ns2__sendPhoneMessage_, "ns2:sendPhoneMessage"))
				{	soap_flag_ns2__sendPhoneMessage_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendPhoneMessage(struct soap *soap, const struct __ns1__sendPhoneMessage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sendPhoneMessage(soap, tag?tag:"-ns1:sendPhoneMessage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendPhoneMessage * SOAP_FMAC4 soap_get___ns1__sendPhoneMessage(struct soap *soap, struct __ns1__sendPhoneMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendPhoneMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__sendPhoneMessage * SOAP_FMAC2 soap_instantiate___ns1__sendPhoneMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendPhoneMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__sendPhoneMessage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sendPhoneMessage);
		if (size)
			*size = sizeof(struct __ns1__sendPhoneMessage);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sendPhoneMessage[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__sendPhoneMessage);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__sendPhoneMessage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__sendPhoneMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__sendPhoneMessage %p -> %p\n", q, p));
	*(struct __ns1__sendPhoneMessage*)p = *(struct __ns1__sendPhoneMessage*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMyCarsInf(struct soap *soap, struct __ns1__getMyCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getMyCarsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMyCarsInf(struct soap *soap, const struct __ns1__getMyCarsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getMyCarsInf(soap, &a->ns2__getMyCarsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMyCarsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getMyCarsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getMyCarsInf(soap, "ns2:getMyCarsInf", -1, &a->ns2__getMyCarsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyCarsInf * SOAP_FMAC4 soap_in___ns1__getMyCarsInf(struct soap *soap, const char *tag, struct __ns1__getMyCarsInf *a, const char *type)
{
	size_t soap_flag_ns2__getMyCarsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getMyCarsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMyCarsInf, sizeof(struct __ns1__getMyCarsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMyCarsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getMyCarsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getMyCarsInf(soap, "ns2:getMyCarsInf", &a->ns2__getMyCarsInf_, "ns2:getMyCarsInf"))
				{	soap_flag_ns2__getMyCarsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMyCarsInf(struct soap *soap, const struct __ns1__getMyCarsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMyCarsInf(soap, tag?tag:"-ns1:getMyCarsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyCarsInf * SOAP_FMAC4 soap_get___ns1__getMyCarsInf(struct soap *soap, struct __ns1__getMyCarsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMyCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMyCarsInf * SOAP_FMAC2 soap_instantiate___ns1__getMyCarsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMyCarsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMyCarsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyCarsInf);
		if (size)
			*size = sizeof(struct __ns1__getMyCarsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyCarsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getMyCarsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getMyCarsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMyCarsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMyCarsInf %p -> %p\n", q, p));
	*(struct __ns1__getMyCarsInf*)p = *(struct __ns1__getMyCarsInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getUserCustomInf(struct soap *soap, struct __ns1__getUserCustomInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getUserCustomInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getUserCustomInf(struct soap *soap, const struct __ns1__getUserCustomInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getUserCustomInf(soap, &a->ns2__getUserCustomInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getUserCustomInf(struct soap *soap, const char *tag, int id, const struct __ns1__getUserCustomInf *a, const char *type)
{
	if (soap_out_PointerTons2__getUserCustomInf(soap, "ns2:getUserCustomInf", -1, &a->ns2__getUserCustomInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserCustomInf * SOAP_FMAC4 soap_in___ns1__getUserCustomInf(struct soap *soap, const char *tag, struct __ns1__getUserCustomInf *a, const char *type)
{
	size_t soap_flag_ns2__getUserCustomInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getUserCustomInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getUserCustomInf, sizeof(struct __ns1__getUserCustomInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getUserCustomInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getUserCustomInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getUserCustomInf(soap, "ns2:getUserCustomInf", &a->ns2__getUserCustomInf_, "ns2:getUserCustomInf"))
				{	soap_flag_ns2__getUserCustomInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getUserCustomInf(struct soap *soap, const struct __ns1__getUserCustomInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getUserCustomInf(soap, tag?tag:"-ns1:getUserCustomInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserCustomInf * SOAP_FMAC4 soap_get___ns1__getUserCustomInf(struct soap *soap, struct __ns1__getUserCustomInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getUserCustomInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getUserCustomInf * SOAP_FMAC2 soap_instantiate___ns1__getUserCustomInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getUserCustomInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getUserCustomInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getUserCustomInf);
		if (size)
			*size = sizeof(struct __ns1__getUserCustomInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getUserCustomInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getUserCustomInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getUserCustomInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getUserCustomInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getUserCustomInf %p -> %p\n", q, p));
	*(struct __ns1__getUserCustomInf*)p = *(struct __ns1__getUserCustomInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getFavoriteSpecialLineInf(struct soap *soap, struct __ns1__getFavoriteSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getFavoriteSpecialLineInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getFavoriteSpecialLineInf(struct soap *soap, const struct __ns1__getFavoriteSpecialLineInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getFavoriteSpecialLineInf(soap, &a->ns2__getFavoriteSpecialLineInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getFavoriteSpecialLineInf(struct soap *soap, const char *tag, int id, const struct __ns1__getFavoriteSpecialLineInf *a, const char *type)
{
	if (soap_out_PointerTons2__getFavoriteSpecialLineInf(soap, "ns2:getFavoriteSpecialLineInf", -1, &a->ns2__getFavoriteSpecialLineInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFavoriteSpecialLineInf * SOAP_FMAC4 soap_in___ns1__getFavoriteSpecialLineInf(struct soap *soap, const char *tag, struct __ns1__getFavoriteSpecialLineInf *a, const char *type)
{
	size_t soap_flag_ns2__getFavoriteSpecialLineInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getFavoriteSpecialLineInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getFavoriteSpecialLineInf, sizeof(struct __ns1__getFavoriteSpecialLineInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getFavoriteSpecialLineInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getFavoriteSpecialLineInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getFavoriteSpecialLineInf(soap, "ns2:getFavoriteSpecialLineInf", &a->ns2__getFavoriteSpecialLineInf_, "ns2:getFavoriteSpecialLineInf"))
				{	soap_flag_ns2__getFavoriteSpecialLineInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getFavoriteSpecialLineInf(struct soap *soap, const struct __ns1__getFavoriteSpecialLineInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getFavoriteSpecialLineInf(soap, tag?tag:"-ns1:getFavoriteSpecialLineInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFavoriteSpecialLineInf * SOAP_FMAC4 soap_get___ns1__getFavoriteSpecialLineInf(struct soap *soap, struct __ns1__getFavoriteSpecialLineInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getFavoriteSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getFavoriteSpecialLineInf * SOAP_FMAC2 soap_instantiate___ns1__getFavoriteSpecialLineInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getFavoriteSpecialLineInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getFavoriteSpecialLineInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getFavoriteSpecialLineInf);
		if (size)
			*size = sizeof(struct __ns1__getFavoriteSpecialLineInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getFavoriteSpecialLineInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getFavoriteSpecialLineInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getFavoriteSpecialLineInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getFavoriteSpecialLineInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getFavoriteSpecialLineInf %p -> %p\n", q, p));
	*(struct __ns1__getFavoriteSpecialLineInf*)p = *(struct __ns1__getFavoriteSpecialLineInf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__collectSpecialLine(struct soap *soap, struct __ns1__collectSpecialLine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__collectSpecialLine_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__collectSpecialLine(struct soap *soap, const struct __ns1__collectSpecialLine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__collectSpecialLine(soap, &a->ns2__collectSpecialLine_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__collectSpecialLine(struct soap *soap, const char *tag, int id, const struct __ns1__collectSpecialLine *a, const char *type)
{
	if (soap_out_PointerTons2__collectSpecialLine(soap, "ns2:collectSpecialLine", -1, &a->ns2__collectSpecialLine_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__collectSpecialLine * SOAP_FMAC4 soap_in___ns1__collectSpecialLine(struct soap *soap, const char *tag, struct __ns1__collectSpecialLine *a, const char *type)
{
	size_t soap_flag_ns2__collectSpecialLine_ = 1;
	short soap_flag;
	a = (struct __ns1__collectSpecialLine *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__collectSpecialLine, sizeof(struct __ns1__collectSpecialLine), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__collectSpecialLine(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__collectSpecialLine_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__collectSpecialLine(soap, "ns2:collectSpecialLine", &a->ns2__collectSpecialLine_, "ns2:collectSpecialLine"))
				{	soap_flag_ns2__collectSpecialLine_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__collectSpecialLine(struct soap *soap, const struct __ns1__collectSpecialLine *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__collectSpecialLine(soap, tag?tag:"-ns1:collectSpecialLine", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__collectSpecialLine * SOAP_FMAC4 soap_get___ns1__collectSpecialLine(struct soap *soap, struct __ns1__collectSpecialLine *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__collectSpecialLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__collectSpecialLine * SOAP_FMAC2 soap_instantiate___ns1__collectSpecialLine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__collectSpecialLine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__collectSpecialLine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__collectSpecialLine);
		if (size)
			*size = sizeof(struct __ns1__collectSpecialLine);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__collectSpecialLine[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__collectSpecialLine);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__collectSpecialLine*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__collectSpecialLine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__collectSpecialLine %p -> %p\n", q, p));
	*(struct __ns1__collectSpecialLine*)p = *(struct __ns1__collectSpecialLine*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getNewBulkGoodsInf(struct soap *soap, struct __ns1__getNewBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getNewBulkGoodsInf_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getNewBulkGoodsInf(struct soap *soap, const struct __ns1__getNewBulkGoodsInf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__getNewBulkGoodsInf(soap, &a->ns2__getNewBulkGoodsInf_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getNewBulkGoodsInf(struct soap *soap, const char *tag, int id, const struct __ns1__getNewBulkGoodsInf *a, const char *type)
{
	if (soap_out_PointerTons2__getNewBulkGoodsInf(soap, "ns2:getNewBulkGoodsInf", -1, &a->ns2__getNewBulkGoodsInf_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNewBulkGoodsInf * SOAP_FMAC4 soap_in___ns1__getNewBulkGoodsInf(struct soap *soap, const char *tag, struct __ns1__getNewBulkGoodsInf *a, const char *type)
{
	size_t soap_flag_ns2__getNewBulkGoodsInf_ = 1;
	short soap_flag;
	a = (struct __ns1__getNewBulkGoodsInf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getNewBulkGoodsInf, sizeof(struct __ns1__getNewBulkGoodsInf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getNewBulkGoodsInf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getNewBulkGoodsInf_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__getNewBulkGoodsInf(soap, "ns2:getNewBulkGoodsInf", &a->ns2__getNewBulkGoodsInf_, "ns2:getNewBulkGoodsInf"))
				{	soap_flag_ns2__getNewBulkGoodsInf_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getNewBulkGoodsInf(struct soap *soap, const struct __ns1__getNewBulkGoodsInf *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getNewBulkGoodsInf(soap, tag?tag:"-ns1:getNewBulkGoodsInf", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNewBulkGoodsInf * SOAP_FMAC4 soap_get___ns1__getNewBulkGoodsInf(struct soap *soap, struct __ns1__getNewBulkGoodsInf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getNewBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getNewBulkGoodsInf * SOAP_FMAC2 soap_instantiate___ns1__getNewBulkGoodsInf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getNewBulkGoodsInf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getNewBulkGoodsInf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getNewBulkGoodsInf);
		if (size)
			*size = sizeof(struct __ns1__getNewBulkGoodsInf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getNewBulkGoodsInf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getNewBulkGoodsInf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getNewBulkGoodsInf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getNewBulkGoodsInf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getNewBulkGoodsInf %p -> %p\n", q, p));
	*(struct __ns1__getNewBulkGoodsInf*)p = *(struct __ns1__getNewBulkGoodsInf*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchCarsInfResponse(struct soap *soap, ns2__getSearchCarsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchCarsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchCarsInfResponse(struct soap *soap, const char *tag, int id, ns2__getSearchCarsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchCarsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchCarsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getSearchCarsInfResponse(struct soap *soap, const char *tag, ns2__getSearchCarsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchCarsInfResponse **)soap_malloc(soap, sizeof(ns2__getSearchCarsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchCarsInfResponse *)soap_instantiate_ns2__getSearchCarsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchCarsInfResponse ** p = (ns2__getSearchCarsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchCarsInfResponse, sizeof(ns2__getSearchCarsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchCarsInfResponse(struct soap *soap, ns2__getSearchCarsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchCarsInfResponse);
	if (soap_out_PointerTons2__getSearchCarsInfResponse(soap, tag?tag:"ns2:getSearchCarsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchCarsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getSearchCarsInfResponse(struct soap *soap, ns2__getSearchCarsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchCarsInf(struct soap *soap, ns2__getSearchCarsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchCarsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchCarsInf(struct soap *soap, const char *tag, int id, ns2__getSearchCarsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchCarsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchCarsInf ** SOAP_FMAC4 soap_in_PointerTons2__getSearchCarsInf(struct soap *soap, const char *tag, ns2__getSearchCarsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchCarsInf **)soap_malloc(soap, sizeof(ns2__getSearchCarsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchCarsInf *)soap_instantiate_ns2__getSearchCarsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchCarsInf ** p = (ns2__getSearchCarsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchCarsInf, sizeof(ns2__getSearchCarsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchCarsInf(struct soap *soap, ns2__getSearchCarsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchCarsInf);
	if (soap_out_PointerTons2__getSearchCarsInf(soap, tag?tag:"ns2:getSearchCarsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchCarsInf ** SOAP_FMAC4 soap_get_PointerTons2__getSearchCarsInf(struct soap *soap, ns2__getSearchCarsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getAgentPopAdResponse(struct soap *soap, ns2__getAgentPopAdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getAgentPopAdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getAgentPopAdResponse(struct soap *soap, const char *tag, int id, ns2__getAgentPopAdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getAgentPopAdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getAgentPopAdResponse ** SOAP_FMAC4 soap_in_PointerTons2__getAgentPopAdResponse(struct soap *soap, const char *tag, ns2__getAgentPopAdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getAgentPopAdResponse **)soap_malloc(soap, sizeof(ns2__getAgentPopAdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getAgentPopAdResponse *)soap_instantiate_ns2__getAgentPopAdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getAgentPopAdResponse ** p = (ns2__getAgentPopAdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getAgentPopAdResponse, sizeof(ns2__getAgentPopAdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getAgentPopAdResponse(struct soap *soap, ns2__getAgentPopAdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getAgentPopAdResponse);
	if (soap_out_PointerTons2__getAgentPopAdResponse(soap, tag?tag:"ns2:getAgentPopAdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getAgentPopAdResponse ** SOAP_FMAC4 soap_get_PointerTons2__getAgentPopAdResponse(struct soap *soap, ns2__getAgentPopAdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getAgentPopAdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getAgentPopAd(struct soap *soap, ns2__getAgentPopAd *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getAgentPopAd))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getAgentPopAd(struct soap *soap, const char *tag, int id, ns2__getAgentPopAd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getAgentPopAd);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getAgentPopAd ** SOAP_FMAC4 soap_in_PointerTons2__getAgentPopAd(struct soap *soap, const char *tag, ns2__getAgentPopAd **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getAgentPopAd **)soap_malloc(soap, sizeof(ns2__getAgentPopAd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getAgentPopAd *)soap_instantiate_ns2__getAgentPopAd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getAgentPopAd ** p = (ns2__getAgentPopAd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getAgentPopAd, sizeof(ns2__getAgentPopAd), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getAgentPopAd(struct soap *soap, ns2__getAgentPopAd *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getAgentPopAd);
	if (soap_out_PointerTons2__getAgentPopAd(soap, tag?tag:"ns2:getAgentPopAd", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getAgentPopAd ** SOAP_FMAC4 soap_get_PointerTons2__getAgentPopAd(struct soap *soap, ns2__getAgentPopAd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getAgentPopAd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchCarsInfNewResponse(struct soap *soap, ns2__getSearchCarsInfNewResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchCarsInfNewResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchCarsInfNewResponse(struct soap *soap, const char *tag, int id, ns2__getSearchCarsInfNewResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchCarsInfNewResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchCarsInfNewResponse ** SOAP_FMAC4 soap_in_PointerTons2__getSearchCarsInfNewResponse(struct soap *soap, const char *tag, ns2__getSearchCarsInfNewResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchCarsInfNewResponse **)soap_malloc(soap, sizeof(ns2__getSearchCarsInfNewResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchCarsInfNewResponse *)soap_instantiate_ns2__getSearchCarsInfNewResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchCarsInfNewResponse ** p = (ns2__getSearchCarsInfNewResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchCarsInfNewResponse, sizeof(ns2__getSearchCarsInfNewResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchCarsInfNewResponse(struct soap *soap, ns2__getSearchCarsInfNewResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchCarsInfNewResponse);
	if (soap_out_PointerTons2__getSearchCarsInfNewResponse(soap, tag?tag:"ns2:getSearchCarsInfNewResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchCarsInfNewResponse ** SOAP_FMAC4 soap_get_PointerTons2__getSearchCarsInfNewResponse(struct soap *soap, ns2__getSearchCarsInfNewResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchCarsInfNewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchCarsInfNew(struct soap *soap, ns2__getSearchCarsInfNew *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchCarsInfNew))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchCarsInfNew(struct soap *soap, const char *tag, int id, ns2__getSearchCarsInfNew *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchCarsInfNew);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchCarsInfNew ** SOAP_FMAC4 soap_in_PointerTons2__getSearchCarsInfNew(struct soap *soap, const char *tag, ns2__getSearchCarsInfNew **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchCarsInfNew **)soap_malloc(soap, sizeof(ns2__getSearchCarsInfNew *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchCarsInfNew *)soap_instantiate_ns2__getSearchCarsInfNew(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchCarsInfNew ** p = (ns2__getSearchCarsInfNew **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchCarsInfNew, sizeof(ns2__getSearchCarsInfNew), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchCarsInfNew(struct soap *soap, ns2__getSearchCarsInfNew *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchCarsInfNew);
	if (soap_out_PointerTons2__getSearchCarsInfNew(soap, tag?tag:"ns2:getSearchCarsInfNew", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchCarsInfNew ** SOAP_FMAC4 soap_get_PointerTons2__getSearchCarsInfNew(struct soap *soap, ns2__getSearchCarsInfNew **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchCarsInfNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__delFavoriteSpecialLineResponse(struct soap *soap, ns2__delFavoriteSpecialLineResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__delFavoriteSpecialLineResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__delFavoriteSpecialLineResponse(struct soap *soap, const char *tag, int id, ns2__delFavoriteSpecialLineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__delFavoriteSpecialLineResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__delFavoriteSpecialLineResponse ** SOAP_FMAC4 soap_in_PointerTons2__delFavoriteSpecialLineResponse(struct soap *soap, const char *tag, ns2__delFavoriteSpecialLineResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__delFavoriteSpecialLineResponse **)soap_malloc(soap, sizeof(ns2__delFavoriteSpecialLineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__delFavoriteSpecialLineResponse *)soap_instantiate_ns2__delFavoriteSpecialLineResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__delFavoriteSpecialLineResponse ** p = (ns2__delFavoriteSpecialLineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__delFavoriteSpecialLineResponse, sizeof(ns2__delFavoriteSpecialLineResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__delFavoriteSpecialLineResponse(struct soap *soap, ns2__delFavoriteSpecialLineResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__delFavoriteSpecialLineResponse);
	if (soap_out_PointerTons2__delFavoriteSpecialLineResponse(soap, tag?tag:"ns2:delFavoriteSpecialLineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__delFavoriteSpecialLineResponse ** SOAP_FMAC4 soap_get_PointerTons2__delFavoriteSpecialLineResponse(struct soap *soap, ns2__delFavoriteSpecialLineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__delFavoriteSpecialLineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__delFavoriteSpecialLine(struct soap *soap, ns2__delFavoriteSpecialLine *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__delFavoriteSpecialLine))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__delFavoriteSpecialLine(struct soap *soap, const char *tag, int id, ns2__delFavoriteSpecialLine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__delFavoriteSpecialLine);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__delFavoriteSpecialLine ** SOAP_FMAC4 soap_in_PointerTons2__delFavoriteSpecialLine(struct soap *soap, const char *tag, ns2__delFavoriteSpecialLine **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__delFavoriteSpecialLine **)soap_malloc(soap, sizeof(ns2__delFavoriteSpecialLine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__delFavoriteSpecialLine *)soap_instantiate_ns2__delFavoriteSpecialLine(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__delFavoriteSpecialLine ** p = (ns2__delFavoriteSpecialLine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__delFavoriteSpecialLine, sizeof(ns2__delFavoriteSpecialLine), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__delFavoriteSpecialLine(struct soap *soap, ns2__delFavoriteSpecialLine *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__delFavoriteSpecialLine);
	if (soap_out_PointerTons2__delFavoriteSpecialLine(soap, tag?tag:"ns2:delFavoriteSpecialLine", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__delFavoriteSpecialLine ** SOAP_FMAC4 soap_get_PointerTons2__delFavoriteSpecialLine(struct soap *soap, ns2__delFavoriteSpecialLine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__delFavoriteSpecialLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getNewGoodsInfResponse(struct soap *soap, ns2__getNewGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getNewGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getNewGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__getNewGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getNewGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getNewGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getNewGoodsInfResponse(struct soap *soap, const char *tag, ns2__getNewGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getNewGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__getNewGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getNewGoodsInfResponse *)soap_instantiate_ns2__getNewGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getNewGoodsInfResponse ** p = (ns2__getNewGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getNewGoodsInfResponse, sizeof(ns2__getNewGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getNewGoodsInfResponse(struct soap *soap, ns2__getNewGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getNewGoodsInfResponse);
	if (soap_out_PointerTons2__getNewGoodsInfResponse(soap, tag?tag:"ns2:getNewGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getNewGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getNewGoodsInfResponse(struct soap *soap, ns2__getNewGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getNewGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getNewGoodsInf(struct soap *soap, ns2__getNewGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getNewGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getNewGoodsInf(struct soap *soap, const char *tag, int id, ns2__getNewGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getNewGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getNewGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__getNewGoodsInf(struct soap *soap, const char *tag, ns2__getNewGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getNewGoodsInf **)soap_malloc(soap, sizeof(ns2__getNewGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getNewGoodsInf *)soap_instantiate_ns2__getNewGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getNewGoodsInf ** p = (ns2__getNewGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getNewGoodsInf, sizeof(ns2__getNewGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getNewGoodsInf(struct soap *soap, ns2__getNewGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getNewGoodsInf);
	if (soap_out_PointerTons2__getNewGoodsInf(soap, tag?tag:"ns2:getNewGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getNewGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__getNewGoodsInf(struct soap *soap, ns2__getNewGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getNewGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setPubSpecialLineInfResponse(struct soap *soap, ns2__setPubSpecialLineInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setPubSpecialLineInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setPubSpecialLineInfResponse(struct soap *soap, const char *tag, int id, ns2__setPubSpecialLineInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setPubSpecialLineInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setPubSpecialLineInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__setPubSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__setPubSpecialLineInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setPubSpecialLineInfResponse **)soap_malloc(soap, sizeof(ns2__setPubSpecialLineInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setPubSpecialLineInfResponse *)soap_instantiate_ns2__setPubSpecialLineInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setPubSpecialLineInfResponse ** p = (ns2__setPubSpecialLineInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setPubSpecialLineInfResponse, sizeof(ns2__setPubSpecialLineInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setPubSpecialLineInfResponse(struct soap *soap, ns2__setPubSpecialLineInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setPubSpecialLineInfResponse);
	if (soap_out_PointerTons2__setPubSpecialLineInfResponse(soap, tag?tag:"ns2:setPubSpecialLineInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setPubSpecialLineInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__setPubSpecialLineInfResponse(struct soap *soap, ns2__setPubSpecialLineInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setPubSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setPubSpecialLineInf(struct soap *soap, ns2__setPubSpecialLineInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setPubSpecialLineInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setPubSpecialLineInf(struct soap *soap, const char *tag, int id, ns2__setPubSpecialLineInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setPubSpecialLineInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setPubSpecialLineInf ** SOAP_FMAC4 soap_in_PointerTons2__setPubSpecialLineInf(struct soap *soap, const char *tag, ns2__setPubSpecialLineInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setPubSpecialLineInf **)soap_malloc(soap, sizeof(ns2__setPubSpecialLineInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setPubSpecialLineInf *)soap_instantiate_ns2__setPubSpecialLineInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setPubSpecialLineInf ** p = (ns2__setPubSpecialLineInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setPubSpecialLineInf, sizeof(ns2__setPubSpecialLineInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setPubSpecialLineInf(struct soap *soap, ns2__setPubSpecialLineInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setPubSpecialLineInf);
	if (soap_out_PointerTons2__setPubSpecialLineInf(soap, tag?tag:"ns2:setPubSpecialLineInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setPubSpecialLineInf ** SOAP_FMAC4 soap_get_PointerTons2__setPubSpecialLineInf(struct soap *soap, ns2__setPubSpecialLineInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setPubSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getMySpecialLineInfResponse(struct soap *soap, ns2__getMySpecialLineInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getMySpecialLineInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getMySpecialLineInfResponse(struct soap *soap, const char *tag, int id, ns2__getMySpecialLineInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getMySpecialLineInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getMySpecialLineInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getMySpecialLineInfResponse(struct soap *soap, const char *tag, ns2__getMySpecialLineInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getMySpecialLineInfResponse **)soap_malloc(soap, sizeof(ns2__getMySpecialLineInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getMySpecialLineInfResponse *)soap_instantiate_ns2__getMySpecialLineInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getMySpecialLineInfResponse ** p = (ns2__getMySpecialLineInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getMySpecialLineInfResponse, sizeof(ns2__getMySpecialLineInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getMySpecialLineInfResponse(struct soap *soap, ns2__getMySpecialLineInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getMySpecialLineInfResponse);
	if (soap_out_PointerTons2__getMySpecialLineInfResponse(soap, tag?tag:"ns2:getMySpecialLineInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getMySpecialLineInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getMySpecialLineInfResponse(struct soap *soap, ns2__getMySpecialLineInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getMySpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getMySpecialLineInf(struct soap *soap, ns2__getMySpecialLineInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getMySpecialLineInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getMySpecialLineInf(struct soap *soap, const char *tag, int id, ns2__getMySpecialLineInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getMySpecialLineInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getMySpecialLineInf ** SOAP_FMAC4 soap_in_PointerTons2__getMySpecialLineInf(struct soap *soap, const char *tag, ns2__getMySpecialLineInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getMySpecialLineInf **)soap_malloc(soap, sizeof(ns2__getMySpecialLineInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getMySpecialLineInf *)soap_instantiate_ns2__getMySpecialLineInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getMySpecialLineInf ** p = (ns2__getMySpecialLineInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getMySpecialLineInf, sizeof(ns2__getMySpecialLineInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getMySpecialLineInf(struct soap *soap, ns2__getMySpecialLineInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getMySpecialLineInf);
	if (soap_out_PointerTons2__getMySpecialLineInf(soap, tag?tag:"ns2:getMySpecialLineInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getMySpecialLineInf ** SOAP_FMAC4 soap_get_PointerTons2__getMySpecialLineInf(struct soap *soap, ns2__getMySpecialLineInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getMySpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__delCarsInfResponse(struct soap *soap, ns2__delCarsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__delCarsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__delCarsInfResponse(struct soap *soap, const char *tag, int id, ns2__delCarsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__delCarsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__delCarsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__delCarsInfResponse(struct soap *soap, const char *tag, ns2__delCarsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__delCarsInfResponse **)soap_malloc(soap, sizeof(ns2__delCarsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__delCarsInfResponse *)soap_instantiate_ns2__delCarsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__delCarsInfResponse ** p = (ns2__delCarsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__delCarsInfResponse, sizeof(ns2__delCarsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__delCarsInfResponse(struct soap *soap, ns2__delCarsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__delCarsInfResponse);
	if (soap_out_PointerTons2__delCarsInfResponse(soap, tag?tag:"ns2:delCarsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__delCarsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__delCarsInfResponse(struct soap *soap, ns2__delCarsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__delCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__delCarsInf(struct soap *soap, ns2__delCarsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__delCarsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__delCarsInf(struct soap *soap, const char *tag, int id, ns2__delCarsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__delCarsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__delCarsInf ** SOAP_FMAC4 soap_in_PointerTons2__delCarsInf(struct soap *soap, const char *tag, ns2__delCarsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__delCarsInf **)soap_malloc(soap, sizeof(ns2__delCarsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__delCarsInf *)soap_instantiate_ns2__delCarsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__delCarsInf ** p = (ns2__delCarsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__delCarsInf, sizeof(ns2__delCarsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__delCarsInf(struct soap *soap, ns2__delCarsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__delCarsInf);
	if (soap_out_PointerTons2__delCarsInf(soap, tag?tag:"ns2:delCarsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__delCarsInf ** SOAP_FMAC4 soap_get_PointerTons2__delCarsInf(struct soap *soap, ns2__delCarsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__delCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getPersisCarsInfoResponse(struct soap *soap, ns2__getPersisCarsInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getPersisCarsInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getPersisCarsInfoResponse(struct soap *soap, const char *tag, int id, ns2__getPersisCarsInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getPersisCarsInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getPersisCarsInfoResponse ** SOAP_FMAC4 soap_in_PointerTons2__getPersisCarsInfoResponse(struct soap *soap, const char *tag, ns2__getPersisCarsInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getPersisCarsInfoResponse **)soap_malloc(soap, sizeof(ns2__getPersisCarsInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getPersisCarsInfoResponse *)soap_instantiate_ns2__getPersisCarsInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getPersisCarsInfoResponse ** p = (ns2__getPersisCarsInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getPersisCarsInfoResponse, sizeof(ns2__getPersisCarsInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getPersisCarsInfoResponse(struct soap *soap, ns2__getPersisCarsInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getPersisCarsInfoResponse);
	if (soap_out_PointerTons2__getPersisCarsInfoResponse(soap, tag?tag:"ns2:getPersisCarsInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getPersisCarsInfoResponse ** SOAP_FMAC4 soap_get_PointerTons2__getPersisCarsInfoResponse(struct soap *soap, ns2__getPersisCarsInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getPersisCarsInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getPersisCarsInfo(struct soap *soap, ns2__getPersisCarsInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getPersisCarsInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getPersisCarsInfo(struct soap *soap, const char *tag, int id, ns2__getPersisCarsInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getPersisCarsInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getPersisCarsInfo ** SOAP_FMAC4 soap_in_PointerTons2__getPersisCarsInfo(struct soap *soap, const char *tag, ns2__getPersisCarsInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getPersisCarsInfo **)soap_malloc(soap, sizeof(ns2__getPersisCarsInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getPersisCarsInfo *)soap_instantiate_ns2__getPersisCarsInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getPersisCarsInfo ** p = (ns2__getPersisCarsInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getPersisCarsInfo, sizeof(ns2__getPersisCarsInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getPersisCarsInfo(struct soap *soap, ns2__getPersisCarsInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getPersisCarsInfo);
	if (soap_out_PointerTons2__getPersisCarsInfo(soap, tag?tag:"ns2:getPersisCarsInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getPersisCarsInfo ** SOAP_FMAC4 soap_get_PointerTons2__getPersisCarsInfo(struct soap *soap, ns2__getPersisCarsInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getPersisCarsInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__placeOrderResponse(struct soap *soap, ns2__placeOrderResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__placeOrderResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__placeOrderResponse(struct soap *soap, const char *tag, int id, ns2__placeOrderResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__placeOrderResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__placeOrderResponse ** SOAP_FMAC4 soap_in_PointerTons2__placeOrderResponse(struct soap *soap, const char *tag, ns2__placeOrderResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__placeOrderResponse **)soap_malloc(soap, sizeof(ns2__placeOrderResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__placeOrderResponse *)soap_instantiate_ns2__placeOrderResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__placeOrderResponse ** p = (ns2__placeOrderResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__placeOrderResponse, sizeof(ns2__placeOrderResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__placeOrderResponse(struct soap *soap, ns2__placeOrderResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__placeOrderResponse);
	if (soap_out_PointerTons2__placeOrderResponse(soap, tag?tag:"ns2:placeOrderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__placeOrderResponse ** SOAP_FMAC4 soap_get_PointerTons2__placeOrderResponse(struct soap *soap, ns2__placeOrderResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__placeOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__placeOrder(struct soap *soap, ns2__placeOrder *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__placeOrder))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__placeOrder(struct soap *soap, const char *tag, int id, ns2__placeOrder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__placeOrder);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__placeOrder ** SOAP_FMAC4 soap_in_PointerTons2__placeOrder(struct soap *soap, const char *tag, ns2__placeOrder **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__placeOrder **)soap_malloc(soap, sizeof(ns2__placeOrder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__placeOrder *)soap_instantiate_ns2__placeOrder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__placeOrder ** p = (ns2__placeOrder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__placeOrder, sizeof(ns2__placeOrder), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__placeOrder(struct soap *soap, ns2__placeOrder *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__placeOrder);
	if (soap_out_PointerTons2__placeOrder(soap, tag?tag:"ns2:placeOrder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__placeOrder ** SOAP_FMAC4 soap_get_PointerTons2__placeOrder(struct soap *soap, ns2__placeOrder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__placeOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__browseZoneCarsResponse(struct soap *soap, ns2__browseZoneCarsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__browseZoneCarsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__browseZoneCarsResponse(struct soap *soap, const char *tag, int id, ns2__browseZoneCarsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__browseZoneCarsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__browseZoneCarsResponse ** SOAP_FMAC4 soap_in_PointerTons2__browseZoneCarsResponse(struct soap *soap, const char *tag, ns2__browseZoneCarsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__browseZoneCarsResponse **)soap_malloc(soap, sizeof(ns2__browseZoneCarsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__browseZoneCarsResponse *)soap_instantiate_ns2__browseZoneCarsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__browseZoneCarsResponse ** p = (ns2__browseZoneCarsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__browseZoneCarsResponse, sizeof(ns2__browseZoneCarsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__browseZoneCarsResponse(struct soap *soap, ns2__browseZoneCarsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__browseZoneCarsResponse);
	if (soap_out_PointerTons2__browseZoneCarsResponse(soap, tag?tag:"ns2:browseZoneCarsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__browseZoneCarsResponse ** SOAP_FMAC4 soap_get_PointerTons2__browseZoneCarsResponse(struct soap *soap, ns2__browseZoneCarsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__browseZoneCarsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__browseZoneCars(struct soap *soap, ns2__browseZoneCars *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__browseZoneCars))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__browseZoneCars(struct soap *soap, const char *tag, int id, ns2__browseZoneCars *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__browseZoneCars);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__browseZoneCars ** SOAP_FMAC4 soap_in_PointerTons2__browseZoneCars(struct soap *soap, const char *tag, ns2__browseZoneCars **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__browseZoneCars **)soap_malloc(soap, sizeof(ns2__browseZoneCars *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__browseZoneCars *)soap_instantiate_ns2__browseZoneCars(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__browseZoneCars ** p = (ns2__browseZoneCars **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__browseZoneCars, sizeof(ns2__browseZoneCars), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__browseZoneCars(struct soap *soap, ns2__browseZoneCars *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__browseZoneCars);
	if (soap_out_PointerTons2__browseZoneCars(soap, tag?tag:"ns2:browseZoneCars", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__browseZoneCars ** SOAP_FMAC4 soap_get_PointerTons2__browseZoneCars(struct soap *soap, ns2__browseZoneCars **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__browseZoneCars(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getPersisGoodsInfoResponse(struct soap *soap, ns2__getPersisGoodsInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getPersisGoodsInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getPersisGoodsInfoResponse(struct soap *soap, const char *tag, int id, ns2__getPersisGoodsInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getPersisGoodsInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getPersisGoodsInfoResponse ** SOAP_FMAC4 soap_in_PointerTons2__getPersisGoodsInfoResponse(struct soap *soap, const char *tag, ns2__getPersisGoodsInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getPersisGoodsInfoResponse **)soap_malloc(soap, sizeof(ns2__getPersisGoodsInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getPersisGoodsInfoResponse *)soap_instantiate_ns2__getPersisGoodsInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getPersisGoodsInfoResponse ** p = (ns2__getPersisGoodsInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getPersisGoodsInfoResponse, sizeof(ns2__getPersisGoodsInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getPersisGoodsInfoResponse(struct soap *soap, ns2__getPersisGoodsInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getPersisGoodsInfoResponse);
	if (soap_out_PointerTons2__getPersisGoodsInfoResponse(soap, tag?tag:"ns2:getPersisGoodsInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getPersisGoodsInfoResponse ** SOAP_FMAC4 soap_get_PointerTons2__getPersisGoodsInfoResponse(struct soap *soap, ns2__getPersisGoodsInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getPersisGoodsInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getPersisGoodsInfo(struct soap *soap, ns2__getPersisGoodsInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getPersisGoodsInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getPersisGoodsInfo(struct soap *soap, const char *tag, int id, ns2__getPersisGoodsInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getPersisGoodsInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getPersisGoodsInfo ** SOAP_FMAC4 soap_in_PointerTons2__getPersisGoodsInfo(struct soap *soap, const char *tag, ns2__getPersisGoodsInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getPersisGoodsInfo **)soap_malloc(soap, sizeof(ns2__getPersisGoodsInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getPersisGoodsInfo *)soap_instantiate_ns2__getPersisGoodsInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getPersisGoodsInfo ** p = (ns2__getPersisGoodsInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getPersisGoodsInfo, sizeof(ns2__getPersisGoodsInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getPersisGoodsInfo(struct soap *soap, ns2__getPersisGoodsInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getPersisGoodsInfo);
	if (soap_out_PointerTons2__getPersisGoodsInfo(soap, tag?tag:"ns2:getPersisGoodsInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getPersisGoodsInfo ** SOAP_FMAC4 soap_get_PointerTons2__getPersisGoodsInfo(struct soap *soap, ns2__getPersisGoodsInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getPersisGoodsInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__usrLoginResponse(struct soap *soap, ns2__usrLoginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__usrLoginResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__usrLoginResponse(struct soap *soap, const char *tag, int id, ns2__usrLoginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__usrLoginResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__usrLoginResponse ** SOAP_FMAC4 soap_in_PointerTons2__usrLoginResponse(struct soap *soap, const char *tag, ns2__usrLoginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__usrLoginResponse **)soap_malloc(soap, sizeof(ns2__usrLoginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__usrLoginResponse *)soap_instantiate_ns2__usrLoginResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__usrLoginResponse ** p = (ns2__usrLoginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__usrLoginResponse, sizeof(ns2__usrLoginResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__usrLoginResponse(struct soap *soap, ns2__usrLoginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__usrLoginResponse);
	if (soap_out_PointerTons2__usrLoginResponse(soap, tag?tag:"ns2:usrLoginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__usrLoginResponse ** SOAP_FMAC4 soap_get_PointerTons2__usrLoginResponse(struct soap *soap, ns2__usrLoginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__usrLoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__usrLogin(struct soap *soap, ns2__usrLogin *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__usrLogin))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__usrLogin(struct soap *soap, const char *tag, int id, ns2__usrLogin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__usrLogin);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__usrLogin ** SOAP_FMAC4 soap_in_PointerTons2__usrLogin(struct soap *soap, const char *tag, ns2__usrLogin **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__usrLogin **)soap_malloc(soap, sizeof(ns2__usrLogin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__usrLogin *)soap_instantiate_ns2__usrLogin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__usrLogin ** p = (ns2__usrLogin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__usrLogin, sizeof(ns2__usrLogin), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__usrLogin(struct soap *soap, ns2__usrLogin *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__usrLogin);
	if (soap_out_PointerTons2__usrLogin(soap, tag?tag:"ns2:usrLogin", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__usrLogin ** SOAP_FMAC4 soap_get_PointerTons2__usrLogin(struct soap *soap, ns2__usrLogin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__usrLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__delBulkGoodsInfResponse(struct soap *soap, ns2__delBulkGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__delBulkGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__delBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__delBulkGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__delBulkGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__delBulkGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__delBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__delBulkGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__delBulkGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__delBulkGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__delBulkGoodsInfResponse *)soap_instantiate_ns2__delBulkGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__delBulkGoodsInfResponse ** p = (ns2__delBulkGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__delBulkGoodsInfResponse, sizeof(ns2__delBulkGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__delBulkGoodsInfResponse(struct soap *soap, ns2__delBulkGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__delBulkGoodsInfResponse);
	if (soap_out_PointerTons2__delBulkGoodsInfResponse(soap, tag?tag:"ns2:delBulkGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__delBulkGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__delBulkGoodsInfResponse(struct soap *soap, ns2__delBulkGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__delBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__delBulkGoodsInf(struct soap *soap, ns2__delBulkGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__delBulkGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__delBulkGoodsInf(struct soap *soap, const char *tag, int id, ns2__delBulkGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__delBulkGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__delBulkGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__delBulkGoodsInf(struct soap *soap, const char *tag, ns2__delBulkGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__delBulkGoodsInf **)soap_malloc(soap, sizeof(ns2__delBulkGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__delBulkGoodsInf *)soap_instantiate_ns2__delBulkGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__delBulkGoodsInf ** p = (ns2__delBulkGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__delBulkGoodsInf, sizeof(ns2__delBulkGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__delBulkGoodsInf(struct soap *soap, ns2__delBulkGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__delBulkGoodsInf);
	if (soap_out_PointerTons2__delBulkGoodsInf(soap, tag?tag:"ns2:delBulkGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__delBulkGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__delBulkGoodsInf(struct soap *soap, ns2__delBulkGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__delBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClickSearchCarsInfResponse(struct soap *soap, ns2__getClickSearchCarsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClickSearchCarsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClickSearchCarsInfResponse(struct soap *soap, const char *tag, int id, ns2__getClickSearchCarsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClickSearchCarsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getClickSearchCarsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getClickSearchCarsInfResponse(struct soap *soap, const char *tag, ns2__getClickSearchCarsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClickSearchCarsInfResponse **)soap_malloc(soap, sizeof(ns2__getClickSearchCarsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClickSearchCarsInfResponse *)soap_instantiate_ns2__getClickSearchCarsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getClickSearchCarsInfResponse ** p = (ns2__getClickSearchCarsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClickSearchCarsInfResponse, sizeof(ns2__getClickSearchCarsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClickSearchCarsInfResponse(struct soap *soap, ns2__getClickSearchCarsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getClickSearchCarsInfResponse);
	if (soap_out_PointerTons2__getClickSearchCarsInfResponse(soap, tag?tag:"ns2:getClickSearchCarsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClickSearchCarsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getClickSearchCarsInfResponse(struct soap *soap, ns2__getClickSearchCarsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClickSearchCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClickSearchCarsInf(struct soap *soap, ns2__getClickSearchCarsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClickSearchCarsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClickSearchCarsInf(struct soap *soap, const char *tag, int id, ns2__getClickSearchCarsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClickSearchCarsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getClickSearchCarsInf ** SOAP_FMAC4 soap_in_PointerTons2__getClickSearchCarsInf(struct soap *soap, const char *tag, ns2__getClickSearchCarsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClickSearchCarsInf **)soap_malloc(soap, sizeof(ns2__getClickSearchCarsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClickSearchCarsInf *)soap_instantiate_ns2__getClickSearchCarsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getClickSearchCarsInf ** p = (ns2__getClickSearchCarsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClickSearchCarsInf, sizeof(ns2__getClickSearchCarsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClickSearchCarsInf(struct soap *soap, ns2__getClickSearchCarsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getClickSearchCarsInf);
	if (soap_out_PointerTons2__getClickSearchCarsInf(soap, tag?tag:"ns2:getClickSearchCarsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClickSearchCarsInf ** SOAP_FMAC4 soap_get_PointerTons2__getClickSearchCarsInf(struct soap *soap, ns2__getClickSearchCarsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClickSearchCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setPubCarsInfResponse(struct soap *soap, ns2__setPubCarsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setPubCarsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setPubCarsInfResponse(struct soap *soap, const char *tag, int id, ns2__setPubCarsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setPubCarsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setPubCarsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__setPubCarsInfResponse(struct soap *soap, const char *tag, ns2__setPubCarsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setPubCarsInfResponse **)soap_malloc(soap, sizeof(ns2__setPubCarsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setPubCarsInfResponse *)soap_instantiate_ns2__setPubCarsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setPubCarsInfResponse ** p = (ns2__setPubCarsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setPubCarsInfResponse, sizeof(ns2__setPubCarsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setPubCarsInfResponse(struct soap *soap, ns2__setPubCarsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setPubCarsInfResponse);
	if (soap_out_PointerTons2__setPubCarsInfResponse(soap, tag?tag:"ns2:setPubCarsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setPubCarsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__setPubCarsInfResponse(struct soap *soap, ns2__setPubCarsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setPubCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setPubCarsInf(struct soap *soap, ns2__setPubCarsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setPubCarsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setPubCarsInf(struct soap *soap, const char *tag, int id, ns2__setPubCarsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setPubCarsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setPubCarsInf ** SOAP_FMAC4 soap_in_PointerTons2__setPubCarsInf(struct soap *soap, const char *tag, ns2__setPubCarsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setPubCarsInf **)soap_malloc(soap, sizeof(ns2__setPubCarsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setPubCarsInf *)soap_instantiate_ns2__setPubCarsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setPubCarsInf ** p = (ns2__setPubCarsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setPubCarsInf, sizeof(ns2__setPubCarsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setPubCarsInf(struct soap *soap, ns2__setPubCarsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setPubCarsInf);
	if (soap_out_PointerTons2__setPubCarsInf(soap, tag?tag:"ns2:setPubCarsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setPubCarsInf ** SOAP_FMAC4 soap_get_PointerTons2__setPubCarsInf(struct soap *soap, ns2__setPubCarsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setPubCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setPubBulkGoodsInfResponse(struct soap *soap, ns2__setPubBulkGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setPubBulkGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setPubBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__setPubBulkGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setPubBulkGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setPubBulkGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__setPubBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__setPubBulkGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setPubBulkGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__setPubBulkGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setPubBulkGoodsInfResponse *)soap_instantiate_ns2__setPubBulkGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setPubBulkGoodsInfResponse ** p = (ns2__setPubBulkGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setPubBulkGoodsInfResponse, sizeof(ns2__setPubBulkGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setPubBulkGoodsInfResponse(struct soap *soap, ns2__setPubBulkGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setPubBulkGoodsInfResponse);
	if (soap_out_PointerTons2__setPubBulkGoodsInfResponse(soap, tag?tag:"ns2:setPubBulkGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setPubBulkGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__setPubBulkGoodsInfResponse(struct soap *soap, ns2__setPubBulkGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setPubBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setPubBulkGoodsInf(struct soap *soap, ns2__setPubBulkGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setPubBulkGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setPubBulkGoodsInf(struct soap *soap, const char *tag, int id, ns2__setPubBulkGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setPubBulkGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setPubBulkGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__setPubBulkGoodsInf(struct soap *soap, const char *tag, ns2__setPubBulkGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setPubBulkGoodsInf **)soap_malloc(soap, sizeof(ns2__setPubBulkGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setPubBulkGoodsInf *)soap_instantiate_ns2__setPubBulkGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setPubBulkGoodsInf ** p = (ns2__setPubBulkGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setPubBulkGoodsInf, sizeof(ns2__setPubBulkGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setPubBulkGoodsInf(struct soap *soap, ns2__setPubBulkGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setPubBulkGoodsInf);
	if (soap_out_PointerTons2__setPubBulkGoodsInf(soap, tag?tag:"ns2:setPubBulkGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setPubBulkGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__setPubBulkGoodsInf(struct soap *soap, ns2__setPubBulkGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setPubBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchBulkGoodsInfResponse(struct soap *soap, ns2__getSearchBulkGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__getSearchBulkGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchBulkGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getSearchBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__getSearchBulkGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchBulkGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__getSearchBulkGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchBulkGoodsInfResponse *)soap_instantiate_ns2__getSearchBulkGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchBulkGoodsInfResponse ** p = (ns2__getSearchBulkGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchBulkGoodsInfResponse, sizeof(ns2__getSearchBulkGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchBulkGoodsInfResponse(struct soap *soap, ns2__getSearchBulkGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchBulkGoodsInfResponse);
	if (soap_out_PointerTons2__getSearchBulkGoodsInfResponse(soap, tag?tag:"ns2:getSearchBulkGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchBulkGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getSearchBulkGoodsInfResponse(struct soap *soap, ns2__getSearchBulkGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchBulkGoodsInf(struct soap *soap, ns2__getSearchBulkGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchBulkGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchBulkGoodsInf(struct soap *soap, const char *tag, int id, ns2__getSearchBulkGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchBulkGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchBulkGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__getSearchBulkGoodsInf(struct soap *soap, const char *tag, ns2__getSearchBulkGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchBulkGoodsInf **)soap_malloc(soap, sizeof(ns2__getSearchBulkGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchBulkGoodsInf *)soap_instantiate_ns2__getSearchBulkGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchBulkGoodsInf ** p = (ns2__getSearchBulkGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchBulkGoodsInf, sizeof(ns2__getSearchBulkGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchBulkGoodsInf(struct soap *soap, ns2__getSearchBulkGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchBulkGoodsInf);
	if (soap_out_PointerTons2__getSearchBulkGoodsInf(soap, tag?tag:"ns2:getSearchBulkGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchBulkGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__getSearchBulkGoodsInf(struct soap *soap, ns2__getSearchBulkGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getNewCarsInfResponse(struct soap *soap, ns2__getNewCarsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getNewCarsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getNewCarsInfResponse(struct soap *soap, const char *tag, int id, ns2__getNewCarsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getNewCarsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getNewCarsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getNewCarsInfResponse(struct soap *soap, const char *tag, ns2__getNewCarsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getNewCarsInfResponse **)soap_malloc(soap, sizeof(ns2__getNewCarsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getNewCarsInfResponse *)soap_instantiate_ns2__getNewCarsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getNewCarsInfResponse ** p = (ns2__getNewCarsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getNewCarsInfResponse, sizeof(ns2__getNewCarsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getNewCarsInfResponse(struct soap *soap, ns2__getNewCarsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getNewCarsInfResponse);
	if (soap_out_PointerTons2__getNewCarsInfResponse(soap, tag?tag:"ns2:getNewCarsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getNewCarsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getNewCarsInfResponse(struct soap *soap, ns2__getNewCarsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getNewCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getNewCarsInf(struct soap *soap, ns2__getNewCarsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getNewCarsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getNewCarsInf(struct soap *soap, const char *tag, int id, ns2__getNewCarsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getNewCarsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getNewCarsInf ** SOAP_FMAC4 soap_in_PointerTons2__getNewCarsInf(struct soap *soap, const char *tag, ns2__getNewCarsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getNewCarsInf **)soap_malloc(soap, sizeof(ns2__getNewCarsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getNewCarsInf *)soap_instantiate_ns2__getNewCarsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getNewCarsInf ** p = (ns2__getNewCarsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getNewCarsInf, sizeof(ns2__getNewCarsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getNewCarsInf(struct soap *soap, ns2__getNewCarsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getNewCarsInf);
	if (soap_out_PointerTons2__getNewCarsInf(soap, tag?tag:"ns2:getNewCarsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getNewCarsInf ** SOAP_FMAC4 soap_get_PointerTons2__getNewCarsInf(struct soap *soap, ns2__getNewCarsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getNewCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setPubGoodsInfResponse(struct soap *soap, ns2__setPubGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setPubGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setPubGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__setPubGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setPubGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setPubGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__setPubGoodsInfResponse(struct soap *soap, const char *tag, ns2__setPubGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setPubGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__setPubGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setPubGoodsInfResponse *)soap_instantiate_ns2__setPubGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setPubGoodsInfResponse ** p = (ns2__setPubGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setPubGoodsInfResponse, sizeof(ns2__setPubGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setPubGoodsInfResponse(struct soap *soap, ns2__setPubGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setPubGoodsInfResponse);
	if (soap_out_PointerTons2__setPubGoodsInfResponse(soap, tag?tag:"ns2:setPubGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setPubGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__setPubGoodsInfResponse(struct soap *soap, ns2__setPubGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setPubGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setPubGoodsInf(struct soap *soap, ns2__setPubGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setPubGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setPubGoodsInf(struct soap *soap, const char *tag, int id, ns2__setPubGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setPubGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setPubGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__setPubGoodsInf(struct soap *soap, const char *tag, ns2__setPubGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setPubGoodsInf **)soap_malloc(soap, sizeof(ns2__setPubGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setPubGoodsInf *)soap_instantiate_ns2__setPubGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setPubGoodsInf ** p = (ns2__setPubGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setPubGoodsInf, sizeof(ns2__setPubGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setPubGoodsInf(struct soap *soap, ns2__setPubGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setPubGoodsInf);
	if (soap_out_PointerTons2__setPubGoodsInf(soap, tag?tag:"ns2:setPubGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setPubGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__setPubGoodsInf(struct soap *soap, ns2__setPubGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setPubGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClickSearchGoodsInfResponse(struct soap *soap, ns2__getClickSearchGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClickSearchGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClickSearchGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__getClickSearchGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClickSearchGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getClickSearchGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getClickSearchGoodsInfResponse(struct soap *soap, const char *tag, ns2__getClickSearchGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClickSearchGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__getClickSearchGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClickSearchGoodsInfResponse *)soap_instantiate_ns2__getClickSearchGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getClickSearchGoodsInfResponse ** p = (ns2__getClickSearchGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClickSearchGoodsInfResponse, sizeof(ns2__getClickSearchGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClickSearchGoodsInfResponse(struct soap *soap, ns2__getClickSearchGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getClickSearchGoodsInfResponse);
	if (soap_out_PointerTons2__getClickSearchGoodsInfResponse(soap, tag?tag:"ns2:getClickSearchGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClickSearchGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getClickSearchGoodsInfResponse(struct soap *soap, ns2__getClickSearchGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClickSearchGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClickSearchGoodsInf(struct soap *soap, ns2__getClickSearchGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClickSearchGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClickSearchGoodsInf(struct soap *soap, const char *tag, int id, ns2__getClickSearchGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClickSearchGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getClickSearchGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__getClickSearchGoodsInf(struct soap *soap, const char *tag, ns2__getClickSearchGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClickSearchGoodsInf **)soap_malloc(soap, sizeof(ns2__getClickSearchGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClickSearchGoodsInf *)soap_instantiate_ns2__getClickSearchGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getClickSearchGoodsInf ** p = (ns2__getClickSearchGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClickSearchGoodsInf, sizeof(ns2__getClickSearchGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClickSearchGoodsInf(struct soap *soap, ns2__getClickSearchGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getClickSearchGoodsInf);
	if (soap_out_PointerTons2__getClickSearchGoodsInf(soap, tag?tag:"ns2:getClickSearchGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClickSearchGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__getClickSearchGoodsInf(struct soap *soap, ns2__getClickSearchGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClickSearchGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__addUserCustomInfResponse(struct soap *soap, ns2__addUserCustomInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__addUserCustomInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__addUserCustomInfResponse(struct soap *soap, const char *tag, int id, ns2__addUserCustomInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__addUserCustomInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__addUserCustomInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__addUserCustomInfResponse(struct soap *soap, const char *tag, ns2__addUserCustomInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__addUserCustomInfResponse **)soap_malloc(soap, sizeof(ns2__addUserCustomInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__addUserCustomInfResponse *)soap_instantiate_ns2__addUserCustomInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__addUserCustomInfResponse ** p = (ns2__addUserCustomInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__addUserCustomInfResponse, sizeof(ns2__addUserCustomInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__addUserCustomInfResponse(struct soap *soap, ns2__addUserCustomInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__addUserCustomInfResponse);
	if (soap_out_PointerTons2__addUserCustomInfResponse(soap, tag?tag:"ns2:addUserCustomInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__addUserCustomInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__addUserCustomInfResponse(struct soap *soap, ns2__addUserCustomInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__addUserCustomInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__addUserCustomInf(struct soap *soap, ns2__addUserCustomInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__addUserCustomInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__addUserCustomInf(struct soap *soap, const char *tag, int id, ns2__addUserCustomInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__addUserCustomInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__addUserCustomInf ** SOAP_FMAC4 soap_in_PointerTons2__addUserCustomInf(struct soap *soap, const char *tag, ns2__addUserCustomInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__addUserCustomInf **)soap_malloc(soap, sizeof(ns2__addUserCustomInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__addUserCustomInf *)soap_instantiate_ns2__addUserCustomInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__addUserCustomInf ** p = (ns2__addUserCustomInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__addUserCustomInf, sizeof(ns2__addUserCustomInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__addUserCustomInf(struct soap *soap, ns2__addUserCustomInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__addUserCustomInf);
	if (soap_out_PointerTons2__addUserCustomInf(soap, tag?tag:"ns2:addUserCustomInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__addUserCustomInf ** SOAP_FMAC4 soap_get_PointerTons2__addUserCustomInf(struct soap *soap, ns2__addUserCustomInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__addUserCustomInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getMyBulkGoodsInfResponse(struct soap *soap, ns2__getMyBulkGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getMyBulkGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getMyBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__getMyBulkGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getMyBulkGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getMyBulkGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getMyBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__getMyBulkGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getMyBulkGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__getMyBulkGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getMyBulkGoodsInfResponse *)soap_instantiate_ns2__getMyBulkGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getMyBulkGoodsInfResponse ** p = (ns2__getMyBulkGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getMyBulkGoodsInfResponse, sizeof(ns2__getMyBulkGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getMyBulkGoodsInfResponse(struct soap *soap, ns2__getMyBulkGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getMyBulkGoodsInfResponse);
	if (soap_out_PointerTons2__getMyBulkGoodsInfResponse(soap, tag?tag:"ns2:getMyBulkGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getMyBulkGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getMyBulkGoodsInfResponse(struct soap *soap, ns2__getMyBulkGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getMyBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getMyBulkGoodsInf(struct soap *soap, ns2__getMyBulkGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getMyBulkGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getMyBulkGoodsInf(struct soap *soap, const char *tag, int id, ns2__getMyBulkGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getMyBulkGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getMyBulkGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__getMyBulkGoodsInf(struct soap *soap, const char *tag, ns2__getMyBulkGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getMyBulkGoodsInf **)soap_malloc(soap, sizeof(ns2__getMyBulkGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getMyBulkGoodsInf *)soap_instantiate_ns2__getMyBulkGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getMyBulkGoodsInf ** p = (ns2__getMyBulkGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getMyBulkGoodsInf, sizeof(ns2__getMyBulkGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getMyBulkGoodsInf(struct soap *soap, ns2__getMyBulkGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getMyBulkGoodsInf);
	if (soap_out_PointerTons2__getMyBulkGoodsInf(soap, tag?tag:"ns2:getMyBulkGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getMyBulkGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__getMyBulkGoodsInf(struct soap *soap, ns2__getMyBulkGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getMyBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__delSpecialLineInfResponse(struct soap *soap, ns2__delSpecialLineInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__delSpecialLineInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__delSpecialLineInfResponse(struct soap *soap, const char *tag, int id, ns2__delSpecialLineInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__delSpecialLineInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__delSpecialLineInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__delSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__delSpecialLineInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__delSpecialLineInfResponse **)soap_malloc(soap, sizeof(ns2__delSpecialLineInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__delSpecialLineInfResponse *)soap_instantiate_ns2__delSpecialLineInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__delSpecialLineInfResponse ** p = (ns2__delSpecialLineInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__delSpecialLineInfResponse, sizeof(ns2__delSpecialLineInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__delSpecialLineInfResponse(struct soap *soap, ns2__delSpecialLineInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__delSpecialLineInfResponse);
	if (soap_out_PointerTons2__delSpecialLineInfResponse(soap, tag?tag:"ns2:delSpecialLineInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__delSpecialLineInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__delSpecialLineInfResponse(struct soap *soap, ns2__delSpecialLineInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__delSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__delSpecialLineInf(struct soap *soap, ns2__delSpecialLineInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__delSpecialLineInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__delSpecialLineInf(struct soap *soap, const char *tag, int id, ns2__delSpecialLineInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__delSpecialLineInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__delSpecialLineInf ** SOAP_FMAC4 soap_in_PointerTons2__delSpecialLineInf(struct soap *soap, const char *tag, ns2__delSpecialLineInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__delSpecialLineInf **)soap_malloc(soap, sizeof(ns2__delSpecialLineInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__delSpecialLineInf *)soap_instantiate_ns2__delSpecialLineInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__delSpecialLineInf ** p = (ns2__delSpecialLineInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__delSpecialLineInf, sizeof(ns2__delSpecialLineInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__delSpecialLineInf(struct soap *soap, ns2__delSpecialLineInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__delSpecialLineInf);
	if (soap_out_PointerTons2__delSpecialLineInf(soap, tag?tag:"ns2:delSpecialLineInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__delSpecialLineInf ** SOAP_FMAC4 soap_get_PointerTons2__delSpecialLineInf(struct soap *soap, ns2__delSpecialLineInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__delSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClickSearchSpecialLineInfResponse(struct soap *soap, ns2__getClickSearchSpecialLineInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClickSearchSpecialLineInfResponse(struct soap *soap, const char *tag, int id, ns2__getClickSearchSpecialLineInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getClickSearchSpecialLineInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getClickSearchSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__getClickSearchSpecialLineInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClickSearchSpecialLineInfResponse **)soap_malloc(soap, sizeof(ns2__getClickSearchSpecialLineInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClickSearchSpecialLineInfResponse *)soap_instantiate_ns2__getClickSearchSpecialLineInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getClickSearchSpecialLineInfResponse ** p = (ns2__getClickSearchSpecialLineInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClickSearchSpecialLineInfResponse, sizeof(ns2__getClickSearchSpecialLineInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClickSearchSpecialLineInfResponse(struct soap *soap, ns2__getClickSearchSpecialLineInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getClickSearchSpecialLineInfResponse);
	if (soap_out_PointerTons2__getClickSearchSpecialLineInfResponse(soap, tag?tag:"ns2:getClickSearchSpecialLineInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClickSearchSpecialLineInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getClickSearchSpecialLineInfResponse(struct soap *soap, ns2__getClickSearchSpecialLineInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClickSearchSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClickSearchSpecialLineInf(struct soap *soap, ns2__getClickSearchSpecialLineInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClickSearchSpecialLineInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClickSearchSpecialLineInf(struct soap *soap, const char *tag, int id, ns2__getClickSearchSpecialLineInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClickSearchSpecialLineInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getClickSearchSpecialLineInf ** SOAP_FMAC4 soap_in_PointerTons2__getClickSearchSpecialLineInf(struct soap *soap, const char *tag, ns2__getClickSearchSpecialLineInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClickSearchSpecialLineInf **)soap_malloc(soap, sizeof(ns2__getClickSearchSpecialLineInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClickSearchSpecialLineInf *)soap_instantiate_ns2__getClickSearchSpecialLineInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getClickSearchSpecialLineInf ** p = (ns2__getClickSearchSpecialLineInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClickSearchSpecialLineInf, sizeof(ns2__getClickSearchSpecialLineInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClickSearchSpecialLineInf(struct soap *soap, ns2__getClickSearchSpecialLineInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getClickSearchSpecialLineInf);
	if (soap_out_PointerTons2__getClickSearchSpecialLineInf(soap, tag?tag:"ns2:getClickSearchSpecialLineInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClickSearchSpecialLineInf ** SOAP_FMAC4 soap_get_PointerTons2__getClickSearchSpecialLineInf(struct soap *soap, ns2__getClickSearchSpecialLineInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClickSearchSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getAllSpecialLineInfResponse(struct soap *soap, ns2__getAllSpecialLineInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getAllSpecialLineInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getAllSpecialLineInfResponse(struct soap *soap, const char *tag, int id, ns2__getAllSpecialLineInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getAllSpecialLineInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getAllSpecialLineInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getAllSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__getAllSpecialLineInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getAllSpecialLineInfResponse **)soap_malloc(soap, sizeof(ns2__getAllSpecialLineInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getAllSpecialLineInfResponse *)soap_instantiate_ns2__getAllSpecialLineInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getAllSpecialLineInfResponse ** p = (ns2__getAllSpecialLineInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getAllSpecialLineInfResponse, sizeof(ns2__getAllSpecialLineInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getAllSpecialLineInfResponse(struct soap *soap, ns2__getAllSpecialLineInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getAllSpecialLineInfResponse);
	if (soap_out_PointerTons2__getAllSpecialLineInfResponse(soap, tag?tag:"ns2:getAllSpecialLineInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getAllSpecialLineInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getAllSpecialLineInfResponse(struct soap *soap, ns2__getAllSpecialLineInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getAllSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getAllSpecialLineInf(struct soap *soap, ns2__getAllSpecialLineInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getAllSpecialLineInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getAllSpecialLineInf(struct soap *soap, const char *tag, int id, ns2__getAllSpecialLineInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getAllSpecialLineInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getAllSpecialLineInf ** SOAP_FMAC4 soap_in_PointerTons2__getAllSpecialLineInf(struct soap *soap, const char *tag, ns2__getAllSpecialLineInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getAllSpecialLineInf **)soap_malloc(soap, sizeof(ns2__getAllSpecialLineInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getAllSpecialLineInf *)soap_instantiate_ns2__getAllSpecialLineInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getAllSpecialLineInf ** p = (ns2__getAllSpecialLineInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getAllSpecialLineInf, sizeof(ns2__getAllSpecialLineInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getAllSpecialLineInf(struct soap *soap, ns2__getAllSpecialLineInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getAllSpecialLineInf);
	if (soap_out_PointerTons2__getAllSpecialLineInf(soap, tag?tag:"ns2:getAllSpecialLineInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getAllSpecialLineInf ** SOAP_FMAC4 soap_get_PointerTons2__getAllSpecialLineInf(struct soap *soap, ns2__getAllSpecialLineInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getAllSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setServiceStationInfResponse(struct soap *soap, ns2__setServiceStationInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setServiceStationInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setServiceStationInfResponse(struct soap *soap, const char *tag, int id, ns2__setServiceStationInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setServiceStationInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setServiceStationInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__setServiceStationInfResponse(struct soap *soap, const char *tag, ns2__setServiceStationInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setServiceStationInfResponse **)soap_malloc(soap, sizeof(ns2__setServiceStationInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setServiceStationInfResponse *)soap_instantiate_ns2__setServiceStationInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setServiceStationInfResponse ** p = (ns2__setServiceStationInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setServiceStationInfResponse, sizeof(ns2__setServiceStationInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setServiceStationInfResponse(struct soap *soap, ns2__setServiceStationInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setServiceStationInfResponse);
	if (soap_out_PointerTons2__setServiceStationInfResponse(soap, tag?tag:"ns2:setServiceStationInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setServiceStationInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__setServiceStationInfResponse(struct soap *soap, ns2__setServiceStationInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setServiceStationInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setServiceStationInf(struct soap *soap, ns2__setServiceStationInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setServiceStationInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setServiceStationInf(struct soap *soap, const char *tag, int id, ns2__setServiceStationInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setServiceStationInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setServiceStationInf ** SOAP_FMAC4 soap_in_PointerTons2__setServiceStationInf(struct soap *soap, const char *tag, ns2__setServiceStationInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setServiceStationInf **)soap_malloc(soap, sizeof(ns2__setServiceStationInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setServiceStationInf *)soap_instantiate_ns2__setServiceStationInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setServiceStationInf ** p = (ns2__setServiceStationInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setServiceStationInf, sizeof(ns2__setServiceStationInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setServiceStationInf(struct soap *soap, ns2__setServiceStationInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setServiceStationInf);
	if (soap_out_PointerTons2__setServiceStationInf(soap, tag?tag:"ns2:setServiceStationInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setServiceStationInf ** SOAP_FMAC4 soap_get_PointerTons2__setServiceStationInf(struct soap *soap, ns2__setServiceStationInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setServiceStationInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__deleteUserCustomInfResponse(struct soap *soap, ns2__deleteUserCustomInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__deleteUserCustomInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__deleteUserCustomInfResponse(struct soap *soap, const char *tag, int id, ns2__deleteUserCustomInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__deleteUserCustomInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__deleteUserCustomInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__deleteUserCustomInfResponse(struct soap *soap, const char *tag, ns2__deleteUserCustomInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__deleteUserCustomInfResponse **)soap_malloc(soap, sizeof(ns2__deleteUserCustomInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__deleteUserCustomInfResponse *)soap_instantiate_ns2__deleteUserCustomInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__deleteUserCustomInfResponse ** p = (ns2__deleteUserCustomInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__deleteUserCustomInfResponse, sizeof(ns2__deleteUserCustomInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__deleteUserCustomInfResponse(struct soap *soap, ns2__deleteUserCustomInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__deleteUserCustomInfResponse);
	if (soap_out_PointerTons2__deleteUserCustomInfResponse(soap, tag?tag:"ns2:deleteUserCustomInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__deleteUserCustomInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__deleteUserCustomInfResponse(struct soap *soap, ns2__deleteUserCustomInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__deleteUserCustomInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__deleteUserCustomInf(struct soap *soap, ns2__deleteUserCustomInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__deleteUserCustomInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__deleteUserCustomInf(struct soap *soap, const char *tag, int id, ns2__deleteUserCustomInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__deleteUserCustomInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__deleteUserCustomInf ** SOAP_FMAC4 soap_in_PointerTons2__deleteUserCustomInf(struct soap *soap, const char *tag, ns2__deleteUserCustomInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__deleteUserCustomInf **)soap_malloc(soap, sizeof(ns2__deleteUserCustomInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__deleteUserCustomInf *)soap_instantiate_ns2__deleteUserCustomInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__deleteUserCustomInf ** p = (ns2__deleteUserCustomInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__deleteUserCustomInf, sizeof(ns2__deleteUserCustomInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__deleteUserCustomInf(struct soap *soap, ns2__deleteUserCustomInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__deleteUserCustomInf);
	if (soap_out_PointerTons2__deleteUserCustomInf(soap, tag?tag:"ns2:deleteUserCustomInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__deleteUserCustomInf ** SOAP_FMAC4 soap_get_PointerTons2__deleteUserCustomInf(struct soap *soap, ns2__deleteUserCustomInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__deleteUserCustomInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__checkChargeUserResponse(struct soap *soap, ns2__checkChargeUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__checkChargeUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__checkChargeUserResponse(struct soap *soap, const char *tag, int id, ns2__checkChargeUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__checkChargeUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__checkChargeUserResponse ** SOAP_FMAC4 soap_in_PointerTons2__checkChargeUserResponse(struct soap *soap, const char *tag, ns2__checkChargeUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__checkChargeUserResponse **)soap_malloc(soap, sizeof(ns2__checkChargeUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__checkChargeUserResponse *)soap_instantiate_ns2__checkChargeUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__checkChargeUserResponse ** p = (ns2__checkChargeUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__checkChargeUserResponse, sizeof(ns2__checkChargeUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__checkChargeUserResponse(struct soap *soap, ns2__checkChargeUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__checkChargeUserResponse);
	if (soap_out_PointerTons2__checkChargeUserResponse(soap, tag?tag:"ns2:checkChargeUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__checkChargeUserResponse ** SOAP_FMAC4 soap_get_PointerTons2__checkChargeUserResponse(struct soap *soap, ns2__checkChargeUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__checkChargeUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__checkChargeUser(struct soap *soap, ns2__checkChargeUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__checkChargeUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__checkChargeUser(struct soap *soap, const char *tag, int id, ns2__checkChargeUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__checkChargeUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__checkChargeUser ** SOAP_FMAC4 soap_in_PointerTons2__checkChargeUser(struct soap *soap, const char *tag, ns2__checkChargeUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__checkChargeUser **)soap_malloc(soap, sizeof(ns2__checkChargeUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__checkChargeUser *)soap_instantiate_ns2__checkChargeUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__checkChargeUser ** p = (ns2__checkChargeUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__checkChargeUser, sizeof(ns2__checkChargeUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__checkChargeUser(struct soap *soap, ns2__checkChargeUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__checkChargeUser);
	if (soap_out_PointerTons2__checkChargeUser(soap, tag?tag:"ns2:checkChargeUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__checkChargeUser ** SOAP_FMAC4 soap_get_PointerTons2__checkChargeUser(struct soap *soap, ns2__checkChargeUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__checkChargeUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClickSearchBulkGoodsInfResponse(struct soap *soap, ns2__getClickSearchBulkGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClickSearchBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__getClickSearchBulkGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getClickSearchBulkGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getClickSearchBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__getClickSearchBulkGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClickSearchBulkGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__getClickSearchBulkGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClickSearchBulkGoodsInfResponse *)soap_instantiate_ns2__getClickSearchBulkGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getClickSearchBulkGoodsInfResponse ** p = (ns2__getClickSearchBulkGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClickSearchBulkGoodsInfResponse, sizeof(ns2__getClickSearchBulkGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClickSearchBulkGoodsInfResponse(struct soap *soap, ns2__getClickSearchBulkGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getClickSearchBulkGoodsInfResponse);
	if (soap_out_PointerTons2__getClickSearchBulkGoodsInfResponse(soap, tag?tag:"ns2:getClickSearchBulkGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClickSearchBulkGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getClickSearchBulkGoodsInfResponse(struct soap *soap, ns2__getClickSearchBulkGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClickSearchBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClickSearchBulkGoodsInf(struct soap *soap, ns2__getClickSearchBulkGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClickSearchBulkGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClickSearchBulkGoodsInf(struct soap *soap, const char *tag, int id, ns2__getClickSearchBulkGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClickSearchBulkGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getClickSearchBulkGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__getClickSearchBulkGoodsInf(struct soap *soap, const char *tag, ns2__getClickSearchBulkGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClickSearchBulkGoodsInf **)soap_malloc(soap, sizeof(ns2__getClickSearchBulkGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClickSearchBulkGoodsInf *)soap_instantiate_ns2__getClickSearchBulkGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getClickSearchBulkGoodsInf ** p = (ns2__getClickSearchBulkGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClickSearchBulkGoodsInf, sizeof(ns2__getClickSearchBulkGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClickSearchBulkGoodsInf(struct soap *soap, ns2__getClickSearchBulkGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getClickSearchBulkGoodsInf);
	if (soap_out_PointerTons2__getClickSearchBulkGoodsInf(soap, tag?tag:"ns2:getClickSearchBulkGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClickSearchBulkGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__getClickSearchBulkGoodsInf(struct soap *soap, ns2__getClickSearchBulkGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClickSearchBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getCustomGoodsInfResponse(struct soap *soap, ns2__getCustomGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getCustomGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getCustomGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__getCustomGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getCustomGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getCustomGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getCustomGoodsInfResponse(struct soap *soap, const char *tag, ns2__getCustomGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getCustomGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__getCustomGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getCustomGoodsInfResponse *)soap_instantiate_ns2__getCustomGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getCustomGoodsInfResponse ** p = (ns2__getCustomGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getCustomGoodsInfResponse, sizeof(ns2__getCustomGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getCustomGoodsInfResponse(struct soap *soap, ns2__getCustomGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getCustomGoodsInfResponse);
	if (soap_out_PointerTons2__getCustomGoodsInfResponse(soap, tag?tag:"ns2:getCustomGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getCustomGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getCustomGoodsInfResponse(struct soap *soap, ns2__getCustomGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getCustomGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getCustomGoodsInf(struct soap *soap, ns2__getCustomGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getCustomGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getCustomGoodsInf(struct soap *soap, const char *tag, int id, ns2__getCustomGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getCustomGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getCustomGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__getCustomGoodsInf(struct soap *soap, const char *tag, ns2__getCustomGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getCustomGoodsInf **)soap_malloc(soap, sizeof(ns2__getCustomGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getCustomGoodsInf *)soap_instantiate_ns2__getCustomGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getCustomGoodsInf ** p = (ns2__getCustomGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getCustomGoodsInf, sizeof(ns2__getCustomGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getCustomGoodsInf(struct soap *soap, ns2__getCustomGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getCustomGoodsInf);
	if (soap_out_PointerTons2__getCustomGoodsInf(soap, tag?tag:"ns2:getCustomGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getCustomGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__getCustomGoodsInf(struct soap *soap, ns2__getCustomGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getCustomGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getAgentScrollAdResponse(struct soap *soap, ns2__getAgentScrollAdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getAgentScrollAdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getAgentScrollAdResponse(struct soap *soap, const char *tag, int id, ns2__getAgentScrollAdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getAgentScrollAdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getAgentScrollAdResponse ** SOAP_FMAC4 soap_in_PointerTons2__getAgentScrollAdResponse(struct soap *soap, const char *tag, ns2__getAgentScrollAdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getAgentScrollAdResponse **)soap_malloc(soap, sizeof(ns2__getAgentScrollAdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getAgentScrollAdResponse *)soap_instantiate_ns2__getAgentScrollAdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getAgentScrollAdResponse ** p = (ns2__getAgentScrollAdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getAgentScrollAdResponse, sizeof(ns2__getAgentScrollAdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getAgentScrollAdResponse(struct soap *soap, ns2__getAgentScrollAdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getAgentScrollAdResponse);
	if (soap_out_PointerTons2__getAgentScrollAdResponse(soap, tag?tag:"ns2:getAgentScrollAdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getAgentScrollAdResponse ** SOAP_FMAC4 soap_get_PointerTons2__getAgentScrollAdResponse(struct soap *soap, ns2__getAgentScrollAdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getAgentScrollAdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getAgentScrollAd(struct soap *soap, ns2__getAgentScrollAd *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getAgentScrollAd))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getAgentScrollAd(struct soap *soap, const char *tag, int id, ns2__getAgentScrollAd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getAgentScrollAd);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getAgentScrollAd ** SOAP_FMAC4 soap_in_PointerTons2__getAgentScrollAd(struct soap *soap, const char *tag, ns2__getAgentScrollAd **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getAgentScrollAd **)soap_malloc(soap, sizeof(ns2__getAgentScrollAd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getAgentScrollAd *)soap_instantiate_ns2__getAgentScrollAd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getAgentScrollAd ** p = (ns2__getAgentScrollAd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getAgentScrollAd, sizeof(ns2__getAgentScrollAd), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getAgentScrollAd(struct soap *soap, ns2__getAgentScrollAd *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getAgentScrollAd);
	if (soap_out_PointerTons2__getAgentScrollAd(soap, tag?tag:"ns2:getAgentScrollAd", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getAgentScrollAd ** SOAP_FMAC4 soap_get_PointerTons2__getAgentScrollAd(struct soap *soap, ns2__getAgentScrollAd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getAgentScrollAd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSystemScrollAdResponse(struct soap *soap, ns2__getSystemScrollAdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSystemScrollAdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSystemScrollAdResponse(struct soap *soap, const char *tag, int id, ns2__getSystemScrollAdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSystemScrollAdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSystemScrollAdResponse ** SOAP_FMAC4 soap_in_PointerTons2__getSystemScrollAdResponse(struct soap *soap, const char *tag, ns2__getSystemScrollAdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSystemScrollAdResponse **)soap_malloc(soap, sizeof(ns2__getSystemScrollAdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSystemScrollAdResponse *)soap_instantiate_ns2__getSystemScrollAdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSystemScrollAdResponse ** p = (ns2__getSystemScrollAdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSystemScrollAdResponse, sizeof(ns2__getSystemScrollAdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSystemScrollAdResponse(struct soap *soap, ns2__getSystemScrollAdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSystemScrollAdResponse);
	if (soap_out_PointerTons2__getSystemScrollAdResponse(soap, tag?tag:"ns2:getSystemScrollAdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSystemScrollAdResponse ** SOAP_FMAC4 soap_get_PointerTons2__getSystemScrollAdResponse(struct soap *soap, ns2__getSystemScrollAdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSystemScrollAdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSystemScrollAd(struct soap *soap, ns2__getSystemScrollAd *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSystemScrollAd))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSystemScrollAd(struct soap *soap, const char *tag, int id, ns2__getSystemScrollAd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSystemScrollAd);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSystemScrollAd ** SOAP_FMAC4 soap_in_PointerTons2__getSystemScrollAd(struct soap *soap, const char *tag, ns2__getSystemScrollAd **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSystemScrollAd **)soap_malloc(soap, sizeof(ns2__getSystemScrollAd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSystemScrollAd *)soap_instantiate_ns2__getSystemScrollAd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSystemScrollAd ** p = (ns2__getSystemScrollAd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSystemScrollAd, sizeof(ns2__getSystemScrollAd), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSystemScrollAd(struct soap *soap, ns2__getSystemScrollAd *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSystemScrollAd);
	if (soap_out_PointerTons2__getSystemScrollAd(soap, tag?tag:"ns2:getSystemScrollAd", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSystemScrollAd ** SOAP_FMAC4 soap_get_PointerTons2__getSystemScrollAd(struct soap *soap, ns2__getSystemScrollAd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSystemScrollAd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getMyGoodsInfResponse(struct soap *soap, ns2__getMyGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getMyGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getMyGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__getMyGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getMyGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getMyGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getMyGoodsInfResponse(struct soap *soap, const char *tag, ns2__getMyGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getMyGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__getMyGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getMyGoodsInfResponse *)soap_instantiate_ns2__getMyGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getMyGoodsInfResponse ** p = (ns2__getMyGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getMyGoodsInfResponse, sizeof(ns2__getMyGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getMyGoodsInfResponse(struct soap *soap, ns2__getMyGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getMyGoodsInfResponse);
	if (soap_out_PointerTons2__getMyGoodsInfResponse(soap, tag?tag:"ns2:getMyGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getMyGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getMyGoodsInfResponse(struct soap *soap, ns2__getMyGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getMyGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getMyGoodsInf(struct soap *soap, ns2__getMyGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getMyGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getMyGoodsInf(struct soap *soap, const char *tag, int id, ns2__getMyGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getMyGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getMyGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__getMyGoodsInf(struct soap *soap, const char *tag, ns2__getMyGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getMyGoodsInf **)soap_malloc(soap, sizeof(ns2__getMyGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getMyGoodsInf *)soap_instantiate_ns2__getMyGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getMyGoodsInf ** p = (ns2__getMyGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getMyGoodsInf, sizeof(ns2__getMyGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getMyGoodsInf(struct soap *soap, ns2__getMyGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getMyGoodsInf);
	if (soap_out_PointerTons2__getMyGoodsInf(soap, tag?tag:"ns2:getMyGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getMyGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__getMyGoodsInf(struct soap *soap, ns2__getMyGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getMyGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchGoodsInfNewResponse(struct soap *soap, ns2__getSearchGoodsInfNewResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchGoodsInfNewResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchGoodsInfNewResponse(struct soap *soap, const char *tag, int id, ns2__getSearchGoodsInfNewResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchGoodsInfNewResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInfNewResponse ** SOAP_FMAC4 soap_in_PointerTons2__getSearchGoodsInfNewResponse(struct soap *soap, const char *tag, ns2__getSearchGoodsInfNewResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchGoodsInfNewResponse **)soap_malloc(soap, sizeof(ns2__getSearchGoodsInfNewResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchGoodsInfNewResponse *)soap_instantiate_ns2__getSearchGoodsInfNewResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchGoodsInfNewResponse ** p = (ns2__getSearchGoodsInfNewResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchGoodsInfNewResponse, sizeof(ns2__getSearchGoodsInfNewResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchGoodsInfNewResponse(struct soap *soap, ns2__getSearchGoodsInfNewResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchGoodsInfNewResponse);
	if (soap_out_PointerTons2__getSearchGoodsInfNewResponse(soap, tag?tag:"ns2:getSearchGoodsInfNewResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchGoodsInfNewResponse ** SOAP_FMAC4 soap_get_PointerTons2__getSearchGoodsInfNewResponse(struct soap *soap, ns2__getSearchGoodsInfNewResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchGoodsInfNewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchGoodsInfNew(struct soap *soap, ns2__getSearchGoodsInfNew *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchGoodsInfNew))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchGoodsInfNew(struct soap *soap, const char *tag, int id, ns2__getSearchGoodsInfNew *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchGoodsInfNew);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInfNew ** SOAP_FMAC4 soap_in_PointerTons2__getSearchGoodsInfNew(struct soap *soap, const char *tag, ns2__getSearchGoodsInfNew **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchGoodsInfNew **)soap_malloc(soap, sizeof(ns2__getSearchGoodsInfNew *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchGoodsInfNew *)soap_instantiate_ns2__getSearchGoodsInfNew(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchGoodsInfNew ** p = (ns2__getSearchGoodsInfNew **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchGoodsInfNew, sizeof(ns2__getSearchGoodsInfNew), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchGoodsInfNew(struct soap *soap, ns2__getSearchGoodsInfNew *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchGoodsInfNew);
	if (soap_out_PointerTons2__getSearchGoodsInfNew(soap, tag?tag:"ns2:getSearchGoodsInfNew", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchGoodsInfNew ** SOAP_FMAC4 soap_get_PointerTons2__getSearchGoodsInfNew(struct soap *soap, ns2__getSearchGoodsInfNew **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchGoodsInfNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchGoodsInfResponse(struct soap *soap, ns2__getSearchGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__getSearchGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getSearchGoodsInfResponse(struct soap *soap, const char *tag, ns2__getSearchGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__getSearchGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchGoodsInfResponse *)soap_instantiate_ns2__getSearchGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchGoodsInfResponse ** p = (ns2__getSearchGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchGoodsInfResponse, sizeof(ns2__getSearchGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchGoodsInfResponse(struct soap *soap, ns2__getSearchGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchGoodsInfResponse);
	if (soap_out_PointerTons2__getSearchGoodsInfResponse(soap, tag?tag:"ns2:getSearchGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getSearchGoodsInfResponse(struct soap *soap, ns2__getSearchGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchGoodsInf(struct soap *soap, ns2__getSearchGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchGoodsInf(struct soap *soap, const char *tag, int id, ns2__getSearchGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__getSearchGoodsInf(struct soap *soap, const char *tag, ns2__getSearchGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchGoodsInf **)soap_malloc(soap, sizeof(ns2__getSearchGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchGoodsInf *)soap_instantiate_ns2__getSearchGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchGoodsInf ** p = (ns2__getSearchGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchGoodsInf, sizeof(ns2__getSearchGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchGoodsInf(struct soap *soap, ns2__getSearchGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchGoodsInf);
	if (soap_out_PointerTons2__getSearchGoodsInf(soap, tag?tag:"ns2:getSearchGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__getSearchGoodsInf(struct soap *soap, ns2__getSearchGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__delGoodsInfResponse(struct soap *soap, ns2__delGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__delGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__delGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__delGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__delGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__delGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__delGoodsInfResponse(struct soap *soap, const char *tag, ns2__delGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__delGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__delGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__delGoodsInfResponse *)soap_instantiate_ns2__delGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__delGoodsInfResponse ** p = (ns2__delGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__delGoodsInfResponse, sizeof(ns2__delGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__delGoodsInfResponse(struct soap *soap, ns2__delGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__delGoodsInfResponse);
	if (soap_out_PointerTons2__delGoodsInfResponse(soap, tag?tag:"ns2:delGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__delGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__delGoodsInfResponse(struct soap *soap, ns2__delGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__delGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__delGoodsInf(struct soap *soap, ns2__delGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__delGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__delGoodsInf(struct soap *soap, const char *tag, int id, ns2__delGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__delGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__delGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__delGoodsInf(struct soap *soap, const char *tag, ns2__delGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__delGoodsInf **)soap_malloc(soap, sizeof(ns2__delGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__delGoodsInf *)soap_instantiate_ns2__delGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__delGoodsInf ** p = (ns2__delGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__delGoodsInf, sizeof(ns2__delGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__delGoodsInf(struct soap *soap, ns2__delGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__delGoodsInf);
	if (soap_out_PointerTons2__delGoodsInf(soap, tag?tag:"ns2:delGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__delGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__delGoodsInf(struct soap *soap, ns2__delGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__delGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setGoodsStatusResponse(struct soap *soap, ns2__setGoodsStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setGoodsStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setGoodsStatusResponse(struct soap *soap, const char *tag, int id, ns2__setGoodsStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setGoodsStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setGoodsStatusResponse ** SOAP_FMAC4 soap_in_PointerTons2__setGoodsStatusResponse(struct soap *soap, const char *tag, ns2__setGoodsStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setGoodsStatusResponse **)soap_malloc(soap, sizeof(ns2__setGoodsStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setGoodsStatusResponse *)soap_instantiate_ns2__setGoodsStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setGoodsStatusResponse ** p = (ns2__setGoodsStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setGoodsStatusResponse, sizeof(ns2__setGoodsStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setGoodsStatusResponse(struct soap *soap, ns2__setGoodsStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setGoodsStatusResponse);
	if (soap_out_PointerTons2__setGoodsStatusResponse(soap, tag?tag:"ns2:setGoodsStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setGoodsStatusResponse ** SOAP_FMAC4 soap_get_PointerTons2__setGoodsStatusResponse(struct soap *soap, ns2__setGoodsStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setGoodsStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setGoodsStatus(struct soap *soap, ns2__setGoodsStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setGoodsStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setGoodsStatus(struct soap *soap, const char *tag, int id, ns2__setGoodsStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setGoodsStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setGoodsStatus ** SOAP_FMAC4 soap_in_PointerTons2__setGoodsStatus(struct soap *soap, const char *tag, ns2__setGoodsStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setGoodsStatus **)soap_malloc(soap, sizeof(ns2__setGoodsStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setGoodsStatus *)soap_instantiate_ns2__setGoodsStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setGoodsStatus ** p = (ns2__setGoodsStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setGoodsStatus, sizeof(ns2__setGoodsStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setGoodsStatus(struct soap *soap, ns2__setGoodsStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setGoodsStatus);
	if (soap_out_PointerTons2__setGoodsStatus(soap, tag?tag:"ns2:setGoodsStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setGoodsStatus ** SOAP_FMAC4 soap_get_PointerTons2__setGoodsStatus(struct soap *soap, ns2__setGoodsStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setGoodsStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getCustomCarsInfResponse(struct soap *soap, ns2__getCustomCarsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getCustomCarsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getCustomCarsInfResponse(struct soap *soap, const char *tag, int id, ns2__getCustomCarsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getCustomCarsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getCustomCarsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getCustomCarsInfResponse(struct soap *soap, const char *tag, ns2__getCustomCarsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getCustomCarsInfResponse **)soap_malloc(soap, sizeof(ns2__getCustomCarsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getCustomCarsInfResponse *)soap_instantiate_ns2__getCustomCarsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getCustomCarsInfResponse ** p = (ns2__getCustomCarsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getCustomCarsInfResponse, sizeof(ns2__getCustomCarsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getCustomCarsInfResponse(struct soap *soap, ns2__getCustomCarsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getCustomCarsInfResponse);
	if (soap_out_PointerTons2__getCustomCarsInfResponse(soap, tag?tag:"ns2:getCustomCarsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getCustomCarsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getCustomCarsInfResponse(struct soap *soap, ns2__getCustomCarsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getCustomCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getCustomCarsInf(struct soap *soap, ns2__getCustomCarsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getCustomCarsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getCustomCarsInf(struct soap *soap, const char *tag, int id, ns2__getCustomCarsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getCustomCarsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getCustomCarsInf ** SOAP_FMAC4 soap_in_PointerTons2__getCustomCarsInf(struct soap *soap, const char *tag, ns2__getCustomCarsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getCustomCarsInf **)soap_malloc(soap, sizeof(ns2__getCustomCarsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getCustomCarsInf *)soap_instantiate_ns2__getCustomCarsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getCustomCarsInf ** p = (ns2__getCustomCarsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getCustomCarsInf, sizeof(ns2__getCustomCarsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getCustomCarsInf(struct soap *soap, ns2__getCustomCarsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getCustomCarsInf);
	if (soap_out_PointerTons2__getCustomCarsInf(soap, tag?tag:"ns2:getCustomCarsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getCustomCarsInf ** SOAP_FMAC4 soap_get_PointerTons2__getCustomCarsInf(struct soap *soap, ns2__getCustomCarsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getCustomCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchSpecialLineInfResponse(struct soap *soap, ns2__getSearchSpecialLineInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchSpecialLineInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchSpecialLineInfResponse(struct soap *soap, const char *tag, int id, ns2__getSearchSpecialLineInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchSpecialLineInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchSpecialLineInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getSearchSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__getSearchSpecialLineInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchSpecialLineInfResponse **)soap_malloc(soap, sizeof(ns2__getSearchSpecialLineInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchSpecialLineInfResponse *)soap_instantiate_ns2__getSearchSpecialLineInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchSpecialLineInfResponse ** p = (ns2__getSearchSpecialLineInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchSpecialLineInfResponse, sizeof(ns2__getSearchSpecialLineInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchSpecialLineInfResponse(struct soap *soap, ns2__getSearchSpecialLineInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchSpecialLineInfResponse);
	if (soap_out_PointerTons2__getSearchSpecialLineInfResponse(soap, tag?tag:"ns2:getSearchSpecialLineInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchSpecialLineInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getSearchSpecialLineInfResponse(struct soap *soap, ns2__getSearchSpecialLineInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSearchSpecialLineInf(struct soap *soap, ns2__getSearchSpecialLineInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSearchSpecialLineInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSearchSpecialLineInf(struct soap *soap, const char *tag, int id, ns2__getSearchSpecialLineInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSearchSpecialLineInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getSearchSpecialLineInf ** SOAP_FMAC4 soap_in_PointerTons2__getSearchSpecialLineInf(struct soap *soap, const char *tag, ns2__getSearchSpecialLineInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getSearchSpecialLineInf **)soap_malloc(soap, sizeof(ns2__getSearchSpecialLineInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getSearchSpecialLineInf *)soap_instantiate_ns2__getSearchSpecialLineInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getSearchSpecialLineInf ** p = (ns2__getSearchSpecialLineInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSearchSpecialLineInf, sizeof(ns2__getSearchSpecialLineInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSearchSpecialLineInf(struct soap *soap, ns2__getSearchSpecialLineInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSearchSpecialLineInf);
	if (soap_out_PointerTons2__getSearchSpecialLineInf(soap, tag?tag:"ns2:getSearchSpecialLineInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getSearchSpecialLineInf ** SOAP_FMAC4 soap_get_PointerTons2__getSearchSpecialLineInf(struct soap *soap, ns2__getSearchSpecialLineInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSearchSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClickServiceStationInfResponse(struct soap *soap, ns2__getClickServiceStationInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClickServiceStationInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClickServiceStationInfResponse(struct soap *soap, const char *tag, int id, ns2__getClickServiceStationInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClickServiceStationInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getClickServiceStationInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getClickServiceStationInfResponse(struct soap *soap, const char *tag, ns2__getClickServiceStationInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClickServiceStationInfResponse **)soap_malloc(soap, sizeof(ns2__getClickServiceStationInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClickServiceStationInfResponse *)soap_instantiate_ns2__getClickServiceStationInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getClickServiceStationInfResponse ** p = (ns2__getClickServiceStationInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClickServiceStationInfResponse, sizeof(ns2__getClickServiceStationInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClickServiceStationInfResponse(struct soap *soap, ns2__getClickServiceStationInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getClickServiceStationInfResponse);
	if (soap_out_PointerTons2__getClickServiceStationInfResponse(soap, tag?tag:"ns2:getClickServiceStationInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClickServiceStationInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getClickServiceStationInfResponse(struct soap *soap, ns2__getClickServiceStationInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClickServiceStationInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClickServiceStationInf(struct soap *soap, ns2__getClickServiceStationInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClickServiceStationInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClickServiceStationInf(struct soap *soap, const char *tag, int id, ns2__getClickServiceStationInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClickServiceStationInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getClickServiceStationInf ** SOAP_FMAC4 soap_in_PointerTons2__getClickServiceStationInf(struct soap *soap, const char *tag, ns2__getClickServiceStationInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClickServiceStationInf **)soap_malloc(soap, sizeof(ns2__getClickServiceStationInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClickServiceStationInf *)soap_instantiate_ns2__getClickServiceStationInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getClickServiceStationInf ** p = (ns2__getClickServiceStationInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClickServiceStationInf, sizeof(ns2__getClickServiceStationInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClickServiceStationInf(struct soap *soap, ns2__getClickServiceStationInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getClickServiceStationInf);
	if (soap_out_PointerTons2__getClickServiceStationInf(soap, tag?tag:"ns2:getClickServiceStationInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClickServiceStationInf ** SOAP_FMAC4 soap_get_PointerTons2__getClickServiceStationInf(struct soap *soap, ns2__getClickServiceStationInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClickServiceStationInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setCarsStatusResponse(struct soap *soap, ns2__setCarsStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setCarsStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setCarsStatusResponse(struct soap *soap, const char *tag, int id, ns2__setCarsStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setCarsStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setCarsStatusResponse ** SOAP_FMAC4 soap_in_PointerTons2__setCarsStatusResponse(struct soap *soap, const char *tag, ns2__setCarsStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setCarsStatusResponse **)soap_malloc(soap, sizeof(ns2__setCarsStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setCarsStatusResponse *)soap_instantiate_ns2__setCarsStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setCarsStatusResponse ** p = (ns2__setCarsStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setCarsStatusResponse, sizeof(ns2__setCarsStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setCarsStatusResponse(struct soap *soap, ns2__setCarsStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setCarsStatusResponse);
	if (soap_out_PointerTons2__setCarsStatusResponse(soap, tag?tag:"ns2:setCarsStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setCarsStatusResponse ** SOAP_FMAC4 soap_get_PointerTons2__setCarsStatusResponse(struct soap *soap, ns2__setCarsStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setCarsStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setCarsStatus(struct soap *soap, ns2__setCarsStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setCarsStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setCarsStatus(struct soap *soap, const char *tag, int id, ns2__setCarsStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setCarsStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setCarsStatus ** SOAP_FMAC4 soap_in_PointerTons2__setCarsStatus(struct soap *soap, const char *tag, ns2__setCarsStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setCarsStatus **)soap_malloc(soap, sizeof(ns2__setCarsStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setCarsStatus *)soap_instantiate_ns2__setCarsStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setCarsStatus ** p = (ns2__setCarsStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setCarsStatus, sizeof(ns2__setCarsStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setCarsStatus(struct soap *soap, ns2__setCarsStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setCarsStatus);
	if (soap_out_PointerTons2__setCarsStatus(soap, tag?tag:"ns2:setCarsStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setCarsStatus ** SOAP_FMAC4 soap_get_PointerTons2__setCarsStatus(struct soap *soap, ns2__setCarsStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setCarsStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__sendPhoneMessageResponse(struct soap *soap, ns2__sendPhoneMessageResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__sendPhoneMessageResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__sendPhoneMessageResponse(struct soap *soap, const char *tag, int id, ns2__sendPhoneMessageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__sendPhoneMessageResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__sendPhoneMessageResponse ** SOAP_FMAC4 soap_in_PointerTons2__sendPhoneMessageResponse(struct soap *soap, const char *tag, ns2__sendPhoneMessageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__sendPhoneMessageResponse **)soap_malloc(soap, sizeof(ns2__sendPhoneMessageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__sendPhoneMessageResponse *)soap_instantiate_ns2__sendPhoneMessageResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__sendPhoneMessageResponse ** p = (ns2__sendPhoneMessageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__sendPhoneMessageResponse, sizeof(ns2__sendPhoneMessageResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__sendPhoneMessageResponse(struct soap *soap, ns2__sendPhoneMessageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__sendPhoneMessageResponse);
	if (soap_out_PointerTons2__sendPhoneMessageResponse(soap, tag?tag:"ns2:sendPhoneMessageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__sendPhoneMessageResponse ** SOAP_FMAC4 soap_get_PointerTons2__sendPhoneMessageResponse(struct soap *soap, ns2__sendPhoneMessageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__sendPhoneMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__sendPhoneMessage(struct soap *soap, ns2__sendPhoneMessage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__sendPhoneMessage))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__sendPhoneMessage(struct soap *soap, const char *tag, int id, ns2__sendPhoneMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__sendPhoneMessage);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__sendPhoneMessage ** SOAP_FMAC4 soap_in_PointerTons2__sendPhoneMessage(struct soap *soap, const char *tag, ns2__sendPhoneMessage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__sendPhoneMessage **)soap_malloc(soap, sizeof(ns2__sendPhoneMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__sendPhoneMessage *)soap_instantiate_ns2__sendPhoneMessage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__sendPhoneMessage ** p = (ns2__sendPhoneMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__sendPhoneMessage, sizeof(ns2__sendPhoneMessage), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__sendPhoneMessage(struct soap *soap, ns2__sendPhoneMessage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__sendPhoneMessage);
	if (soap_out_PointerTons2__sendPhoneMessage(soap, tag?tag:"ns2:sendPhoneMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__sendPhoneMessage ** SOAP_FMAC4 soap_get_PointerTons2__sendPhoneMessage(struct soap *soap, ns2__sendPhoneMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__sendPhoneMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getMyCarsInfResponse(struct soap *soap, ns2__getMyCarsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getMyCarsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getMyCarsInfResponse(struct soap *soap, const char *tag, int id, ns2__getMyCarsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getMyCarsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getMyCarsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getMyCarsInfResponse(struct soap *soap, const char *tag, ns2__getMyCarsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getMyCarsInfResponse **)soap_malloc(soap, sizeof(ns2__getMyCarsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getMyCarsInfResponse *)soap_instantiate_ns2__getMyCarsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getMyCarsInfResponse ** p = (ns2__getMyCarsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getMyCarsInfResponse, sizeof(ns2__getMyCarsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getMyCarsInfResponse(struct soap *soap, ns2__getMyCarsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getMyCarsInfResponse);
	if (soap_out_PointerTons2__getMyCarsInfResponse(soap, tag?tag:"ns2:getMyCarsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getMyCarsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getMyCarsInfResponse(struct soap *soap, ns2__getMyCarsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getMyCarsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getMyCarsInf(struct soap *soap, ns2__getMyCarsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getMyCarsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getMyCarsInf(struct soap *soap, const char *tag, int id, ns2__getMyCarsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getMyCarsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getMyCarsInf ** SOAP_FMAC4 soap_in_PointerTons2__getMyCarsInf(struct soap *soap, const char *tag, ns2__getMyCarsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getMyCarsInf **)soap_malloc(soap, sizeof(ns2__getMyCarsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getMyCarsInf *)soap_instantiate_ns2__getMyCarsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getMyCarsInf ** p = (ns2__getMyCarsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getMyCarsInf, sizeof(ns2__getMyCarsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getMyCarsInf(struct soap *soap, ns2__getMyCarsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getMyCarsInf);
	if (soap_out_PointerTons2__getMyCarsInf(soap, tag?tag:"ns2:getMyCarsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getMyCarsInf ** SOAP_FMAC4 soap_get_PointerTons2__getMyCarsInf(struct soap *soap, ns2__getMyCarsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getMyCarsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getUserCustomInfResponse(struct soap *soap, ns2__getUserCustomInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getUserCustomInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getUserCustomInfResponse(struct soap *soap, const char *tag, int id, ns2__getUserCustomInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getUserCustomInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getUserCustomInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getUserCustomInfResponse(struct soap *soap, const char *tag, ns2__getUserCustomInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getUserCustomInfResponse **)soap_malloc(soap, sizeof(ns2__getUserCustomInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getUserCustomInfResponse *)soap_instantiate_ns2__getUserCustomInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getUserCustomInfResponse ** p = (ns2__getUserCustomInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getUserCustomInfResponse, sizeof(ns2__getUserCustomInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getUserCustomInfResponse(struct soap *soap, ns2__getUserCustomInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getUserCustomInfResponse);
	if (soap_out_PointerTons2__getUserCustomInfResponse(soap, tag?tag:"ns2:getUserCustomInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getUserCustomInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getUserCustomInfResponse(struct soap *soap, ns2__getUserCustomInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getUserCustomInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getUserCustomInf(struct soap *soap, ns2__getUserCustomInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getUserCustomInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getUserCustomInf(struct soap *soap, const char *tag, int id, ns2__getUserCustomInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getUserCustomInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getUserCustomInf ** SOAP_FMAC4 soap_in_PointerTons2__getUserCustomInf(struct soap *soap, const char *tag, ns2__getUserCustomInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getUserCustomInf **)soap_malloc(soap, sizeof(ns2__getUserCustomInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getUserCustomInf *)soap_instantiate_ns2__getUserCustomInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getUserCustomInf ** p = (ns2__getUserCustomInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getUserCustomInf, sizeof(ns2__getUserCustomInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getUserCustomInf(struct soap *soap, ns2__getUserCustomInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getUserCustomInf);
	if (soap_out_PointerTons2__getUserCustomInf(soap, tag?tag:"ns2:getUserCustomInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getUserCustomInf ** SOAP_FMAC4 soap_get_PointerTons2__getUserCustomInf(struct soap *soap, ns2__getUserCustomInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getUserCustomInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getFavoriteSpecialLineInfResponse(struct soap *soap, ns2__getFavoriteSpecialLineInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getFavoriteSpecialLineInfResponse(struct soap *soap, const char *tag, int id, ns2__getFavoriteSpecialLineInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getFavoriteSpecialLineInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getFavoriteSpecialLineInfResponse(struct soap *soap, const char *tag, ns2__getFavoriteSpecialLineInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getFavoriteSpecialLineInfResponse **)soap_malloc(soap, sizeof(ns2__getFavoriteSpecialLineInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getFavoriteSpecialLineInfResponse *)soap_instantiate_ns2__getFavoriteSpecialLineInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getFavoriteSpecialLineInfResponse ** p = (ns2__getFavoriteSpecialLineInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getFavoriteSpecialLineInfResponse, sizeof(ns2__getFavoriteSpecialLineInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getFavoriteSpecialLineInfResponse(struct soap *soap, ns2__getFavoriteSpecialLineInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getFavoriteSpecialLineInfResponse);
	if (soap_out_PointerTons2__getFavoriteSpecialLineInfResponse(soap, tag?tag:"ns2:getFavoriteSpecialLineInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getFavoriteSpecialLineInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getFavoriteSpecialLineInfResponse(struct soap *soap, ns2__getFavoriteSpecialLineInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getFavoriteSpecialLineInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getFavoriteSpecialLineInf(struct soap *soap, ns2__getFavoriteSpecialLineInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getFavoriteSpecialLineInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getFavoriteSpecialLineInf(struct soap *soap, const char *tag, int id, ns2__getFavoriteSpecialLineInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getFavoriteSpecialLineInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getFavoriteSpecialLineInf ** SOAP_FMAC4 soap_in_PointerTons2__getFavoriteSpecialLineInf(struct soap *soap, const char *tag, ns2__getFavoriteSpecialLineInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getFavoriteSpecialLineInf **)soap_malloc(soap, sizeof(ns2__getFavoriteSpecialLineInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getFavoriteSpecialLineInf *)soap_instantiate_ns2__getFavoriteSpecialLineInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getFavoriteSpecialLineInf ** p = (ns2__getFavoriteSpecialLineInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getFavoriteSpecialLineInf, sizeof(ns2__getFavoriteSpecialLineInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getFavoriteSpecialLineInf(struct soap *soap, ns2__getFavoriteSpecialLineInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getFavoriteSpecialLineInf);
	if (soap_out_PointerTons2__getFavoriteSpecialLineInf(soap, tag?tag:"ns2:getFavoriteSpecialLineInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getFavoriteSpecialLineInf ** SOAP_FMAC4 soap_get_PointerTons2__getFavoriteSpecialLineInf(struct soap *soap, ns2__getFavoriteSpecialLineInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getFavoriteSpecialLineInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__collectSpecialLineResponse(struct soap *soap, ns2__collectSpecialLineResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__collectSpecialLineResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__collectSpecialLineResponse(struct soap *soap, const char *tag, int id, ns2__collectSpecialLineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__collectSpecialLineResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__collectSpecialLineResponse ** SOAP_FMAC4 soap_in_PointerTons2__collectSpecialLineResponse(struct soap *soap, const char *tag, ns2__collectSpecialLineResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__collectSpecialLineResponse **)soap_malloc(soap, sizeof(ns2__collectSpecialLineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__collectSpecialLineResponse *)soap_instantiate_ns2__collectSpecialLineResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__collectSpecialLineResponse ** p = (ns2__collectSpecialLineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__collectSpecialLineResponse, sizeof(ns2__collectSpecialLineResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__collectSpecialLineResponse(struct soap *soap, ns2__collectSpecialLineResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__collectSpecialLineResponse);
	if (soap_out_PointerTons2__collectSpecialLineResponse(soap, tag?tag:"ns2:collectSpecialLineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__collectSpecialLineResponse ** SOAP_FMAC4 soap_get_PointerTons2__collectSpecialLineResponse(struct soap *soap, ns2__collectSpecialLineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__collectSpecialLineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__collectSpecialLine(struct soap *soap, ns2__collectSpecialLine *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__collectSpecialLine))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__collectSpecialLine(struct soap *soap, const char *tag, int id, ns2__collectSpecialLine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__collectSpecialLine);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__collectSpecialLine ** SOAP_FMAC4 soap_in_PointerTons2__collectSpecialLine(struct soap *soap, const char *tag, ns2__collectSpecialLine **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__collectSpecialLine **)soap_malloc(soap, sizeof(ns2__collectSpecialLine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__collectSpecialLine *)soap_instantiate_ns2__collectSpecialLine(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__collectSpecialLine ** p = (ns2__collectSpecialLine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__collectSpecialLine, sizeof(ns2__collectSpecialLine), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__collectSpecialLine(struct soap *soap, ns2__collectSpecialLine *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__collectSpecialLine);
	if (soap_out_PointerTons2__collectSpecialLine(soap, tag?tag:"ns2:collectSpecialLine", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__collectSpecialLine ** SOAP_FMAC4 soap_get_PointerTons2__collectSpecialLine(struct soap *soap, ns2__collectSpecialLine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__collectSpecialLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getNewBulkGoodsInfResponse(struct soap *soap, ns2__getNewBulkGoodsInfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getNewBulkGoodsInfResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getNewBulkGoodsInfResponse(struct soap *soap, const char *tag, int id, ns2__getNewBulkGoodsInfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getNewBulkGoodsInfResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getNewBulkGoodsInfResponse ** SOAP_FMAC4 soap_in_PointerTons2__getNewBulkGoodsInfResponse(struct soap *soap, const char *tag, ns2__getNewBulkGoodsInfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getNewBulkGoodsInfResponse **)soap_malloc(soap, sizeof(ns2__getNewBulkGoodsInfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getNewBulkGoodsInfResponse *)soap_instantiate_ns2__getNewBulkGoodsInfResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getNewBulkGoodsInfResponse ** p = (ns2__getNewBulkGoodsInfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getNewBulkGoodsInfResponse, sizeof(ns2__getNewBulkGoodsInfResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getNewBulkGoodsInfResponse(struct soap *soap, ns2__getNewBulkGoodsInfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getNewBulkGoodsInfResponse);
	if (soap_out_PointerTons2__getNewBulkGoodsInfResponse(soap, tag?tag:"ns2:getNewBulkGoodsInfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getNewBulkGoodsInfResponse ** SOAP_FMAC4 soap_get_PointerTons2__getNewBulkGoodsInfResponse(struct soap *soap, ns2__getNewBulkGoodsInfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getNewBulkGoodsInfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getNewBulkGoodsInf(struct soap *soap, ns2__getNewBulkGoodsInf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getNewBulkGoodsInf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getNewBulkGoodsInf(struct soap *soap, const char *tag, int id, ns2__getNewBulkGoodsInf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getNewBulkGoodsInf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__getNewBulkGoodsInf ** SOAP_FMAC4 soap_in_PointerTons2__getNewBulkGoodsInf(struct soap *soap, const char *tag, ns2__getNewBulkGoodsInf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getNewBulkGoodsInf **)soap_malloc(soap, sizeof(ns2__getNewBulkGoodsInf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getNewBulkGoodsInf *)soap_instantiate_ns2__getNewBulkGoodsInf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__getNewBulkGoodsInf ** p = (ns2__getNewBulkGoodsInf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getNewBulkGoodsInf, sizeof(ns2__getNewBulkGoodsInf), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getNewBulkGoodsInf(struct soap *soap, ns2__getNewBulkGoodsInf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getNewBulkGoodsInf);
	if (soap_out_PointerTons2__getNewBulkGoodsInf(soap, tag?tag:"ns2:getNewBulkGoodsInf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getNewBulkGoodsInf ** SOAP_FMAC4 soap_get_PointerTons2__getNewBulkGoodsInf(struct soap *soap, ns2__getNewBulkGoodsInf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getNewBulkGoodsInf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
